import * as i1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { Pipe, EventEmitter, Component, Input, Output, ViewChild, Directive, HostBinding, HostListener, ChangeDetectionStrategy, NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import * as i3 from '@ngx-translate/core';
import { TranslateModule } from '@ngx-translate/core';
import * as i4 from '@avl-controls/ng-binders';
import { AvlNgBindersModule } from '@avl-controls/ng-binders';
import * as i5 from '@angular/forms';
import { NG_VALIDATORS, NgForm, FormsModule } from '@angular/forms';
import { LeafColumn, ColumnType } from '@avl-controls/datatable/dist/avl-datatable/column-definitions';
import * as i1$1 from '@angular/animations';
import { style, animate } from '@angular/animations';
import { BehaviorSubject, Observable, Subject } from 'rxjs';
import '@avl-controls/core/dist/avl-snackbar/avl-snackbar';
import { skipWhile, takeUntil, debounceTime, distinctUntilChanged, filter } from 'rxjs/operators';
import '@avl-controls/core/dist/avl-icon-button/avl-icon-button';
import '@avl-controls/core/dist/avl-icon/avl-icon';
import '@avl-controls/core/dist/avl-side-sheet/avl-side-sheet';
import '@avl-controls/core/dist/avl-checkbox/avl-checkbox';
import '@avl-controls/core/dist/avl-tooltip/avl-tooltip';
import '@avl-controls/core/dist/avl-date/avl-date';
import * as i1$2 from '@avl-ng-controls/dialog';
import { AvlDialogModule } from '@avl-ng-controls/dialog';
import * as i2 from '@avl-ng-controls/navigation';
import { AvlNavigationModule } from '@avl-ng-controls/navigation';

const NOTIFICATIONS_OVERFLOW_MENU = [
    {
        items: [
            {
                label: 'VizBox.NotificationMenu.MarkAllAsRead',
                action: 'markAllAsRead'
            },
            {
                label: 'VizBox.NotificationMenu.MarkAllAsUnread',
                action: 'markAllAsUnread'
            }
        ]
    }
];
const TYPE_ICON_MAPPINGS$1 = {
    [0 /* Error */]: 'cancel',
    [1 /* Warning */]: 'warning',
    [2 /* Info */]: 'info-outline',
    [3 /* OK */]: 'check'
};

const DEFAULT_PAGE_SIZE_OPTIONS = [
    { value: 15, label: 'Show 15 per page' },
    { value: 50, label: 'Show 50 per page' },
    { value: Number.MAX_SAFE_INTEGER, label: 'Show all' }
];
const DEFAULT_FILTERS = {
    type: {
        warning: undefined,
        error: undefined,
        info: undefined,
        ok: undefined
    },
    state: {
        read: undefined,
        unread: undefined
    },
    date: {
        dateFrom: undefined,
        dateTo: undefined
    },
    search: undefined
};
const DEFAULT_COLUMN_DEFINITIONS = [
    new LeafColumn('VizBox.NotificationDialog.Type', 'icon', ColumnType.Icon, false, false, 0.5),
    new LeafColumn('VizBox.NotificationDialog.Module', 'module', ColumnType.Text, true, false, 3),
    new LeafColumn('VizBox.NotificationDialog.Message', 'messageText', ColumnType.Text, true, false, 8),
    new LeafColumn('VizBox.NotificationDialog.Id', 'id', ColumnType.Number, false, false, 1),
    {
        caption: 'VizBox.NotificationDialog.Timestamp',
        valueField: 'timestamp',
        type: ColumnType.Date,
        sortable: false,
        filterable: false,
        flexWidth: 3,
        dateTimeOptions: { format: 'date-time-short' }
    },
    new LeafColumn('VizBox.NotificationDialog.State', 'currentIconToggle', ColumnType.Icon, false, false, 1)
];
const NOTIFICATION_TYPE_MAPPINGS = new Map([
    [0 /* Error */, 'error'],
    [1 /* Warning */, 'warning'],
    [2 /* Info */, 'info'],
    [3 /* OK */, 'ok'],
    [false, 'unread'],
    [true, 'read']
]);
const TYPE_ICON_MAPPINGS = {
    [0 /* Error */]: 'cancel',
    [1 /* Warning */]: 'warning',
    [2 /* Info */]: 'info-outline',
    [3 /* OK */]: 'check'
};
const STATE_ICON_MAPPINGS = {
    false: 'mail',
    true: 'communication:mail-outline'
};
const DEFAULT_ICON_STYLE = 'height:24px; width:24px;';
const TYPE_ICON_STYLE_MAPPINGS = {
    [0 /* Error */]: `--avl-icon-custom-color: var(--avl-error-color); ${DEFAULT_ICON_STYLE}`,
    [1 /* Warning */]: `--avl-icon-custom-color: var(--avl-warning-color); ${DEFAULT_ICON_STYLE}`,
    [2 /* Info */]: `--avl-icon-custom-color: var(--avl-icon-default-color); ${DEFAULT_ICON_STYLE}`,
    [3 /* OK */]: `--avl-icon-custom-color: var(--avl-ok-color); ${DEFAULT_ICON_STYLE}`
};
const TRANSLATION_BASE = 'VizBox.NotificationDialog.';
const ACTION_BUTTONS = [
    {
        id: 'unread',
        tooltip: TRANSLATION_BASE + "MarkSelectedAsUnread"
    },
    {
        id: 'read',
        tooltip: TRANSLATION_BASE + "MarkSelectedAsRead"
    }
];

/** Maps general avl notification list to table specific list */
class PrepareNotificationsPipe {
    transform(notifications, prepareFor) {
        return this[prepareFor](notifications);
    }
    dialog(notifications) {
        return notifications.map(notification => (Object.assign(Object.assign({}, notification), { icon: TYPE_ICON_MAPPINGS[notification.type], iconStyle: TYPE_ICON_STYLE_MAPPINGS[notification.type], currentIconToggle: STATE_ICON_MAPPINGS[String(notification.read)], currentIconToggleStyle: DEFAULT_ICON_STYLE, state: notification.read })));
    }
    menu(notifications) {
        return notifications.map(notification => (Object.assign(Object.assign({}, notification), { label: notification.messageText, sublabel: this.formatDateTime(notification.timestamp), icon: TYPE_ICON_MAPPINGS[notification.type], iconToggleUnchecked: 'mail', iconToggleChecked: 'communication:mail-outline', iconToggleValue: notification.read })));
    }
    formatDateTime(date) {
        return date === null
            ? ''
            : `${AvlLocalizationService.formatDateTime(date, {
                format: 'date-short'
            })} ${AvlLocalizationService.formatDateTime(date, { format: 'time-long' })}`;
    }
}
PrepareNotificationsPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: PrepareNotificationsPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
PrepareNotificationsPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: PrepareNotificationsPipe, name: "prepareNotifications" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: PrepareNotificationsPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'prepareNotifications'
                }]
        }] });

var __awaiter$2 = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class AvlNotificationMenuComponent {
    constructor() {
        this.open = false;
        this.openChange = new EventEmitter();
        this.openDetails = new EventEmitter();
        this.notificationStateChanged = new EventEmitter();
        this.markAllAsRead = new EventEmitter();
        this.markAllAsUnread = new EventEmitter();
        this.overflowMenuItems = [];
        this.numberOfUnreadNotifications = 0;
        this._notifications = [];
        this.overflowMenuHandlers = {
            markAllAsRead: () => {
                this.markAllAsRead.emit();
                this.numberOfUnreadNotifications = 0;
            },
            markAllAsUnread: () => {
                this.markAllAsUnread.emit();
                this.numberOfUnreadNotifications = this.notifications.length;
            },
            undefined: () => { }
        };
    }
    set notifications(notifications) {
        this.numberOfUnreadNotifications = notifications.filter(notif => !notif.read).length;
        this._notifications = notifications;
    }
    get notifications() {
        return this._notifications;
    }
    ngOnInit() {
        this.translateLabels();
    }
    ngAfterViewInit() {
        this.list.nativeElement.revertedList = true;
    }
    onNotificationStateChanged(event) {
        const notificationMenuItem = Object.assign({}, event.detail.value);
        const notification = Object.assign(Object.assign({}, notificationMenuItem), { read: notificationMenuItem.iconToggleValue });
        notification.read ? this.numberOfUnreadNotifications-- : this.numberOfUnreadNotifications++;
        this.notificationStateChanged.emit(notification);
        this.list.nativeElement.removeFocus();
    }
    onItemClicked(item) {
        this.overflowMenuHandlers[item.action]();
    }
    onOpenChanged(event) {
        if (!event.detail.value) {
            this.openChange.emit(false);
        }
    }
    onOverflowMenuClicked() {
        this.list.nativeElement.removeFocus();
    }
    onDetailsClicked() {
        this.open = false;
        this.openDetails.emit();
        this.openChange.emit(false);
    }
    /**Event fired when list item is clicked on
     * depending on the notification flag it opens in new tab
     */
    onListItemClicked(event) {
        const item = event.detail;
        if (item.link) {
            if (item.openInNewTab) {
                window.open(item.link, '_blank');
            }
            else {
                window.open(item.link, '_self');
            }
        }
    }
    translateLabels() {
        return __awaiter$2(this, void 0, void 0, function* () {
            if (!AvlLocalizationService || !AvlLocalizationService.translationService) {
                return;
            }
            this.overflowMenuItems = yield this.translateMenu(NOTIFICATIONS_OVERFLOW_MENU);
        });
    }
    translateMenu(menu) {
        return __awaiter$2(this, void 0, void 0, function* () {
            return yield Promise.all(menu.map((group) => __awaiter$2(this, void 0, void 0, function* () { return yield this.translateMenuGroup(group); })));
        });
    }
    translateMenuGroup(group) {
        return __awaiter$2(this, void 0, void 0, function* () {
            return {
                items: yield Promise.all(group.items.map((item) => __awaiter$2(this, void 0, void 0, function* () { return yield this.translateMenuItem(item); })))
            };
        });
    }
    translateMenuItem(item) {
        return __awaiter$2(this, void 0, void 0, function* () {
            const translateService = AvlLocalizationService.translationService;
            return Object.assign(Object.assign({}, item), { label: yield translateService.translate(item.label), sublabel: item.sublabel ? yield translateService.translate(item.sublabel) : null });
        });
    }
}
AvlNotificationMenuComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlNotificationMenuComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
AvlNotificationMenuComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.3", type: AvlNotificationMenuComponent, selector: "avl-notification-menu", inputs: { open: "open", trigger: "trigger", notifications: "notifications" }, outputs: { openChange: "openChange", openDetails: "openDetails", notificationStateChanged: "notificationStateChanged", markAllAsRead: "markAllAsRead", markAllAsUnread: "markAllAsUnread" }, viewQueries: [{ propertyName: "list", first: true, predicate: ["list"], descendants: true }], ngImport: i0, template: "<avl-popup\r\n  [noCloseOnInsideClick]=\"true\"\r\n  [open]=\"open\"\r\n  [trigger]=\"trigger\"\r\n  (open-changed)=\"onOpenChanged($event)\"\r\n>\r\n  <div id=\"header\">\r\n    <div id=\"headerText\">\r\n      <span>{{ 'VizBox.NotificationMenu.Notifications' | translate }}</span>\r\n      <span *ngIf=\"numberOfUnreadNotifications\"> ({{ numberOfUnreadNotifications }}) </span>\r\n    </div>\r\n    <avl-overflow-menu (itemClicked)=\"onItemClicked($event)\" [items]=\"overflowMenuItems\">\r\n      <avl-icon-button\r\n        icon=\"more-vert\"\r\n        slot=\"trigger\"\r\n        (click)=\"onOverflowMenuClicked()\"\r\n      ></avl-icon-button>\r\n    </avl-overflow-menu>\r\n  </div>\r\n  <avl-list\r\n    #list\r\n    [rows]=\"notifications | prepareNotifications: 'menu'\"\r\n    (row-changed)=\"onNotificationStateChanged($event)\"\r\n    (list-item-clicked)=\"onListItemClicked($event)\"\r\n  ></avl-list>\r\n  <div id=\"footer\">\r\n    <avl-button (click)=\"onDetailsClicked()\">{{\r\n      'VizBox.NotificationMenu.Details' | translate\r\n    }}</avl-button>\r\n  </div>\r\n</avl-popup>\r\n", styles: ["avl-popup{width:40%}avl-list{width:100%;height:250px;padding-top:8px;--avl-item-padding-left:16px;--avl-item-padding-right:16px;--notification-item-height:48px}#header{justify-content:space-between;padding:0 16px;border-bottom:1px solid var(--avl-overflow-menu-divider-color,var(--avl-divider-color))}#footer,#header{display:flex;align-items:center;box-sizing:border-box;height:56px}#footer{border-top:1px solid var(--avl-overflow-menu-divider-color,var(--avl-divider-color))}#headerText{font-size:20px;color:var(--avl-primary-text-color);overflow:hidden;white-space:nowrap;text-overflow:ellipsis}"], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i4.AvlOverflowMenuDirective, selector: "avl-overflow-menu", outputs: ["itemClicked"] }, { type: i4.AvlInteractionControlDirective, selector: "avl-button,avl-icon-button,avl-item,avl-search-bar,avl-radio-button,avl-upload,avl-snackbar", outputs: ["focusedChange"] }, { type: i4.AvlIconButtonDirective, selector: "avl-icon-button", outputs: ["badgeChange", "badgeValueChange"] }, { type: i4.AvlMultiSelectControlDirective, selector: "avl-datatable,avl-list,avl-chip-list, avl-chip-input", outputs: ["selectedIndexesChange", "selectedValuesChange"] }, { type: i4.AvlSingleSelectControlDirective, selector: "avl-datatable,avl-dropdown,avl-list,avl-radio-group,avl-app-switcher,avl-chip-list,avl-combo-box", outputs: ["selectedIndexChange", "selectedValueChange"] }, { type: i4.AvlListDirective, selector: "avl-list", inputs: ["readonly"], outputs: ["invalidChange", "overflowMenuItemClicked", "rightCheckboxChanged", "activeRowChanged", "rowReordered"] }], pipes: { "translate": i3.TranslatePipe, "prepareNotifications": PrepareNotificationsPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlNotificationMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'avl-notification-menu',
                    templateUrl: './avl-notification-menu.component.html',
                    styleUrls: ['./avl-notification-menu.component.css']
                }]
        }], propDecorators: { open: [{
                type: Input
            }], trigger: [{
                type: Input
            }], notifications: [{
                type: Input
            }], openChange: [{
                type: Output
            }], openDetails: [{
                type: Output
            }], notificationStateChanged: [{
                type: Output
            }], markAllAsRead: [{
                type: Output
            }], markAllAsUnread: [{
                type: Output
            }], list: [{
                type: ViewChild,
                args: ['list']
            }] } });

/** @hidden */
const ANIMATION_DURATION = 400;
/** @hidden */
const ACTION_BUTTON_MESSAGE = '_X more _TYPE notifications';
/** @hidden */
const MARGIN = 12;

class AnimateButton {
    constructor() {
        this.getInfoHeight = () => {
            return this.infoStackHeight > this.infoStackIndicatorHeight
                ? this.infoStackHeight
                : this.infoStackIndicatorHeight;
        };
        this.getWarningHeight = () => {
            return this.warningStackHeight > this.warningStackIndicatorHeight
                ? this.warningStackHeight
                : this.warningStackIndicatorHeight;
        };
        this.getOffsetHeight = (height) => {
            return height ? height + MARGIN * 2 : 0;
        };
    }
    ngOnChanges(changes) {
        const infoStackOffsetHeight = this.getOffsetHeight(this.getInfoHeight());
        const warningStackOffsetHeight = this.getOffsetHeight(this.getWarningHeight());
        this.styleTop = infoStackOffsetHeight + warningStackOffsetHeight + 'px';
    }
}
AnimateButton.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AnimateButton, deps: [], target: i0.ɵɵFactoryTarget.Directive });
AnimateButton.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.3", type: AnimateButton, selector: "[animateButton]", inputs: { increment: "increment", infoStackHeight: "infoStackHeight", warningStackHeight: "warningStackHeight", infoStackIndicatorHeight: "infoStackIndicatorHeight", warningStackIndicatorHeight: "warningStackIndicatorHeight" }, host: { properties: { "style.top": "this.styleTop" } }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AnimateButton, decorators: [{
            type: Directive,
            args: [{ selector: '[animateButton]' }]
        }], ctorParameters: function () { return []; }, propDecorators: { increment: [{
                type: Input
            }], infoStackHeight: [{
                type: Input
            }], warningStackHeight: [{
                type: Input
            }], infoStackIndicatorHeight: [{
                type: Input
            }], warningStackIndicatorHeight: [{
                type: Input
            }], styleTop: [{
                type: HostBinding,
                args: ['style.top']
            }] } });

/** @hidden */
class AnimateSnackbar {
    constructor(builder, el) {
        this.builder = builder;
        /** @hidden */
        this.defaultClass = true;
        this.getAnimation = (animationName, initialStyle) => {
            const elementWidth = this.element.nativeElement.offsetWidth - 3 * MARGIN;
            const inStackStyle = style({
                marginTop: MARGIN + 'px',
                marginLeft: MARGIN + 'px',
                marginRight: MARGIN + 'px',
                width: elementWidth + 'px'
            });
            switch (animationName) {
                case 4 /* FromStack */:
                    return [animate(ANIMATION_DURATION + 'ms ease-in', inStackStyle), initialStyle];
                case 3 /* ToStack */: {
                    return [initialStyle, animate(ANIMATION_DURATION + 'ms ease-in', inStackStyle)];
                }
                default:
                    return [initialStyle, animate('1ms ease-in', initialStyle)];
            }
        };
        this.element = el;
    }
    ngOnChanges(changes) {
        if (changes.animateSnackbar) {
            const isInStack = changes.animateSnackbar.currentValue === 3 /* ToStack */;
            if (isInStack) {
                this.move();
            }
            else if (changes.animateSnackbar.previousValue === 3 /* ToStack */) {
                this.move();
            }
        }
    }
    show(metadata) {
        if (this.player) {
            this.player.destroy();
        }
        if (metadata) {
            const factory = this.builder.build(metadata);
            const player = factory.create(this.element.nativeElement);
            player.play();
        }
    }
    move() {
        const animationMetadata = this.animate();
        this.show(animationMetadata);
    }
    animate() {
        const initialStyle = style({
            marginTop: '0',
            width: '100%',
            marginLeft: '0',
            marginRight: '0'
        });
        return this.getAnimation(this.animateSnackbar, initialStyle);
    }
}
AnimateSnackbar.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AnimateSnackbar, deps: [{ token: i1$1.AnimationBuilder }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AnimateSnackbar.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.3", type: AnimateSnackbar, selector: "[animateSnackbar]", inputs: { animateSnackbar: "animateSnackbar", positionAnimation: "positionAnimation", notification: "notification", reopen: "reopen" }, host: { properties: { "class.in-stack": "this.inStack", "class.no-animation": "this.noAnimation", "class.snackbar-container": "this.defaultClass" } }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AnimateSnackbar, decorators: [{
            type: Directive,
            args: [{ selector: '[animateSnackbar]' }]
        }], ctorParameters: function () { return [{ type: i1$1.AnimationBuilder }, { type: i0.ElementRef }]; }, propDecorators: { animateSnackbar: [{
                type: Input
            }], positionAnimation: [{
                type: Input
            }], notification: [{
                type: Input,
                args: ['notification']
            }], reopen: [{
                type: Input,
                args: ['reopen']
            }], inStack: [{
                type: HostBinding,
                args: ['class.in-stack']
            }], noAnimation: [{
                type: HostBinding,
                args: ['class.no-animation']
            }], defaultClass: [{
                type: HostBinding,
                args: ['class.snackbar-container']
            }] } });

class AnimateStack {
    constructor(builder, el) {
        this.builder = builder;
        this.getAnimation = (animationName, initialStyle) => {
            const allStyle = style('*');
            switch (animationName) {
                case 2 /* ToBottom */: {
                    return [
                        allStyle,
                        animate(ANIMATION_DURATION + 'ms ease-in', style({
                            top: this.styleTop + 'px',
                            zIndex: 0
                        }))
                    ];
                }
                case 1 /* ToTop */: {
                    return [allStyle, animate(ANIMATION_DURATION + 'ms ease-in', initialStyle)];
                }
                default:
                    return [initialStyle, animate('0ms', initialStyle)];
            }
        };
        this.element = el;
    }
    ngOnChanges(changes) {
        var _a;
        if (changes.animateStack) {
            this.move(this.previousStackHeight);
        }
        else if (changes.previousStackHeight) {
            this.move(changes === null || changes === void 0 ? void 0 : changes.previousStackHeight.currentValue);
        }
        else if (changes.snackbarMethodDescription) {
            if (((_a = changes.snackbarMethodDescription.currentValue) === null || _a === void 0 ? void 0 : _a.method) === 'show') {
                this.move(this.previousStackHeight);
            }
        }
    }
    show(metadata) {
        if (this.player) {
            this.player.destroy();
        }
        if (metadata) {
            const factory = this.builder.build(metadata);
            const player = factory.create(this.element.nativeElement);
            player.play();
        }
    }
    move(height) {
        if (this.animateStack === 2 /* ToBottom */) {
            this.styleTop = height + MARGIN * 2;
        }
        const animationMetadata = this.animate();
        this.show(animationMetadata);
    }
    animate() {
        const initialStyle = style({
            top: '0',
            width: '100%',
            left: '0',
            zIndex: 1
        });
        return this.getAnimation(this.animateStack, initialStyle);
    }
}
AnimateStack.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AnimateStack, deps: [{ token: i1$1.AnimationBuilder }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AnimateStack.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.3", type: AnimateStack, selector: "[animateStack]", inputs: { animateStack: "animateStack", notification: "notification", previousStackHeight: "previousStackHeight", snackbarMethodDescription: "snackbarMethodDescription", reopen: "reopen" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AnimateStack, decorators: [{
            type: Directive,
            args: [{ selector: '[animateStack]' }]
        }], ctorParameters: function () { return [{ type: i1$1.AnimationBuilder }, { type: i0.ElementRef }]; }, propDecorators: { animateStack: [{
                type: Input
            }], notification: [{
                type: Input
            }], previousStackHeight: [{
                type: Input
            }], snackbarMethodDescription: [{
                type: Input
            }], reopen: [{
                type: Input
            }] } });

/**@hidden */
class SnackbarMethodDescription {
    constructor(method, animate) {
        this.method = method;
        this.animate = animate;
    }
}
class ShowHideSnackbarDirective {
    constructor(el) {
        this.element = el;
    }
    ngOnChanges(changes) {
        var _a, _b, _c, _d;
        if (changes.methodDescription) {
            if (((_a = changes.methodDescription.currentValue) === null || _a === void 0 ? void 0 : _a.method) === 'show') {
                setTimeout(() => {
                    var _a, _b;
                    return (_a = this.element.nativeElement) === null || _a === void 0 ? void 0 : _a.showSnackbar('relative', !((_b = changes.methodDescription.currentValue) === null || _b === void 0 ? void 0 : _b.animate));
                }, 0);
            }
            else if (((_b = changes.methodDescription.currentValue) === null || _b === void 0 ? void 0 : _b.method) === 'hide') {
                (_c = this.element.nativeElement) === null || _c === void 0 ? void 0 : _c.hideSnackbar((_d = changes.methodDescription.currentValue) === null || _d === void 0 ? void 0 : _d.animate);
            }
        }
    }
}
ShowHideSnackbarDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: ShowHideSnackbarDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
ShowHideSnackbarDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.3", type: ShowHideSnackbarDirective, selector: "[showHideSnackbar]", inputs: { methodDescription: "methodDescription" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: ShowHideSnackbarDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[showHideSnackbar]' }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { methodDescription: [{
                type: Input
            }] } });

class SnackbarListener {
    constructor() {
        /** @hidden */
        this.notificationClicked = new EventEmitter();
        /** @hidden */
        this.buttonClicked = new EventEmitter();
        /** @hidden */
        this.notificationDismissed = new EventEmitter();
    }
    onNotificationClicked(event) {
        this.notificationClicked.emit(event);
    }
    onButtonClicked(event) {
        if (event instanceof Event) {
            this.buttonClicked.emit(event);
        }
    }
    onNotificationDismissed(event) {
        if (event instanceof Event) {
            this.notificationDismissed.emit(event);
        }
    }
}
SnackbarListener.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: SnackbarListener, deps: [], target: i0.ɵɵFactoryTarget.Directive });
SnackbarListener.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.3", type: SnackbarListener, selector: "[snackbarListener]", outputs: { notificationClicked: "notificationClicked", buttonClicked: "buttonClicked", notificationDismissed: "notificationDismissed" }, host: { listeners: { "notification-clicked": "onNotificationClicked($event)", "button-clicked": "onButtonClicked($event)", "notification-dismissed": "onNotificationDismissed($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: SnackbarListener, decorators: [{
            type: Directive,
            args: [{ selector: '[snackbarListener]' }]
        }], propDecorators: { notificationClicked: [{
                type: Output
            }], buttonClicked: [{
                type: Output
            }], notificationDismissed: [{
                type: Output
            }], onNotificationClicked: [{
                type: HostListener,
                args: ['notification-clicked', ['$event']]
            }], onButtonClicked: [{
                type: HostListener,
                args: ['button-clicked', ['$event']]
            }], onNotificationDismissed: [{
                type: HostListener,
                args: ['notification-dismissed', ['$event']]
            }] } });

var __awaiter$1 = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/** @hidden */
class SnackbarStack {
    constructor(stackType) {
        /** @hidden */
        this.notificationList = [];
        /** @hidden */
        this.activeNotification$ = new BehaviorSubject(undefined);
        /** @hidden */
        this.stackIndicator = false;
        /** @hidden */
        this.actionButtonMessage = ACTION_BUTTON_MESSAGE;
        this.openNextNotification = (stackType) => {
            this.methodDescription = new SnackbarMethodDescription('show', !this.reopen);
            if (!this.reopen) {
                this.stackAnimation = 1 /* ToTop */;
            }
            else {
                this.stackAnimation = 4 /* FromStack */;
            }
            this.setStackIndicatorProperties(stackType);
            this.reopen = false;
            this.dismissedSilently = false;
        };
        this.resetValues = () => {
            this.notificationList = [];
            this.previousNotification = undefined;
            this.stackIndicator = undefined;
        };
        this.setStackIndicatorProperties = (stackType) => {
            const notificationsCount = this.notificationList.length;
            this.stackIndicator = notificationsCount > 1;
            const timeout = setTimeout(() => {
                this.previousNotification = this.notificationList[notificationsCount - 1];
                this.buttonLabel = this.setButtonLabel(notificationsCount, stackType);
                this.stackIndicatorButtonLabel = this.setButtonLabel(notificationsCount - 1, stackType);
                clearTimeout(timeout);
            }, this.previousNotification ? ANIMATION_DURATION : 0);
        };
        this.setButtonLabel = (notificationsCount, type) => {
            return notificationsCount > 0
                ? this.actionButtonMessage
                    .replace('_TYPE ', type === 'info' ? '' : type + ' ')
                    .replace('_X', String(notificationsCount))
                : null;
        };
        this.translateLabels();
        this.methodDescription = new SnackbarMethodDescription(undefined, undefined);
        this.activeNotification$
            .pipe(skipWhile(notification => notification === undefined))
            .subscribe((notification) => {
            if (notification) {
                if (this.notificationList.length > 0) {
                    const timeout = setTimeout(() => {
                        this.openNextNotification(stackType);
                        clearTimeout(timeout);
                    }, this.previousNotification ? ANIMATION_DURATION : 0);
                }
                else {
                    this.openNextNotification(stackType);
                }
            }
            else {
                this.resetValues();
            }
        });
    }
    translateLabels() {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (!AvlLocalizationService || !AvlLocalizationService.translationService) {
                return;
            }
            const translationService = AvlLocalizationService.translationService;
            this.actionButtonMessage = yield translationService.translate('VizBox.NotificationContainer._X_more_TYPE_notifications');
        });
    }
}

const NOTIFICATION_TYPE = new Map([
    [0 /* Error */, 'Error'],
    [1 /* Warning */, 'Warning'],
    [2 /* Info */, 'Info'],
    [3 /* OK */, 'OK']
]);
class AvlNotificationContainerComponent {
    constructor(cdRef) {
        this.cdRef = cdRef;
        /** Observable emits notifications. Default observable emits dummy notifications every 3s for 100s. */
        this.notification$ = new Observable(function subscribe(subscriber) {
            let i = 0;
            const intervalId = setInterval(() => {
                const warning = Math.round(Math.random());
                subscriber.next({
                    id: i++,
                    module: 'notification-container',
                    timestamp: new Date(),
                    type: warning ? 1 /* Warning */ : 2 /* Info */,
                    messageText: 'Snackbar with notification' + new Date().toTimeString(),
                    read: false,
                    link: 'https://vizbox.avl.com'
                });
            }, 3000);
            setTimeout(() => {
                clearInterval(intervalId);
            }, 100000);
        });
        this.openMenu = new EventEmitter();
        /** @hidden */
        this.stackHeight = {};
        /** @hidden */
        this.notificationList = [];
        this.destroyed$ = new Subject();
        /** @hidden */
        this.onButtonClicked = (event) => {
            if (event) {
                this.openMenu.emit();
                this.dismissAll();
            }
        };
        /** @hidden */
        this.onNotificationDismissed = (event, notification) => {
            var _a, _b;
            if (event) {
                const snackType = (_b = (_a = event.target) === null || _a === void 0 ? void 0 : _a.id) === null || _b === void 0 ? void 0 : _b.replace('Snackbar', '');
                this.removeNotification(notification, snackType);
            }
        };
        /** @hidden */
        this.openFromStack = (notification) => {
            const stackName = this.getStackName(notification.type);
            this[stackName].methodDescription = new SnackbarMethodDescription('hide', true);
        };
        /** @hidden */
        this.dismissAll = () => {
            this.notificationList = [];
            this.warningStack.activeNotification$.next(undefined);
            this.infoStack.activeNotification$.next(undefined);
        };
        this.handleNotification = (notification) => {
            this.previousNotification = this.notificationList[this.notificationList.length - 1];
            this.notificationList.push(notification);
            this.updateStackActiveNotification(notification);
            this.setStackAnimation(notification.type);
        };
        this.updateStackActiveNotification = (notification) => {
            var _a;
            const stackName = this.getStack(notification === null || notification === void 0 ? void 0 : notification.type);
            this.updateStackNotificationList(notification.type);
            this.activeNotification = notification;
            if (this[stackName].notificationList.length > 1) {
                this.reopen = true;
                if (((_a = this.previousNotification) === null || _a === void 0 ? void 0 : _a.type) === notification.type) {
                    this[stackName].snackbarAnimation = 3 /* ToStack */;
                    // silently dismiss notification after previous notification animation
                    const timeout = setTimeout(() => {
                        this.silentlyDismissNotification(stackName);
                        this[stackName].snackbarAnimation = null;
                        clearTimeout(timeout);
                    }, ANIMATION_DURATION);
                }
                else {
                    this.silentlyDismissNotification(stackName);
                }
            }
            else {
                this[stackName].activeNotification$.next(notification);
            }
        };
        this.updateStackNotificationList = (notificationType) => {
            const stack = this[this.getStack(notificationType)];
            if (stack) {
                stack.notificationList = this.notificationList.filter(item => item.type === notificationType);
            }
            return stack.notificationList;
        };
        this.silentlyDismissNotification = (stackName) => {
            this[stackName].dismissedSilently = true;
            this[stackName].methodDescription = new SnackbarMethodDescription('hide', false);
        };
        this.setStackAnimation = (notificationType, animation) => {
            var _a, _b, _c;
            const currentStack = this.getStack(notificationType);
            const previousStack = this.getStack(notificationType, true);
            if (((_b = (_a = this[previousStack]) === null || _a === void 0 ? void 0 : _a.notificationList) === null || _b === void 0 ? void 0 : _b.length) > 0 &&
                ((_c = this.previousNotification) === null || _c === void 0 ? void 0 : _c.type) !== notificationType) {
                this[previousStack].stackAnimation = animation || 2 /* ToBottom */;
                this[currentStack].stackAnimation =
                    animation === 1 /* ToTop */
                        ? 2 /* ToBottom */
                        : 1 /* ToTop */;
            }
        };
        this.removeNotification = (notification, snackType) => {
            var _a;
            const stackName = this.getStack(notification === null || notification === void 0 ? void 0 : notification.type);
            if (this[stackName].dismissedSilently) {
                //notification dismissed silently
                const stackName = this.getStack((_a = this.activeNotification) === null || _a === void 0 ? void 0 : _a.type);
                this[stackName].activeNotification$.next(this.activeNotification);
                this.reopen = false;
            }
            else {
                //notification dismissed
                this.notificationList = this.notificationList.filter(currentNotification => currentNotification.id !== notification.id);
                this.reopenLastNotification(notification, stackName);
            }
        };
        this.reopenLastNotification = (notification, stackName) => {
            var _a;
            let stackNotificationList = (_a = this[stackName]) === null || _a === void 0 ? void 0 : _a.notificationList;
            if (this.isLastNotificationDismissed(notification, this[stackName]) &&
                (stackNotificationList === null || stackNotificationList === void 0 ? void 0 : stackNotificationList.length) > 0) {
                this[stackName].reopen = true;
                stackNotificationList = this.updateStackNotificationList(notification.type);
                const lastNotification = stackNotificationList[stackNotificationList.length - 1];
                if (lastNotification) {
                    this[stackName].activeNotification$.next(lastNotification);
                }
                else {
                    this[stackName].stackIndicator = false;
                    this[stackName].reopen = false;
                    this[stackName].animateStack = 2 /* ToBottom */;
                    this.setStackAnimation(notification.type, 1 /* ToTop */);
                }
            }
        };
        this.isLastNotificationDismissed = (notification, stack) => {
            const lastNotification = stack.notificationList[stack.notificationList.length - 1];
            return (lastNotification === null || lastNotification === void 0 ? void 0 : lastNotification.id) === (notification === null || notification === void 0 ? void 0 : notification.id);
        };
        this.getStackName = (stackType) => {
            return stackType === 1 ? 'warningStack' : 'infoStack';
        };
        this.warningStack = new SnackbarStack(String(NOTIFICATION_TYPE.get(1 /* Warning */)).toLowerCase());
        this.infoStack = new SnackbarStack(String(NOTIFICATION_TYPE.get(2 /* Info */)).toLowerCase());
    }
    ngOnDestroy() {
        this.destroyed$.next();
        this.destroyed$.complete();
    }
    ngAfterViewChecked() {
        this.cdRef.detectChanges();
    }
    /** @hidden */
    ngOnInit() {
        var _a, _b;
        this.positionTop = ((_a = document.querySelector('main')) === null || _a === void 0 ? void 0 : _a.offsetTop) + 12 + 'px';
        (_b = this.notification$) === null || _b === void 0 ? void 0 : _b.pipe(takeUntil(this.destroyed$)).subscribe(notification => {
            this.handleNotification(notification);
        });
    }
    /** @hidden */
    /** Event fired when notification snackbar is clicked
     * depending on the notification flag it opens in new tab
    */
    onNotificationSnackbarClicked(event) {
        const snackbar = event.detail;
        if (snackbar.link) {
            if (snackbar.openInNewTab) {
                window.open(snackbar.link, '_blank');
            }
            else {
                window.open(snackbar.link, '_self');
            }
        }
    }
    getStack(notificationType, previous) {
        let stackType;
        if (notificationType === 1 /* Warning */ ||
            notificationType === 0 /* Error */) {
            stackType = previous ? 2 /* Info */ : 1 /* Warning */;
        }
        else {
            stackType = previous ? 1 /* Warning */ : 2 /* Info */;
        }
        return this.getStackName(stackType);
    }
}
AvlNotificationContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlNotificationContainerComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
AvlNotificationContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.3", type: AvlNotificationContainerComponent, selector: "avl-notification-container", inputs: { displayIcon: ["display-icon", "displayIcon"], notification$: "notification$" }, outputs: { openMenu: "openMenu" }, host: { properties: { "style.top": "this.positionTop" } }, viewQueries: [{ propertyName: "warningStackElement", first: true, predicate: ["warningStackElement"], descendants: true }, { propertyName: "infoStackElement", first: true, predicate: ["infoStackElement"], descendants: true }, { propertyName: "infoStackIndicatorElement", first: true, predicate: ["infoStackIndicatorElement"], descendants: true }, { propertyName: "warningStackIndicatorElement", first: true, predicate: ["infoStackIndicatorElement"], descendants: true }], ngImport: i0, template: "<div class=\"snackbar\" *ngIf=\"notification$ | async as notification\">\r\n  <div\r\n    [animateStack]=\"warningStack?.stackAnimation\"\r\n    [previousStackHeight] = \"infoStack.notificationList.length>0 ? infoSnackElement.offsetHeight : 0\"\r\n    [snackbarMethodDescription] = \"warningStack.methodDescription\"\r\n    class=\"snackbar-stack\"\r\n    id=\"warningStack\"\r\n    #warningStackElement\r\n  >\r\n    <div [animateSnackbar]=\"warningStack.snackbarAnimation\" id=\"warningSnack\" #warningSnackElement>\r\n      <avl-snackbar\r\n        *ngIf=\"warningStack.activeNotification$ | async as activeWarningNotification\"\r\n        id=\"warningSnackbar\"\r\n        [message]=\"activeWarningNotification?.messageText\"\r\n        [openInNewTab]=\"activeWarningNotification.openInNewTab\"\r\n        [actionButtonLabel]=\"warningStack.stackIndicatorButtonLabel\"\r\n        [link]=\"activeWarningNotification.link\"\r\n        [messageType]=\"activeWarningNotification.type\"\r\n        sliding\r\n        (buttonClicked)=\"onButtonClicked($event)\"\r\n        (notificationDismissed)=\"onNotificationDismissed($event, activeWarningNotification)\"\r\n        snackbarListener\r\n        #warningSnackbar\r\n        showHideSnackbar=\"warningSnackbar\"\r\n        [methodDescription]=\"warningStack.methodDescription\"\r\n        (snackbar-clicked)=\"onNotificationSnackbarClicked($event)\"\r\n      ></avl-snackbar>\r\n    </div>\r\n\r\n    <div class=\"stack-indicator-container\" *ngIf=\"warningStack.notificationList.length>1\" #warningStackIndicator>\r\n      <div class=\"stack-indicator\">\r\n        <div class=\"notification-container\">\r\n          <div [ngClass]=\"{'notification': true, 'has-action': warningStack.stackIndicatorButtonLabel}\">\r\n            <avl-icon icon=\"icons:warning\" id=\"warningIcon\" class=\"warning\"></avl-icon>\r\n            <p id=\"snackbarMessage\">{{ warningStack.previousNotification?.messageText }}</p>\r\n            <avl-icon-button id=\"closeButton\" icon=\"icons:close\"></avl-icon-button>\r\n          </div>\r\n          <button id=\"actionButton\" *ngIf=\"warningStack.stackIndicatorButtonLabel\" (click)=\"openFromStack(warningStack.previousNotification)\">\r\n            <div class=\"button-label\">{{ warningStack.stackIndicatorButtonLabel }}</div>\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <div\r\n    class=\"snackbar-stack\"\r\n    id=\"infoStack\"\r\n    [animateStack]=\"infoStack?.stackAnimation\"\r\n    [previousStackHeight] = \"infoStack.notificationList.length>0 ? warningSnackElement.offsetHeight : 0\"\r\n    [snackbarMethodDescription] = \"infoStack.methodDescription\"\r\n    #infoStackElement\r\n  >\r\n    <div [animateSnackbar]=\"infoStack.snackbarAnimation\" id=\"infoSnack\" #infoSnackElement>\r\n      <avl-snackbar\r\n        id=\"infoSnackbar\"\r\n        *ngIf=\"infoStack.activeNotification$ | async as activeInfoNotification\"\r\n        [message]=\"activeInfoNotification.messageText\"\r\n        [openInNewTab]=\"activeInfoNotification.openInNewTab\"\r\n        [actionButtonLabel]=\"infoStack.stackIndicatorButtonLabel\"\r\n        [link]=\"activeInfoNotification.link\"\r\n        [messageType]=\"activeInfoNotification.type\"\r\n        [displayIcon]=\"displayIcon\"\r\n        sliding\r\n        (buttonClicked)=\"onButtonClicked($event)\"\r\n        (notificationDismissed)=\"onNotificationDismissed($event, activeInfoNotification)\"\r\n        snackbarListener\r\n        #infoSnackbar\r\n        showHideSnackbar=\"infoSnackbar\"\r\n        [methodDescription]=\"infoStack.methodDescription\"\r\n        (snackbar-clicked)=\"onNotificationSnackbarClicked($event)\"\r\n      ></avl-snackbar>\r\n    </div>\r\n\r\n    <div class=\"stack-indicator-container\" *ngIf=\"infoStack.notificationList.length>1\" #infoStackIndicator>\r\n      <div class=\"stack-indicator\">\r\n        <div class=\"notification-container\">\r\n          <div [ngClass]=\"{'notification': true, 'has-action': infoStack.stackIndicatorButtonLabel}\">\r\n            <p id=\"snackbarMessage\">{{ infoStack.previousNotification?.messageText }}</p>\r\n            <avl-icon-button id=\"closeButton\" icon=\"icons:close\"></avl-icon-button>\r\n          </div>\r\n        </div>\r\n        <button id=\"actionButton\" *ngIf=\"infoStack.stackIndicatorButtonLabel\" (click)=\"openFromStack(infoStack.previousNotification)\">\r\n          <div class=\"button-label\">{{ infoStack.stackIndicatorButtonLabel }}</div>\r\n        </button>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <div\r\n    animateButton\r\n    [infoStackHeight]=\"infoStack?.notificationList?.length > 0 ? infoSnackElement.offsetHeight : 0\"\r\n    [warningStackHeight]=\"warningStack?.notificationList?.length > 0 ? warningSnackElement.offsetHeight : 0\"\r\n    [infoStackIndicatorHeight]=\"infoStackIndicatorElement?.nativeElement?.offsetHeight\"\r\n    [warningStackIndicatorHeight]=\"warningStackIndicatorElement?.nativeElement?.offsetHeight\"\r\n    class=\"dismiss-all\"\r\n    *ngIf=\"notificationList?.length > 1\"\r\n  >\r\n    <avl-button id=\"dismissAll\" (click)=\"dismissAll()\">{{'VizBox.NotificationContainer.DismissAll' | translate}}</avl-button>\r\n  </div>\r\n</div>\r\n\r\n\r\n", styles: [":host{position:fixed;right:0;width:445px;display:flex;flex-direction:column;--avl-snackbar-text-color:var(--avl-on-background-info-color)}.snackbar{width:100%;display:flex;flex-direction:column}.snackbar.displayed{flex:1;max-height:100%}.snackbar-stack{position:absolute;top:0;left:0;right:0;width:100%}.stack-indicator-container{margin:0 12px;position:absolute;width:calc(100% - 12px);top:12px;z-index:-1}.snackbar-container{margin-top:0;margin-left:0;margin-right:0;width:100%}.button-label{text-align:left;text-transform:none}.stack-indicator{background-color:var(--avl-background-message-color);top:0;left:0;width:calc(100% - 24px);border-radius:4px;position:relative;height:100%;z-index:-1;box-shadow:0 3px 5px -1px rgb(0 0 0/20%),0 6px 10px 0 rgb(0 0 0/14%),0 1px 18px 0 rgb(0 0 0/12%)}.notification{display:flex;flex:1 1 100%;align-items:center;flex-direction:row;padding:0 12px 0 16px;justify-content:flex-start;cursor:pointer;text-overflow:ellipsis}.notification p{flex-grow:1;-webkit-line-clamp:3;text-overflow:ellipsis;line-height:19px;margin:0 0 0 12px;padding:12px 0;color:var(--avl-on-background-info-color)}.notification p,button#actionButton{max-height:48px;font-size:14px;font-family:var(--avl-font-family)}button#actionButton{font-weight:500;color:var(--avl-on-background-message-link-color);background-color:var(--avl-button-background-default-color);height:48px;width:100%;cursor:pointer;padding:12px;margin:-12px 0 0;border-radius:2px;border:0;outline:none}div#actionButton:hover{color:var(--avl-on-background-message-link-hover-color)}#warningIcon{--avl-icon-custom-color:var(--avl-on-background-message-warning-color);flex:0 0 24px}#errorIcon{--avl-icon-custom-color:var(--avl-on-background-message-error-color);flex:0 0 24px}#infoIcon{--avl-icon-custom-color:var(--avl-on-background-message-emphasis-medium-color);flex:0 0 24px}#OKIcon{--avl-icon-custom-color:var(--avl-on-background-message-ok-color);flex:0 0 24px}.dismiss-all{position:absolute;padding:0 16px;border-radius:25px;background-color:var(--avl-background-message-color);width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;top:12px}#dismissAll{--avl-flat-button-label-color:var(--avl-on-background-message-link-color)}avl-icon-button{flex:0 0 48px;margin-left:12px;cursor:pointer;--avl-icon-button-color:var(--avl-on-background-message-icon-default-color);--avl-icon-ink-hover-color:var(--avl-on-background-message-icon-hover-color);--avl-icon-ink-focus-color:var(--avl-on-background-message-icon-focus-color);--avl-icon-ink-pressed-color:var(--avl-on-background-message-icon-pressed-color)}#warningIcon{--avl-icon-custom-color:var(--avl-warning-color)}@media only screen and (min-width:320px) and (max-width:376px){:host{width:calc(100% - 32px)}}@media only screen and (min-width:460px){:host{width:445px}}@media only screen and (min-width:376px) and (max-width:400px){:host{width:376px}}"], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: AnimateStack, selector: "[animateStack]", inputs: ["animateStack", "notification", "previousStackHeight", "snackbarMethodDescription", "reopen"] }, { type: AnimateSnackbar, selector: "[animateSnackbar]", inputs: ["animateSnackbar", "positionAnimation", "notification", "reopen"] }, { type: i4.AvlInteractionControlDirective, selector: "avl-button,avl-icon-button,avl-item,avl-search-bar,avl-radio-button,avl-upload,avl-snackbar", outputs: ["focusedChange"] }, { type: i4.AvlSnackbarDirective, selector: "avl-snackbar", outputs: ["buttonClicked", "displayedChange"] }, { type: SnackbarListener, selector: "[snackbarListener]", outputs: ["notificationClicked", "buttonClicked", "notificationDismissed"] }, { type: ShowHideSnackbarDirective, selector: "[showHideSnackbar]", inputs: ["methodDescription"] }, { type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i4.AvlIconButtonDirective, selector: "avl-icon-button", outputs: ["badgeChange", "badgeValueChange"] }, { type: AnimateButton, selector: "[animateButton]", inputs: ["increment", "infoStackHeight", "warningStackHeight", "infoStackIndicatorHeight", "warningStackIndicatorHeight"] }], pipes: { "async": i1.AsyncPipe, "translate": i3.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlNotificationContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'avl-notification-container',
                    templateUrl: './avl-notification-container.component.html',
                    styleUrls: ['./avl-notification-container.component.css']
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { positionTop: [{
                type: HostBinding,
                args: ['style.top']
            }], warningStackElement: [{
                type: ViewChild,
                args: ['warningStackElement']
            }], infoStackElement: [{
                type: ViewChild,
                args: ['infoStackElement']
            }], infoStackIndicatorElement: [{
                type: ViewChild,
                args: ['infoStackIndicatorElement']
            }], warningStackIndicatorElement: [{
                type: ViewChild,
                args: ['infoStackIndicatorElement']
            }], displayIcon: [{
                type: Input,
                args: ['display-icon']
            }], notification$: [{
                type: Input,
                args: ['notification$']
            }], openMenu: [{
                type: Output
            }] } });

function dateValidator(date) {
    return (control) => {
        return date.invalid ? { date: { value: control.value } } : null;
    };
}
class DateInvalidValidatorDirective {
    validate(control) {
        return this.dateInvalid ? dateValidator(this.dateInvalid)(control) : null;
    }
}
DateInvalidValidatorDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: DateInvalidValidatorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
DateInvalidValidatorDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.3", type: DateInvalidValidatorDirective, selector: "[dateInvalid]", inputs: { dateInvalid: "dateInvalid" }, providers: [{ provide: NG_VALIDATORS, useExisting: DateInvalidValidatorDirective, multi: true }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: DateInvalidValidatorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[dateInvalid]',
                    providers: [{ provide: NG_VALIDATORS, useExisting: DateInvalidValidatorDirective, multi: true }]
                }]
        }], propDecorators: { dateInvalid: [{
                type: Input,
                args: ['dateInvalid']
            }] } });

class IterableObjectPipe {
    transform(object) {
        if (!object) {
            return undefined;
        }
        return Object.keys(object);
    }
}
IterableObjectPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: IterableObjectPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
IterableObjectPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: IterableObjectPipe, name: "iterableObject" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: IterableObjectPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'iterableObject'
                }]
        }] });

class CapitalizePipe {
    transform(text) {
        let firstLetter = text.substr(0, 1).toUpperCase();
        return firstLetter + text.substr(1);
    }
}
CapitalizePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: CapitalizePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
CapitalizePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: CapitalizePipe, name: "capitalize" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: CapitalizePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'capitalize'
                }]
        }] });

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class AvlNotificationDialogComponent {
    constructor() {
        this.open = false;
        this.pageSizeOptions = DEFAULT_PAGE_SIZE_OPTIONS;
        this.columnDefinitions = DEFAULT_COLUMN_DEFINITIONS;
        this.notificationsCount = {
            warning: 0,
            info: 0,
            ok: 0,
            error: 0,
            unread: 0,
            read: 0,
            total: 0
        };
        this.openChange = new EventEmitter();
        this.filtersChange = new EventEmitter();
        this.markSelectedAsRead = new EventEmitter();
        this.markSelectedAsUnread = new EventEmitter();
        this.tableRefresh = new EventEmitter();
        this.selectedPageChanged = new EventEmitter();
        this.pageSizeChanged = new EventEmitter();
        this.badge = false;
        this.disableMarkingSelected = true;
        this.filters = this.deepCopyObject(DEFAULT_FILTERS);
        this.filtersOpen = true;
        this.translationBase = TRANSLATION_BASE;
        this.actionButtons = ACTION_BUTTONS;
        this.disabledRange = {};
        this.dateFilterGroupInitHeader = 'Date';
        this.dateFilterGroupHeader = this.dateFilterGroupInitHeader;
        //notification datatable options
        this.selectedRows = [];
        this.pageSize = 15;
        this._notifications = [];
        this.destroyed$ = new Subject();
    }
    get notifications() {
        return this._notifications || [];
    }
    set notifications(notifications) {
        this._notifications = notifications;
    }
    set filterForm(filterForm) {
        var _a;
        (_a = this.filterFormSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        this.filterFormSubscription = filterForm === null || filterForm === void 0 ? void 0 : filterForm.valueChanges.pipe(debounceTime(300), distinctUntilChanged(), takeUntil(this.destroyed$), filter(_ => filterForm.valid)).subscribe(value => this.handleFiltersChanged(value));
    }
    ngOnDestroy() {
        this.destroyed$.next();
        this.destroyed$.complete();
    }
    ngOnInit() {
        this.translateLabels();
    }
    getIconByType(type) {
        switch (type) {
            case 'unread':
                return STATE_ICON_MAPPINGS['false'];
            case 'read':
                return STATE_ICON_MAPPINGS['true'];
            default:
                for (let [typeKey, typeValue] of NOTIFICATION_TYPE_MAPPINGS) {
                    if (typeValue === type && typeof typeKey === 'number') {
                        return TYPE_ICON_MAPPINGS[typeKey];
                    }
                }
        }
    }
    /** Emits event when dialog opens or closes */
    openChanged(open) {
        this.openChange.emit(open);
    }
    onSelectedPageChanged(event) {
        this.selectedPageChanged.emit(event);
    }
    onPageSizeChanged(event) {
        this.pageSizeChanged.emit(event);
    }
    /** Toggles displaying of filter sheet */
    toggleFilters() {
        this.filtersOpen = !this.filtersOpen;
    }
    /** Refreshes the datatable when refresh button is clicked */
    refreshTable() {
        this.tableRefresh.emit();
    }
    markAs(state) {
        state === NOTIFICATION_TYPE_MAPPINGS.get(true) ? this.markAsRead() : this.markAsUnread();
    }
    /** Changes selected notification state to read */
    markAsRead() {
        this.markSelectedAsRead.emit(this.selectedRows);
    }
    /** Changes selected notification state to unread */
    markAsUnread() {
        this.markSelectedAsUnread.emit(this.selectedRows);
    }
    /**
     * Resets all filters.
     */
    reset() {
        this.filters = this.deepCopyObject(DEFAULT_FILTERS);
        this.updateLabels();
        this.badge = false;
    }
    /** Called when selection is applied to the table rows */
    selectedValuesChanged() {
        this.disableMarkingSelected = false;
        if (this.selectedRows.length == 0) {
            this.disableMarkingSelected = true;
        }
    }
    /** Updates date filter header labels when date changes */
    updateLabels() {
        return __awaiter(this, void 0, void 0, function* () {
            const translationService = AvlLocalizationService.translationService;
            const { dateFrom, dateTo } = this.filters.date;
            if (!dateFrom && !dateTo) {
                this.dateFilterGroupHeader = this.dateFilterGroupInitHeader;
            }
            else {
                this.dateFilterGroupHeader = yield translationService.translate('VizBox.NotificationDialog.DateRange', {
                    dateFrom: this.formatDateTime(dateFrom),
                    dateTo: this.formatDateTime(dateTo)
                });
            }
        });
    }
    /** Event fired when table row is clicked
     * depending on the notification flag it opens in new tab
     */
    onRowClicked(event) {
        const row = event.detail;
        if (row.link) {
            if (row.openInNewTab) {
                window.open(row.link, '_blank');
            }
            else {
                window.open(row.link, '_self');
            }
        }
    }
    handleFiltersChanged(value) {
        var _a;
        this.activeFilters = this.getActiveFilters(value);
        if ((_a = this.activeFilters) === null || _a === void 0 ? void 0 : _a.date) {
            this.disabledRange = this.getDisabledRange();
        }
        this.badge = Boolean(this.activeFilters);
        const event = new CustomEvent('filtersChange', { detail: this.activeFilters });
        this.filtersChange.emit(event);
    }
    /** Calculates active filters from filter object */
    getActiveFilters(filters) {
        Object.keys(filters).forEach(key => {
            const filter = filters[key];
            //don't iterate through search
            if (filter && typeof filter !== 'string') {
                filters[key] = this.removeInactiveFilterKeys(filter);
            }
        });
        return this.removeInactiveFilterKeys(filters);
    }
    /** disable dates before dateFrom in dateTo, and dates after dateTo in dateFrom  */
    getDisabledRange() {
        const { dateFrom, dateTo } = this.filters.date;
        return {
            dateFrom: dateTo ? [{ from: dateTo }] : undefined,
            dateTo: dateFrom ? [{ to: dateFrom }] : undefined
        };
    }
    /** Removes inactive filters from filter object and returns it */
    removeInactiveFilterKeys(filter) {
        var _a;
        Object.keys(filter)
            .filter(secondLevelKey => !Boolean(filter[secondLevelKey]))
            .forEach(secondLevelKey => delete filter[secondLevelKey]);
        return ((_a = Object.keys(filter)) === null || _a === void 0 ? void 0 : _a.length) ? filter : undefined;
    }
    /** Formats date time to date-short */
    formatDateTime(d) {
        return d ? AvlLocalizationService.formatDateTime(d, { format: 'date-short' }) : '(-)';
    }
    /** Deep copy of filters object */
    deepCopyObject(object) {
        const copiedObject = {};
        Object.keys(object).forEach(key => {
            copiedObject[key] =
                typeof object[key] === 'object' ? Object.assign({}, object[key]) : object[key];
        });
        return copiedObject;
    }
    // Translations
    translateLabels() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!AvlLocalizationService || !AvlLocalizationService.translationService) {
                return;
            }
            const translationService = AvlLocalizationService.translationService;
            this.dateFilterGroupInitHeader = yield translationService.translate('VizBox.NotificationDialog.Date');
            this.dateFilterGroupHeader = this.dateFilterGroupInitHeader;
            this.pageSizeOptions = yield this.translatePageSizeOptions(this.pageSizeOptions);
            this.columnDefinitions = yield this.translateColumns(this.columnDefinitions);
        });
    }
    translatePageSizeOptions(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all(options.map((option) => __awaiter(this, void 0, void 0, function* () { return this.translatePageSizeOption(option); })));
        });
    }
    translatePageSizeOption(item) {
        return __awaiter(this, void 0, void 0, function* () {
            const translationService = AvlLocalizationService.translationService;
            return Object.assign(Object.assign({}, item), { label: item.value === Number.MAX_SAFE_INTEGER
                    ? yield translationService.translate('VizBox.NotificationDialog.ShowAll')
                    : yield translationService.translate('VizBox.NotificationDialog.ShowXPerPage', {
                        rows: item.value
                    }) });
        });
    }
    translateColumns(column) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all(column.map((item) => __awaiter(this, void 0, void 0, function* () { return this.translateColumnItem(item); })));
        });
    }
    translateColumnItem(item) {
        return __awaiter(this, void 0, void 0, function* () {
            const translateService = AvlLocalizationService.translationService;
            return Object.assign(Object.assign({}, item), { caption: yield translateService.translate(item.caption) });
        });
    }
}
AvlNotificationDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlNotificationDialogComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
AvlNotificationDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.3", type: AvlNotificationDialogComponent, selector: "avl-notification-dialog", inputs: { open: "open", pageSizeOptions: "pageSizeOptions", columnDefinitions: "columnDefinitions", notificationsCount: "notificationsCount", refreshBadge: "refreshBadge", notifications: "notifications" }, outputs: { openChange: "openChange", filtersChange: "filtersChange", markSelectedAsRead: "markSelectedAsRead", markSelectedAsUnread: "markSelectedAsUnread", tableRefresh: "tableRefresh", selectedPageChanged: "selectedPageChanged", pageSizeChanged: "pageSizeChanged" }, viewQueries: [{ propertyName: "table", first: true, predicate: ["notificationTable"], descendants: true }, { propertyName: "filterForm", first: true, predicate: ["filterForm"], descendants: true, read: NgForm }], ngImport: i0, template: "<avl-dialog\r\n  id=\"outerDialog\"\r\n  [open]=\"open\"\r\n  (openChange)=\"openChanged($event)\"\r\n  [closeOnScrimClick]=\"false\"\r\n  [fullscreen]=\"true\"\r\n>\r\n  <ng-template #content>\r\n    <avl-dialog-header>{{ translationBase + 'Details' | translate }}</avl-dialog-header>\r\n    <avl-dialog-content>\r\n      <div class=\"main-container\">\r\n        <div class=\"content\">\r\n          <div class=\"table-header\">\r\n            <h1>\r\n              {{ translationBase + 'Notifications' | translate }} ({{ notifications?.length }}\r\n              <span\r\n                *ngIf=\"\r\n                  notificationsCount.total && notificationsCount.total !== notifications?.length\r\n                \"\r\n              >\r\n                /{{ notificationsCount.total }} </span\r\n              >)\r\n            </h1>\r\n            <div class=\"table-header-right\">\r\n              <avl-icon-button\r\n                id=\"updateIcon\"\r\n                (click)=\"refreshTable()\"\r\n                class=\"pointer\"\r\n                icon=\"icons:refresh\"\r\n                [badge]=\"refreshBadge\"\r\n              >\r\n              </avl-icon-button>\r\n              <avl-tooltip for=\"updateIcon\">\r\n                {{ translationBase + 'Refresh' | translate }}</avl-tooltip\r\n              >\r\n              <div class=\"divider vertical\"></div>\r\n              <div *ngFor=\"let button of actionButtons\">\r\n                <avl-icon-button\r\n                  id=\"{{ button.id }}Icon\"\r\n                  (click)=\"markAs(button.id)\"\r\n                  class=\"pointer\"\r\n                  [icon]=\"getIconByType(button.id)\"\r\n                  [disabled]=\"disableMarkingSelected\"\r\n                >\r\n                </avl-icon-button>\r\n                <avl-tooltip for=\"{{ button.id }}Icon\">{{\r\n                  button.tooltip | translate\r\n                }}</avl-tooltip>\r\n              </div>\r\n              <div class=\"divider vertical\"></div>\r\n              <div *ngIf=\"!filtersOpen\" class=\"search-bar-holder\">\r\n                <div *ngTemplateOutlet=\"searchBar\"></div>\r\n              </div>\r\n              <avl-icon-button\r\n                (click)=\"toggleFilters()\"\r\n                class=\"pointer\"\r\n                icon=\"icons:filter-list\"\r\n                [badge]=\"badge\"\r\n              ></avl-icon-button>\r\n            </div>\r\n          </div>\r\n          <avl-datatable\r\n            #notificationTable\r\n            class=\"filterDatatable\"\r\n            multi-select\r\n            allow-active-row\r\n            pagination\r\n            [columnDefinitions]=\"columnDefinitions\"\r\n            [pageSize]=\"pageSize\"\r\n            [data]=\"notifications | prepareNotifications: 'dialog'\"\r\n            [pageSizeOptions]=\"pageSizeOptions\"\r\n            [(selectedValues)]=\"selectedRows\"\r\n            (selectedValuesChange)=\"selectedValuesChanged()\"\r\n            (page-size-changed)=\"onPageSizeChanged($event)\"\r\n            (selected-page-changed)=\"onSelectedPageChanged($event)\"\r\n            (on-row-clicked)=\"onRowClicked($event)\"\r\n          >\r\n          </avl-datatable>\r\n        </div>\r\n        <avl-side-sheet class=\"filter-sheet\" divider [(open)]=\"filtersOpen\" #filterSheet>\r\n          <div slot=\"title\">\r\n            <h2>{{ translationBase + 'Filters' | translate }}</h2>\r\n          </div>\r\n          <div slot=\"content\">\r\n            <form #filterForm=\"ngForm\">\r\n              <!--ngIf is needed to rerender template on filtersheet toggle-->\r\n              <div *ngIf=\"filtersOpen\" class=\"search-bar-holder\">\r\n                <div *ngTemplateOutlet=\"searchBar\"></div>\r\n              </div>\r\n\r\n              <avl-list-expander\r\n                [open]=\"true\"\r\n                [narrow]=\"true\"\r\n                #filterFormType=\"ngModelGroup\"\r\n                ngModelGroup=\"type\"\r\n              >\r\n                <div role=\"header\">\r\n                  <h3>\r\n                    <span>{{ translationBase + 'Type' | translate }}</span>\r\n                    <span *ngIf=\"activeFilters?.type | iterableObject as activeFilterGroup\">\r\n                      <ng-container\r\n                        *ngTemplateOutlet=\"\r\n                          currentHeader;\r\n                          context: {\r\n                            activeFilterGroup: activeFilterGroup,\r\n                            filterGroup: filters?.type | iterableObject\r\n                          }\r\n                        \"\r\n                      ></ng-container>\r\n                    </span>\r\n                  </h3>\r\n                </div>\r\n                <div role=\"content\" class=\"filterContent\">\r\n                  <div *ngFor=\"let type of filters?.type | iterableObject\">\r\n                    <avl-checkbox name=\"{{ type }}\" [(ngModel)]=\"filters.type[type]\">\r\n                      {{ translationBase + (type | titlecase) | translate }}\r\n                      <span *ngIf=\"notifications.length\">({{ notificationsCount[type] }})</span>\r\n                    </avl-checkbox>\r\n                    <avl-icon\r\n                      id=\"{{ type }}Icon\"\r\n                      class=\"typeIcons\"\r\n                      icon=\"icons:{{ getIconByType(type) }}\"\r\n                    ></avl-icon>\r\n                  </div>\r\n                </div>\r\n              </avl-list-expander>\r\n              <avl-list-expander\r\n                [open]=\"true\"\r\n                [narrow]=\"true\"\r\n                #filterFormState=\"ngModelGroup\"\r\n                ngModelGroup=\"state\"\r\n              >\r\n                <div role=\"header\">\r\n                  <h3>\r\n                    <span>{{ translationBase + 'State' | translate }}</span>\r\n                    <span *ngIf=\"activeFilters?.state | iterableObject as activeFilterGroup\">\r\n                      <ng-container\r\n                        *ngTemplateOutlet=\"\r\n                          currentHeader;\r\n                          context: {\r\n                            activeFilterGroup: activeFilterGroup,\r\n                            filterGroup: filters?.state | iterableObject\r\n                          }\r\n                        \"\r\n                      ></ng-container>\r\n                    </span>\r\n                  </h3>\r\n                </div>\r\n                <div role=\"content\" class=\"filterContent\">\r\n                  <div *ngFor=\"let state of filters?.state | iterableObject\">\r\n                    <avl-checkbox name=\"{{ state }}\" [(ngModel)]=\"filters.state[state]\">\r\n                      {{ translationBase + (state | titlecase) | translate }} ({{\r\n                        notificationsCount[state]\r\n                      }})\r\n                    </avl-checkbox>\r\n                    <avl-icon\r\n                      id=\"{{ state }}Icon\"\r\n                      class=\"typeIcons\"\r\n                      icon=\"icons:{{ getIconByType(state) }}\"\r\n                    ></avl-icon>\r\n                  </div>\r\n                </div>\r\n              </avl-list-expander>\r\n              <avl-list-expander\r\n                [open]=\"true\"\r\n                [narrow]=\"true\"\r\n                #filterFormDate=\"ngModelGroup\"\r\n                ngModelGroup=\"date\"\r\n              >\r\n                <div role=\"header\">\r\n                  <h3 id=\"date-group\" #dateGroup>\r\n                    {{ dateFilterGroupHeader }}\r\n                  </h3>\r\n                  <avl-tooltip\r\n                    for=\"date-group\"\r\n                    *ngIf=\"dateGroup.scrollWidth > dateGroup.clientWidth\"\r\n                  >\r\n                    {{ dateFilterGroupHeader }}\r\n                  </avl-tooltip>\r\n                </div>\r\n                <div role=\"content\">\r\n                  <avl-date\r\n                    *ngFor=\"let date of filters?.date | iterableObject\"\r\n                    class=\"date-control\"\r\n                    [(ngModel)]=\"filters.date[date]\"\r\n                    name=\"{{ date }}\"\r\n                    (valueChange)=\"updateLabels()\"\r\n                    [label]=\"translationBase + (date | capitalize) | translate\"\r\n                    [disabledRanges]=\"disabledRange[date]\"\r\n                    #dateEl\r\n                    auto-validate\r\n                    [dateInvalid]=\"dateEl\"\r\n                  ></avl-date>\r\n                </div>\r\n              </avl-list-expander>\r\n              <ng-template #searchBar>\r\n                <avl-search-bar\r\n                  placeholder=\"{{ translationBase + 'Search' | translate }}\"\r\n                  always-open\r\n                  #searchBarElement\r\n                  name=\"search\"\r\n                  [(ngModel)]=\"filters.search\"\r\n                ></avl-search-bar>\r\n              </ng-template>\r\n            </form>\r\n          </div>\r\n          <div slot=\"actions\">\r\n            <avl-button (click)=\"reset()\">{{ translationBase + 'Reset' | translate }}</avl-button>\r\n          </div>\r\n        </avl-side-sheet>\r\n      </div>\r\n    </avl-dialog-content>\r\n  </ng-template>\r\n\r\n  <ng-template\r\n    #currentHeader\r\n    let-activeFilterGroup=\"activeFilterGroup\"\r\n    let-filterGroup=\"filterGroup\"\r\n  >\r\n    <span>: </span><span *ngIf=\"activeFilterGroup.length === filterGroup.length\">all</span>\r\n    <span *ngIf=\"activeFilterGroup.length !== filterGroup.length\">\r\n      <span *ngFor=\"let item of activeFilterGroup; index as i\">\r\n        <span>{{ translationBase + (item | titlecase) | translate }}</span>\r\n        <span *ngIf=\"i < activeFilterGroup.length - 1\">, </span>\r\n      </span>\r\n    </span>\r\n  </ng-template>\r\n</avl-dialog>\r\n", styles: [".content{position:relative;display:flex;flex-direction:column;flex-grow:1}.divider{background-color:var(--avl-divider-color)}.divider.vertical{width:1px;height:auto;margin:12px 0}.search-bar-holder{padding:0 9px}form .search-bar-holder{display:block;position:relative;padding:12px 24px 12px 12px}.table-header{display:flex;justify-content:space-between;align-items:center}.table-header-right{display:flex}.main-container{display:flex;height:100%}.main-container.hidden{display:none}.filterDatatable{height:100%}.filter-sheet{--avl-side-sheet-padding:0px;--avl-side-sheet-height:84vh;width:300px}.filter-sheet h2{font-size:20px;margin-left:24px}.filter-sheet h3{font-size:16px;margin:0;text-overflow:ellipsis;overflow:hidden}.pointer{cursor:pointer}#errorIcon{--avl-icon-custom-color:var(--avl-error-color)}#warningIcon{--avl-icon-custom-color:var(--avl-warning-color)}#okIcon{--avl-icon-custom-color:var(--avl-ok-color)}#infoIcon{--avl-icon-custom-color:var(--avl-icon-default-color)}.filterContent{position:relative}.typeIcons{position:absolute;right:0;margin-top:12px;margin-bottom:12px}.date-control{width:100%}avl-dialog-content{--padding-top:1px!important;--padding-right:0px!important;--padding-bottom:2px!important}avl-dialog-header{z-index:1}avl-side-sheet{--avl-side-sheet-height:unset!important;box-shadow:none;border-left:1px solid var(--avl-divider-color)}avl-datatable{--margin-top-pages:0px!important}"], components: [{ type: i1$2.AvlDialogComponent, selector: "avl-dialog", inputs: ["closeOnScrimClick", "complex", "warningHeaderText", "warningDialogText", "fullscreen", "open", "dirty", "warningOnClose"], outputs: ["openChange"] }, { type: i1$2.AvlDialogHeaderComponent, selector: "avl-dialog-header" }, { type: i1$2.AvlDialogContentComponent, selector: "avl-dialog-content" }, { type: i2.AvlListExpanderComponent, selector: "avl-list-expander", inputs: ["narrow", "open"], outputs: ["openChange"] }], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i4.AvlInteractionControlDirective, selector: "avl-button,avl-icon-button,avl-item,avl-search-bar,avl-radio-button,avl-upload,avl-snackbar", outputs: ["focusedChange"] }, { type: i4.AvlIconButtonDirective, selector: "avl-icon-button", outputs: ["badgeChange", "badgeValueChange"] }, { type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i4.AvlMultiSelectControlDirective, selector: "avl-datatable,avl-list,avl-chip-list, avl-chip-input", outputs: ["selectedIndexesChange", "selectedValuesChange"] }, { type: i4.AvlSingleSelectControlDirective, selector: "avl-datatable,avl-dropdown,avl-list,avl-radio-group,avl-app-switcher,avl-chip-list,avl-combo-box", outputs: ["selectedIndexChange", "selectedValueChange"] }, { type: i4.AvlDatatableDirective, selector: "avl-datatable", outputs: ["buttonClick", "overflowMenuItemClick", "linkClick", "pageSizeChange", "selectedPageChange"] }, { type: i4.AvlSideSheetDirective, selector: "avl-side-sheet", outputs: ["openChange"] }, { type: i5.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i5.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i5.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i5.NgModelGroup, selector: "[ngModelGroup]", inputs: ["ngModelGroup"], exportAs: ["ngModelGroup"] }, { type: i4.AvlCheckableControlDirective, selector: "avl-checkbox,avl-radio-button, avl-icon-toggle, avl-switch", outputs: ["checkedChange"] }, { type: i4.AvlFormControlDirective, selector: "avl-date,avl-dropdown,avl-time,avl-icon-toggle,avl-numberfield,avl-radio-group,avl-slider,avl-textarea,avl-textfield,avl-timespan,avl-checkbox,avl-switch,avl-chip-list,avl-upload,avl-search-bar,avl-chip-input", inputs: ["readonly"], outputs: ["invalidChange"] }, { type: i4.AvlCheckboxDirective, selector: "avl-checkbox", outputs: ["indeterminateChange"] }, { type: i5.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i5.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i4.AvlDateDirective, selector: "avl-date", outputs: ["valueChange"] }, { type: DateInvalidValidatorDirective, selector: "[dateInvalid]", inputs: ["dateInvalid"] }, { type: i4.AvlSearchBarDirective, selector: "avl-search-bar", outputs: ["queryChange", "openChange"] }], pipes: { "translate": i3.TranslatePipe, "prepareNotifications": PrepareNotificationsPipe, "iterableObject": IterableObjectPipe, "titlecase": i1.TitleCasePipe, "capitalize": CapitalizePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlNotificationDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'avl-notification-dialog',
                    templateUrl: './avl-notification-dialog.component.html',
                    styleUrls: ['./avl-notification-dialog.component.css'],
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], propDecorators: { open: [{
                type: Input
            }], pageSizeOptions: [{
                type: Input
            }], columnDefinitions: [{
                type: Input
            }], notificationsCount: [{
                type: Input
            }], refreshBadge: [{
                type: Input
            }], notifications: [{
                type: Input
            }], openChange: [{
                type: Output
            }], filtersChange: [{
                type: Output
            }], markSelectedAsRead: [{
                type: Output
            }], markSelectedAsUnread: [{
                type: Output
            }], tableRefresh: [{
                type: Output
            }], selectedPageChanged: [{
                type: Output
            }], pageSizeChanged: [{
                type: Output
            }], table: [{
                type: ViewChild,
                args: ['notificationTable']
            }], filterForm: [{
                type: ViewChild,
                args: ['filterForm', { read: NgForm }]
            }] } });

const componentsAndDirectives = [
    AvlNotificationMenuComponent,
    AvlNotificationContainerComponent,
    SnackbarListener,
    AnimateStack,
    AnimateSnackbar,
    ShowHideSnackbarDirective,
    AnimateButton,
    AvlNotificationDialogComponent,
    PrepareNotificationsPipe,
    CapitalizePipe,
    IterableObjectPipe,
    DateInvalidValidatorDirective
];
class AvlNotificationModule {
}
AvlNotificationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlNotificationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AvlNotificationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlNotificationModule, declarations: [AvlNotificationMenuComponent,
        AvlNotificationContainerComponent,
        SnackbarListener,
        AnimateStack,
        AnimateSnackbar,
        ShowHideSnackbarDirective,
        AnimateButton,
        AvlNotificationDialogComponent,
        PrepareNotificationsPipe,
        CapitalizePipe,
        IterableObjectPipe,
        DateInvalidValidatorDirective], imports: [CommonModule,
        TranslateModule,
        AvlNgBindersModule,
        AvlDialogModule,
        AvlNavigationModule,
        FormsModule], exports: [AvlNotificationMenuComponent,
        AvlNotificationContainerComponent,
        AvlNotificationDialogComponent] });
AvlNotificationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlNotificationModule, imports: [[
            CommonModule,
            TranslateModule,
            AvlNgBindersModule,
            AvlDialogModule,
            AvlNavigationModule,
            FormsModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlNotificationModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [...componentsAndDirectives],
                    imports: [
                        CommonModule,
                        TranslateModule,
                        AvlNgBindersModule,
                        AvlDialogModule,
                        AvlNavigationModule,
                        FormsModule
                    ],
                    schemas: [CUSTOM_ELEMENTS_SCHEMA],
                    exports: [
                        AvlNotificationMenuComponent,
                        AvlNotificationContainerComponent,
                        AvlNotificationDialogComponent
                    ]
                }]
        }] });

/*
 * Public API Surface of notification
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AvlNotificationContainerComponent, AvlNotificationDialogComponent, AvlNotificationMenuComponent, AvlNotificationModule };
//# sourceMappingURL=avl-ng-controls-notification.js.map
