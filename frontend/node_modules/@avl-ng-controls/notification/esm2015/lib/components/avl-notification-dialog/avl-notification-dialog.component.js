var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Component, Input, ViewChild, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';
import '@avl-controls/core/dist/avl-icon-button/avl-icon-button';
import '@avl-controls/core/dist/avl-icon/avl-icon';
import '@avl-controls/core/dist/avl-side-sheet/avl-side-sheet';
import '@avl-controls/core/dist/avl-checkbox/avl-checkbox';
import '@avl-controls/core/dist/avl-tooltip/avl-tooltip';
import '@avl-controls/core/dist/avl-date/avl-date';
import { DEFAULT_COLUMN_DEFINITIONS, DEFAULT_FILTERS, DEFAULT_PAGE_SIZE_OPTIONS, STATE_ICON_MAPPINGS, TYPE_ICON_MAPPINGS, TRANSLATION_BASE, ACTION_BUTTONS } from './avl-notification-dialog.consts';
import { NgForm } from '@angular/forms';
import { Subject } from 'rxjs';
import { debounceTime, distinctUntilChanged, filter, takeUntil } from 'rxjs/operators';
import { NOTIFICATION_TYPE_MAPPINGS } from './avl-notification-dialog.consts';
import * as i0 from "@angular/core";
import * as i1 from "@avl-ng-controls/dialog";
import * as i2 from "@avl-ng-controls/navigation";
import * as i3 from "@angular/common";
import * as i4 from "@avl-controls/ng-binders";
import * as i5 from "@angular/forms";
import * as i6 from "./date-validator.directive";
import * as i7 from "@ngx-translate/core";
import * as i8 from "../../pipes/prepare-notifications.pipe";
import * as i9 from "../../pipes/iterable-object.pipe";
import * as i10 from "../../pipes/capitalize.pipe";
export class AvlNotificationDialogComponent {
    constructor() {
        this.open = false;
        this.pageSizeOptions = DEFAULT_PAGE_SIZE_OPTIONS;
        this.columnDefinitions = DEFAULT_COLUMN_DEFINITIONS;
        this.notificationsCount = {
            warning: 0,
            info: 0,
            ok: 0,
            error: 0,
            unread: 0,
            read: 0,
            total: 0
        };
        this.openChange = new EventEmitter();
        this.filtersChange = new EventEmitter();
        this.markSelectedAsRead = new EventEmitter();
        this.markSelectedAsUnread = new EventEmitter();
        this.tableRefresh = new EventEmitter();
        this.selectedPageChanged = new EventEmitter();
        this.pageSizeChanged = new EventEmitter();
        this.badge = false;
        this.disableMarkingSelected = true;
        this.filters = this.deepCopyObject(DEFAULT_FILTERS);
        this.filtersOpen = true;
        this.translationBase = TRANSLATION_BASE;
        this.actionButtons = ACTION_BUTTONS;
        this.disabledRange = {};
        this.dateFilterGroupInitHeader = 'Date';
        this.dateFilterGroupHeader = this.dateFilterGroupInitHeader;
        //notification datatable options
        this.selectedRows = [];
        this.pageSize = 15;
        this._notifications = [];
        this.destroyed$ = new Subject();
    }
    get notifications() {
        return this._notifications || [];
    }
    set notifications(notifications) {
        this._notifications = notifications;
    }
    set filterForm(filterForm) {
        var _a;
        (_a = this.filterFormSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        this.filterFormSubscription = filterForm === null || filterForm === void 0 ? void 0 : filterForm.valueChanges.pipe(debounceTime(300), distinctUntilChanged(), takeUntil(this.destroyed$), filter(_ => filterForm.valid)).subscribe(value => this.handleFiltersChanged(value));
    }
    ngOnDestroy() {
        this.destroyed$.next();
        this.destroyed$.complete();
    }
    ngOnInit() {
        this.translateLabels();
    }
    getIconByType(type) {
        switch (type) {
            case 'unread':
                return STATE_ICON_MAPPINGS['false'];
            case 'read':
                return STATE_ICON_MAPPINGS['true'];
            default:
                for (let [typeKey, typeValue] of NOTIFICATION_TYPE_MAPPINGS) {
                    if (typeValue === type && typeof typeKey === 'number') {
                        return TYPE_ICON_MAPPINGS[typeKey];
                    }
                }
        }
    }
    /** Emits event when dialog opens or closes */
    openChanged(open) {
        this.openChange.emit(open);
    }
    onSelectedPageChanged(event) {
        this.selectedPageChanged.emit(event);
    }
    onPageSizeChanged(event) {
        this.pageSizeChanged.emit(event);
    }
    /** Toggles displaying of filter sheet */
    toggleFilters() {
        this.filtersOpen = !this.filtersOpen;
    }
    /** Refreshes the datatable when refresh button is clicked */
    refreshTable() {
        this.tableRefresh.emit();
    }
    markAs(state) {
        state === NOTIFICATION_TYPE_MAPPINGS.get(true) ? this.markAsRead() : this.markAsUnread();
    }
    /** Changes selected notification state to read */
    markAsRead() {
        this.markSelectedAsRead.emit(this.selectedRows);
    }
    /** Changes selected notification state to unread */
    markAsUnread() {
        this.markSelectedAsUnread.emit(this.selectedRows);
    }
    /**
     * Resets all filters.
     */
    reset() {
        this.filters = this.deepCopyObject(DEFAULT_FILTERS);
        this.updateLabels();
        this.badge = false;
    }
    /** Called when selection is applied to the table rows */
    selectedValuesChanged() {
        this.disableMarkingSelected = false;
        if (this.selectedRows.length == 0) {
            this.disableMarkingSelected = true;
        }
    }
    /** Updates date filter header labels when date changes */
    updateLabels() {
        return __awaiter(this, void 0, void 0, function* () {
            const translationService = AvlLocalizationService.translationService;
            const { dateFrom, dateTo } = this.filters.date;
            if (!dateFrom && !dateTo) {
                this.dateFilterGroupHeader = this.dateFilterGroupInitHeader;
            }
            else {
                this.dateFilterGroupHeader = yield translationService.translate('VizBox.NotificationDialog.DateRange', {
                    dateFrom: this.formatDateTime(dateFrom),
                    dateTo: this.formatDateTime(dateTo)
                });
            }
        });
    }
    /** Event fired when table row is clicked
     * depending on the notification flag it opens in new tab
     */
    onRowClicked(event) {
        const row = event.detail;
        if (row.link) {
            if (row.openInNewTab) {
                window.open(row.link, '_blank');
            }
            else {
                window.open(row.link, '_self');
            }
        }
    }
    handleFiltersChanged(value) {
        var _a;
        this.activeFilters = this.getActiveFilters(value);
        if ((_a = this.activeFilters) === null || _a === void 0 ? void 0 : _a.date) {
            this.disabledRange = this.getDisabledRange();
        }
        this.badge = Boolean(this.activeFilters);
        const event = new CustomEvent('filtersChange', { detail: this.activeFilters });
        this.filtersChange.emit(event);
    }
    /** Calculates active filters from filter object */
    getActiveFilters(filters) {
        Object.keys(filters).forEach(key => {
            const filter = filters[key];
            //don't iterate through search
            if (filter && typeof filter !== 'string') {
                filters[key] = this.removeInactiveFilterKeys(filter);
            }
        });
        return this.removeInactiveFilterKeys(filters);
    }
    /** disable dates before dateFrom in dateTo, and dates after dateTo in dateFrom  */
    getDisabledRange() {
        const { dateFrom, dateTo } = this.filters.date;
        return {
            dateFrom: dateTo ? [{ from: dateTo }] : undefined,
            dateTo: dateFrom ? [{ to: dateFrom }] : undefined
        };
    }
    /** Removes inactive filters from filter object and returns it */
    removeInactiveFilterKeys(filter) {
        var _a;
        Object.keys(filter)
            .filter(secondLevelKey => !Boolean(filter[secondLevelKey]))
            .forEach(secondLevelKey => delete filter[secondLevelKey]);
        return ((_a = Object.keys(filter)) === null || _a === void 0 ? void 0 : _a.length) ? filter : undefined;
    }
    /** Formats date time to date-short */
    formatDateTime(d) {
        return d ? AvlLocalizationService.formatDateTime(d, { format: 'date-short' }) : '(-)';
    }
    /** Deep copy of filters object */
    deepCopyObject(object) {
        const copiedObject = {};
        Object.keys(object).forEach(key => {
            copiedObject[key] =
                typeof object[key] === 'object' ? Object.assign({}, object[key]) : object[key];
        });
        return copiedObject;
    }
    // Translations
    translateLabels() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!AvlLocalizationService || !AvlLocalizationService.translationService) {
                return;
            }
            const translationService = AvlLocalizationService.translationService;
            this.dateFilterGroupInitHeader = yield translationService.translate('VizBox.NotificationDialog.Date');
            this.dateFilterGroupHeader = this.dateFilterGroupInitHeader;
            this.pageSizeOptions = yield this.translatePageSizeOptions(this.pageSizeOptions);
            this.columnDefinitions = yield this.translateColumns(this.columnDefinitions);
        });
    }
    translatePageSizeOptions(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all(options.map((option) => __awaiter(this, void 0, void 0, function* () { return this.translatePageSizeOption(option); })));
        });
    }
    translatePageSizeOption(item) {
        return __awaiter(this, void 0, void 0, function* () {
            const translationService = AvlLocalizationService.translationService;
            return Object.assign(Object.assign({}, item), { label: item.value === Number.MAX_SAFE_INTEGER
                    ? yield translationService.translate('VizBox.NotificationDialog.ShowAll')
                    : yield translationService.translate('VizBox.NotificationDialog.ShowXPerPage', {
                        rows: item.value
                    }) });
        });
    }
    translateColumns(column) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all(column.map((item) => __awaiter(this, void 0, void 0, function* () { return this.translateColumnItem(item); })));
        });
    }
    translateColumnItem(item) {
        return __awaiter(this, void 0, void 0, function* () {
            const translateService = AvlLocalizationService.translationService;
            return Object.assign(Object.assign({}, item), { caption: yield translateService.translate(item.caption) });
        });
    }
}
AvlNotificationDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlNotificationDialogComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
AvlNotificationDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.3", type: AvlNotificationDialogComponent, selector: "avl-notification-dialog", inputs: { open: "open", pageSizeOptions: "pageSizeOptions", columnDefinitions: "columnDefinitions", notificationsCount: "notificationsCount", refreshBadge: "refreshBadge", notifications: "notifications" }, outputs: { openChange: "openChange", filtersChange: "filtersChange", markSelectedAsRead: "markSelectedAsRead", markSelectedAsUnread: "markSelectedAsUnread", tableRefresh: "tableRefresh", selectedPageChanged: "selectedPageChanged", pageSizeChanged: "pageSizeChanged" }, viewQueries: [{ propertyName: "table", first: true, predicate: ["notificationTable"], descendants: true }, { propertyName: "filterForm", first: true, predicate: ["filterForm"], descendants: true, read: NgForm }], ngImport: i0, template: "<avl-dialog\r\n  id=\"outerDialog\"\r\n  [open]=\"open\"\r\n  (openChange)=\"openChanged($event)\"\r\n  [closeOnScrimClick]=\"false\"\r\n  [fullscreen]=\"true\"\r\n>\r\n  <ng-template #content>\r\n    <avl-dialog-header>{{ translationBase + 'Details' | translate }}</avl-dialog-header>\r\n    <avl-dialog-content>\r\n      <div class=\"main-container\">\r\n        <div class=\"content\">\r\n          <div class=\"table-header\">\r\n            <h1>\r\n              {{ translationBase + 'Notifications' | translate }} ({{ notifications?.length }}\r\n              <span\r\n                *ngIf=\"\r\n                  notificationsCount.total && notificationsCount.total !== notifications?.length\r\n                \"\r\n              >\r\n                /{{ notificationsCount.total }} </span\r\n              >)\r\n            </h1>\r\n            <div class=\"table-header-right\">\r\n              <avl-icon-button\r\n                id=\"updateIcon\"\r\n                (click)=\"refreshTable()\"\r\n                class=\"pointer\"\r\n                icon=\"icons:refresh\"\r\n                [badge]=\"refreshBadge\"\r\n              >\r\n              </avl-icon-button>\r\n              <avl-tooltip for=\"updateIcon\">\r\n                {{ translationBase + 'Refresh' | translate }}</avl-tooltip\r\n              >\r\n              <div class=\"divider vertical\"></div>\r\n              <div *ngFor=\"let button of actionButtons\">\r\n                <avl-icon-button\r\n                  id=\"{{ button.id }}Icon\"\r\n                  (click)=\"markAs(button.id)\"\r\n                  class=\"pointer\"\r\n                  [icon]=\"getIconByType(button.id)\"\r\n                  [disabled]=\"disableMarkingSelected\"\r\n                >\r\n                </avl-icon-button>\r\n                <avl-tooltip for=\"{{ button.id }}Icon\">{{\r\n                  button.tooltip | translate\r\n                }}</avl-tooltip>\r\n              </div>\r\n              <div class=\"divider vertical\"></div>\r\n              <div *ngIf=\"!filtersOpen\" class=\"search-bar-holder\">\r\n                <div *ngTemplateOutlet=\"searchBar\"></div>\r\n              </div>\r\n              <avl-icon-button\r\n                (click)=\"toggleFilters()\"\r\n                class=\"pointer\"\r\n                icon=\"icons:filter-list\"\r\n                [badge]=\"badge\"\r\n              ></avl-icon-button>\r\n            </div>\r\n          </div>\r\n          <avl-datatable\r\n            #notificationTable\r\n            class=\"filterDatatable\"\r\n            multi-select\r\n            allow-active-row\r\n            pagination\r\n            [columnDefinitions]=\"columnDefinitions\"\r\n            [pageSize]=\"pageSize\"\r\n            [data]=\"notifications | prepareNotifications: 'dialog'\"\r\n            [pageSizeOptions]=\"pageSizeOptions\"\r\n            [(selectedValues)]=\"selectedRows\"\r\n            (selectedValuesChange)=\"selectedValuesChanged()\"\r\n            (page-size-changed)=\"onPageSizeChanged($event)\"\r\n            (selected-page-changed)=\"onSelectedPageChanged($event)\"\r\n            (on-row-clicked)=\"onRowClicked($event)\"\r\n          >\r\n          </avl-datatable>\r\n        </div>\r\n        <avl-side-sheet class=\"filter-sheet\" divider [(open)]=\"filtersOpen\" #filterSheet>\r\n          <div slot=\"title\">\r\n            <h2>{{ translationBase + 'Filters' | translate }}</h2>\r\n          </div>\r\n          <div slot=\"content\">\r\n            <form #filterForm=\"ngForm\">\r\n              <!--ngIf is needed to rerender template on filtersheet toggle-->\r\n              <div *ngIf=\"filtersOpen\" class=\"search-bar-holder\">\r\n                <div *ngTemplateOutlet=\"searchBar\"></div>\r\n              </div>\r\n\r\n              <avl-list-expander\r\n                [open]=\"true\"\r\n                [narrow]=\"true\"\r\n                #filterFormType=\"ngModelGroup\"\r\n                ngModelGroup=\"type\"\r\n              >\r\n                <div role=\"header\">\r\n                  <h3>\r\n                    <span>{{ translationBase + 'Type' | translate }}</span>\r\n                    <span *ngIf=\"activeFilters?.type | iterableObject as activeFilterGroup\">\r\n                      <ng-container\r\n                        *ngTemplateOutlet=\"\r\n                          currentHeader;\r\n                          context: {\r\n                            activeFilterGroup: activeFilterGroup,\r\n                            filterGroup: filters?.type | iterableObject\r\n                          }\r\n                        \"\r\n                      ></ng-container>\r\n                    </span>\r\n                  </h3>\r\n                </div>\r\n                <div role=\"content\" class=\"filterContent\">\r\n                  <div *ngFor=\"let type of filters?.type | iterableObject\">\r\n                    <avl-checkbox name=\"{{ type }}\" [(ngModel)]=\"filters.type[type]\">\r\n                      {{ translationBase + (type | titlecase) | translate }}\r\n                      <span *ngIf=\"notifications.length\">({{ notificationsCount[type] }})</span>\r\n                    </avl-checkbox>\r\n                    <avl-icon\r\n                      id=\"{{ type }}Icon\"\r\n                      class=\"typeIcons\"\r\n                      icon=\"icons:{{ getIconByType(type) }}\"\r\n                    ></avl-icon>\r\n                  </div>\r\n                </div>\r\n              </avl-list-expander>\r\n              <avl-list-expander\r\n                [open]=\"true\"\r\n                [narrow]=\"true\"\r\n                #filterFormState=\"ngModelGroup\"\r\n                ngModelGroup=\"state\"\r\n              >\r\n                <div role=\"header\">\r\n                  <h3>\r\n                    <span>{{ translationBase + 'State' | translate }}</span>\r\n                    <span *ngIf=\"activeFilters?.state | iterableObject as activeFilterGroup\">\r\n                      <ng-container\r\n                        *ngTemplateOutlet=\"\r\n                          currentHeader;\r\n                          context: {\r\n                            activeFilterGroup: activeFilterGroup,\r\n                            filterGroup: filters?.state | iterableObject\r\n                          }\r\n                        \"\r\n                      ></ng-container>\r\n                    </span>\r\n                  </h3>\r\n                </div>\r\n                <div role=\"content\" class=\"filterContent\">\r\n                  <div *ngFor=\"let state of filters?.state | iterableObject\">\r\n                    <avl-checkbox name=\"{{ state }}\" [(ngModel)]=\"filters.state[state]\">\r\n                      {{ translationBase + (state | titlecase) | translate }} ({{\r\n                        notificationsCount[state]\r\n                      }})\r\n                    </avl-checkbox>\r\n                    <avl-icon\r\n                      id=\"{{ state }}Icon\"\r\n                      class=\"typeIcons\"\r\n                      icon=\"icons:{{ getIconByType(state) }}\"\r\n                    ></avl-icon>\r\n                  </div>\r\n                </div>\r\n              </avl-list-expander>\r\n              <avl-list-expander\r\n                [open]=\"true\"\r\n                [narrow]=\"true\"\r\n                #filterFormDate=\"ngModelGroup\"\r\n                ngModelGroup=\"date\"\r\n              >\r\n                <div role=\"header\">\r\n                  <h3 id=\"date-group\" #dateGroup>\r\n                    {{ dateFilterGroupHeader }}\r\n                  </h3>\r\n                  <avl-tooltip\r\n                    for=\"date-group\"\r\n                    *ngIf=\"dateGroup.scrollWidth > dateGroup.clientWidth\"\r\n                  >\r\n                    {{ dateFilterGroupHeader }}\r\n                  </avl-tooltip>\r\n                </div>\r\n                <div role=\"content\">\r\n                  <avl-date\r\n                    *ngFor=\"let date of filters?.date | iterableObject\"\r\n                    class=\"date-control\"\r\n                    [(ngModel)]=\"filters.date[date]\"\r\n                    name=\"{{ date }}\"\r\n                    (valueChange)=\"updateLabels()\"\r\n                    [label]=\"translationBase + (date | capitalize) | translate\"\r\n                    [disabledRanges]=\"disabledRange[date]\"\r\n                    #dateEl\r\n                    auto-validate\r\n                    [dateInvalid]=\"dateEl\"\r\n                  ></avl-date>\r\n                </div>\r\n              </avl-list-expander>\r\n              <ng-template #searchBar>\r\n                <avl-search-bar\r\n                  placeholder=\"{{ translationBase + 'Search' | translate }}\"\r\n                  always-open\r\n                  #searchBarElement\r\n                  name=\"search\"\r\n                  [(ngModel)]=\"filters.search\"\r\n                ></avl-search-bar>\r\n              </ng-template>\r\n            </form>\r\n          </div>\r\n          <div slot=\"actions\">\r\n            <avl-button (click)=\"reset()\">{{ translationBase + 'Reset' | translate }}</avl-button>\r\n          </div>\r\n        </avl-side-sheet>\r\n      </div>\r\n    </avl-dialog-content>\r\n  </ng-template>\r\n\r\n  <ng-template\r\n    #currentHeader\r\n    let-activeFilterGroup=\"activeFilterGroup\"\r\n    let-filterGroup=\"filterGroup\"\r\n  >\r\n    <span>: </span><span *ngIf=\"activeFilterGroup.length === filterGroup.length\">all</span>\r\n    <span *ngIf=\"activeFilterGroup.length !== filterGroup.length\">\r\n      <span *ngFor=\"let item of activeFilterGroup; index as i\">\r\n        <span>{{ translationBase + (item | titlecase) | translate }}</span>\r\n        <span *ngIf=\"i < activeFilterGroup.length - 1\">, </span>\r\n      </span>\r\n    </span>\r\n  </ng-template>\r\n</avl-dialog>\r\n", styles: [".content{position:relative;display:flex;flex-direction:column;flex-grow:1}.divider{background-color:var(--avl-divider-color)}.divider.vertical{width:1px;height:auto;margin:12px 0}.search-bar-holder{padding:0 9px}form .search-bar-holder{display:block;position:relative;padding:12px 24px 12px 12px}.table-header{display:flex;justify-content:space-between;align-items:center}.table-header-right{display:flex}.main-container{display:flex;height:100%}.main-container.hidden{display:none}.filterDatatable{height:100%}.filter-sheet{--avl-side-sheet-padding:0px;--avl-side-sheet-height:84vh;width:300px}.filter-sheet h2{font-size:20px;margin-left:24px}.filter-sheet h3{font-size:16px;margin:0;text-overflow:ellipsis;overflow:hidden}.pointer{cursor:pointer}#errorIcon{--avl-icon-custom-color:var(--avl-error-color)}#warningIcon{--avl-icon-custom-color:var(--avl-warning-color)}#okIcon{--avl-icon-custom-color:var(--avl-ok-color)}#infoIcon{--avl-icon-custom-color:var(--avl-icon-default-color)}.filterContent{position:relative}.typeIcons{position:absolute;right:0;margin-top:12px;margin-bottom:12px}.date-control{width:100%}avl-dialog-content{--padding-top:1px!important;--padding-right:0px!important;--padding-bottom:2px!important}avl-dialog-header{z-index:1}avl-side-sheet{--avl-side-sheet-height:unset!important;box-shadow:none;border-left:1px solid var(--avl-divider-color)}avl-datatable{--margin-top-pages:0px!important}"], components: [{ type: i1.AvlDialogComponent, selector: "avl-dialog", inputs: ["closeOnScrimClick", "complex", "warningHeaderText", "warningDialogText", "fullscreen", "open", "dirty", "warningOnClose"], outputs: ["openChange"] }, { type: i1.AvlDialogHeaderComponent, selector: "avl-dialog-header" }, { type: i1.AvlDialogContentComponent, selector: "avl-dialog-content" }, { type: i2.AvlListExpanderComponent, selector: "avl-list-expander", inputs: ["narrow", "open"], outputs: ["openChange"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i4.AvlInteractionControlDirective, selector: "avl-button,avl-icon-button,avl-item,avl-search-bar,avl-radio-button,avl-upload,avl-snackbar", outputs: ["focusedChange"] }, { type: i4.AvlIconButtonDirective, selector: "avl-icon-button", outputs: ["badgeChange", "badgeValueChange"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i4.AvlMultiSelectControlDirective, selector: "avl-datatable,avl-list,avl-chip-list, avl-chip-input", outputs: ["selectedIndexesChange", "selectedValuesChange"] }, { type: i4.AvlSingleSelectControlDirective, selector: "avl-datatable,avl-dropdown,avl-list,avl-radio-group,avl-app-switcher,avl-chip-list,avl-combo-box", outputs: ["selectedIndexChange", "selectedValueChange"] }, { type: i4.AvlDatatableDirective, selector: "avl-datatable", outputs: ["buttonClick", "overflowMenuItemClick", "linkClick", "pageSizeChange", "selectedPageChange"] }, { type: i4.AvlSideSheetDirective, selector: "avl-side-sheet", outputs: ["openChange"] }, { type: i5.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i5.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i5.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i5.NgModelGroup, selector: "[ngModelGroup]", inputs: ["ngModelGroup"], exportAs: ["ngModelGroup"] }, { type: i4.AvlCheckableControlDirective, selector: "avl-checkbox,avl-radio-button, avl-icon-toggle, avl-switch", outputs: ["checkedChange"] }, { type: i4.AvlFormControlDirective, selector: "avl-date,avl-dropdown,avl-time,avl-icon-toggle,avl-numberfield,avl-radio-group,avl-slider,avl-textarea,avl-textfield,avl-timespan,avl-checkbox,avl-switch,avl-chip-list,avl-upload,avl-search-bar,avl-chip-input", inputs: ["readonly"], outputs: ["invalidChange"] }, { type: i4.AvlCheckboxDirective, selector: "avl-checkbox", outputs: ["indeterminateChange"] }, { type: i5.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i5.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i4.AvlDateDirective, selector: "avl-date", outputs: ["valueChange"] }, { type: i6.DateInvalidValidatorDirective, selector: "[dateInvalid]", inputs: ["dateInvalid"] }, { type: i4.AvlSearchBarDirective, selector: "avl-search-bar", outputs: ["queryChange", "openChange"] }], pipes: { "translate": i7.TranslatePipe, "prepareNotifications": i8.PrepareNotificationsPipe, "iterableObject": i9.IterableObjectPipe, "titlecase": i3.TitleCasePipe, "capitalize": i10.CapitalizePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlNotificationDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'avl-notification-dialog',
                    templateUrl: './avl-notification-dialog.component.html',
                    styleUrls: ['./avl-notification-dialog.component.css'],
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], propDecorators: { open: [{
                type: Input
            }], pageSizeOptions: [{
                type: Input
            }], columnDefinitions: [{
                type: Input
            }], notificationsCount: [{
                type: Input
            }], refreshBadge: [{
                type: Input
            }], notifications: [{
                type: Input
            }], openChange: [{
                type: Output
            }], filtersChange: [{
                type: Output
            }], markSelectedAsRead: [{
                type: Output
            }], markSelectedAsUnread: [{
                type: Output
            }], tableRefresh: [{
                type: Output
            }], selectedPageChanged: [{
                type: Output
            }], pageSizeChanged: [{
                type: Output
            }], table: [{
                type: ViewChild,
                args: ['notificationTable']
            }], filterForm: [{
                type: ViewChild,
                args: ['filterForm', { read: NgForm }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZsLW5vdGlmaWNhdGlvbi1kaWFsb2cuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbm90aWZpY2F0aW9uL3NyYy9saWIvY29tcG9uZW50cy9hdmwtbm90aWZpY2F0aW9uLWRpYWxvZy9hdmwtbm90aWZpY2F0aW9uLWRpYWxvZy5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9ub3RpZmljYXRpb24vc3JjL2xpYi9jb21wb25lbnRzL2F2bC1ub3RpZmljYXRpb24tZGlhbG9nL2F2bC1ub3RpZmljYXRpb24tZGlhbG9nLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUNMLFNBQVMsRUFFVCxNQUFNLEVBQ04sWUFBWSxFQUVaLHVCQUF1QixFQUN4QixNQUFNLGVBQWUsQ0FBQztBQVN2QixPQUFPLHlEQUF5RCxDQUFDO0FBQ2pFLE9BQU8sMkNBQTJDLENBQUM7QUFDbkQsT0FBTyx1REFBdUQsQ0FBQztBQUMvRCxPQUFPLG1EQUFtRCxDQUFDO0FBQzNELE9BQU8saURBQWlELENBQUM7QUFDekQsT0FBTywyQ0FBMkMsQ0FBQztBQUVuRCxPQUFPLEVBQ0wsMEJBQTBCLEVBQzFCLGVBQWUsRUFDZix5QkFBeUIsRUFDekIsbUJBQW1CLEVBQ25CLGtCQUFrQixFQUNsQixnQkFBZ0IsRUFDaEIsY0FBYyxFQUNmLE1BQU0sa0NBQWtDLENBQUM7QUFDMUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hDLE9BQU8sRUFBRSxPQUFPLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQzdDLE9BQU8sRUFBRSxZQUFZLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3ZGLE9BQU8sRUFBRSwwQkFBMEIsRUFB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MENBQTBDO29CQUN2RCxTQUFTLEVBQUUsQ0FBQyx5Q0FBeUMsQ0FBQztvQkFDdEQsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07aUJBQ2hEOzhCQUVVLElBQUk7c0JBQVosS0FBSztnQkFDRyxlQUFlO3NCQUF2QixLQUFLO2dCQUNHLGlCQUFpQjtzQkFBekIsS0FBSztnQkFDRyxrQkFBa0I7c0JBQTFCLEtBQUs7Z0JBU0csWUFBWTtzQkFBcEIsS0FBSztnQkFFRixhQUFhO3NCQURoQixLQUFLO2dCQVNJLFVBQVU7c0JBQW5CLE1BQU07Z0JBQ0csYUFBYTtzQkFBdEIsTUFBTTtnQkFDRyxrQkFBa0I7c0JBQTNCLE1BQU07Z0JBQ0csb0JBQW9CO3NCQUE3QixNQUFNO2dCQUNHLFlBQVk7c0JBQXJCLE1BQU07Z0JBQ0csbUJBQW1CO3NCQUE1QixNQUFNO2dCQUNHLGVBQWU7c0JBQXhCLE1BQU07Z0JBRWdDLEtBQUs7c0JBQTNDLFNBQVM7dUJBQUMsbUJBQW1CO2dCQVVpQixVQUFVO3NCQUF4RCxTQUFTO3VCQUFDLFlBQVksRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIENvbXBvbmVudCxcclxuICBJbnB1dCxcclxuICBWaWV3Q2hpbGQsXHJcbiAgRWxlbWVudFJlZixcclxuICBPdXRwdXQsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIE9uSW5pdCxcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb2x1bW4gfSBmcm9tICdAYXZsLWNvbnRyb2xzL2RhdGF0YWJsZS9kaXN0L2F2bC1kYXRhdGFibGUvY29sdW1uLWRlZmluaXRpb25zJztcclxuaW1wb3J0IHtcclxuICBBdmxEYXRhdGFibGUsXHJcbiAgUGFnZVNpemVPcHRpb25cclxufSBmcm9tICdAYXZsLWNvbnRyb2xzL2RhdGF0YWJsZS9kaXN0L2F2bC1kYXRhdGFibGUvYXZsLWRhdGF0YWJsZSc7XHJcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJ0BhdmwtY29udHJvbHMvY29yZS9kaXN0L2F2bC1kYXRlL2F2bC1kYXRlJztcclxuaW1wb3J0IHsgQXZsTm90aWZpY2F0aW9uLCBBdmxOb3RpZmljYXRpb25zQ291bnQgfSBmcm9tICdAYXZsLWludGVyZmFjZXMvaW50ZXJmYWNlcyc7XHJcblxyXG5pbXBvcnQgJ0BhdmwtY29udHJvbHMvY29yZS9kaXN0L2F2bC1pY29uLWJ1dHRvbi9hdmwtaWNvbi1idXR0b24nO1xyXG5pbXBvcnQgJ0BhdmwtY29udHJvbHMvY29yZS9kaXN0L2F2bC1pY29uL2F2bC1pY29uJztcclxuaW1wb3J0ICdAYXZsLWNvbnRyb2xzL2NvcmUvZGlzdC9hdmwtc2lkZS1zaGVldC9hdmwtc2lkZS1zaGVldCc7XHJcbmltcG9ydCAnQGF2bC1jb250cm9scy9jb3JlL2Rpc3QvYXZsLWNoZWNrYm94L2F2bC1jaGVja2JveCc7XHJcbmltcG9ydCAnQGF2bC1jb250cm9scy9jb3JlL2Rpc3QvYXZsLXRvb2x0aXAvYXZsLXRvb2x0aXAnO1xyXG5pbXBvcnQgJ0BhdmwtY29udHJvbHMvY29yZS9kaXN0L2F2bC1kYXRlL2F2bC1kYXRlJztcclxuaW1wb3J0IHsgQXZsTm90aWZpY2F0aW9uVGFibGVJdGVtIH0gZnJvbSAnLi4vLi4vbW9kZWxzL25vdGlmaWNhdGlvbi1kaWFsb2cubW9kZWwnO1xyXG5pbXBvcnQge1xyXG4gIERFRkFVTFRfQ09MVU1OX0RFRklOSVRJT05TLFxyXG4gIERFRkFVTFRfRklMVEVSUyxcclxuICBERUZBVUxUX1BBR0VfU0laRV9PUFRJT05TLFxyXG4gIFNUQVRFX0lDT05fTUFQUElOR1MsXHJcbiAgVFlQRV9JQ09OX01BUFBJTkdTLFxyXG4gIFRSQU5TTEFUSU9OX0JBU0UsXHJcbiAgQUNUSU9OX0JVVFRPTlNcclxufSBmcm9tICcuL2F2bC1ub3RpZmljYXRpb24tZGlhbG9nLmNvbnN0cyc7XHJcbmltcG9ydCB7IE5nRm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGRlYm91bmNlVGltZSwgZGlzdGluY3RVbnRpbENoYW5nZWQsIGZpbHRlciwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBOT1RJRklDQVRJT05fVFlQRV9NQVBQSU5HUyB9IGZyb20gJy4vYXZsLW5vdGlmaWNhdGlvbi1kaWFsb2cuY29uc3RzJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnYXZsLW5vdGlmaWNhdGlvbi1kaWFsb2cnLFxyXG4gIHRlbXBsYXRlVXJsOiAnLi9hdmwtbm90aWZpY2F0aW9uLWRpYWxvZy5jb21wb25lbnQuaHRtbCcsXHJcbiAgc3R5bGVVcmxzOiBbJy4vYXZsLW5vdGlmaWNhdGlvbi1kaWFsb2cuY29tcG9uZW50LmNzcyddLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBdmxOb3RpZmljYXRpb25EaWFsb2dDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xyXG4gIEBJbnB1dCgpIG9wZW46IGJvb2xlYW4gPSBmYWxzZTtcclxuICBASW5wdXQoKSBwYWdlU2l6ZU9wdGlvbnM6IFBhZ2VTaXplT3B0aW9uW10gPSBERUZBVUxUX1BBR0VfU0laRV9PUFRJT05TO1xyXG4gIEBJbnB1dCgpIGNvbHVtbkRlZmluaXRpb25zOiBDb2x1bW5bXSA9IERFRkFVTFRfQ09MVU1OX0RFRklOSVRJT05TO1xyXG4gIEBJbnB1dCgpIG5vdGlmaWNhdGlvbnNDb3VudDogQXZsTm90aWZpY2F0aW9uc0NvdW50ID0ge1xyXG4gICAgd2FybmluZzogMCxcclxuICAgIGluZm86IDAsXHJcbiAgICBvazogMCxcclxuICAgIGVycm9yOiAwLFxyXG4gICAgdW5yZWFkOiAwLFxyXG4gICAgcmVhZDogMCxcclxuICAgIHRvdGFsOiAwXHJcbiAgfTtcclxuICBASW5wdXQoKSByZWZyZXNoQmFkZ2U6IGJvb2xlYW47XHJcbiAgQElucHV0KClcclxuICBnZXQgbm90aWZpY2F0aW9ucygpOiBBdmxOb3RpZmljYXRpb25bXSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbm90aWZpY2F0aW9ucyB8fCBbXTtcclxuICB9XHJcblxyXG4gIHNldCBub3RpZmljYXRpb25zKG5vdGlmaWNhdGlvbnM6IEF2bE5vdGlmaWNhdGlvbltdKSB7XHJcbiAgICB0aGlzLl9ub3RpZmljYXRpb25zID0gbm90aWZpY2F0aW9ucztcclxuICB9XHJcblxyXG4gIEBPdXRwdXQoKSBvcGVuQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XHJcbiAgQE91dHB1dCgpIGZpbHRlcnNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxDdXN0b21FdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPEN1c3RvbUV2ZW50PigpO1xyXG4gIEBPdXRwdXQoKSBtYXJrU2VsZWN0ZWRBc1JlYWQ6IEV2ZW50RW1pdHRlcjxhbnlbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPEF2bE5vdGlmaWNhdGlvbltdPigpO1xyXG4gIEBPdXRwdXQoKSBtYXJrU2VsZWN0ZWRBc1VucmVhZDogRXZlbnRFbWl0dGVyPGFueVtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8QXZsTm90aWZpY2F0aW9uW10+KCk7XHJcbiAgQE91dHB1dCgpIHRhYmxlUmVmcmVzaDogRXZlbnRFbWl0dGVyPGFueVtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8QXZsTm90aWZpY2F0aW9uW10+KCk7XHJcbiAgQE91dHB1dCgpIHNlbGVjdGVkUGFnZUNoYW5nZWQ6IEV2ZW50RW1pdHRlcjxhbnlbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPEF2bE5vdGlmaWNhdGlvbltdPigpO1xyXG4gIEBPdXRwdXQoKSBwYWdlU2l6ZUNoYW5nZWQ6IEV2ZW50RW1pdHRlcjxhbnlbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPEF2bE5vdGlmaWNhdGlvbltdPigpO1xyXG5cclxuICBAVmlld0NoaWxkKCdub3RpZmljYXRpb25UYWJsZScpIHB1YmxpYyB0YWJsZTogRWxlbWVudFJlZjxBdmxEYXRhdGFibGU+O1xyXG5cclxuICBwdWJsaWMgYmFkZ2U6IGJvb2xlYW4gPSBmYWxzZTtcclxuICBwdWJsaWMgZGlzYWJsZU1hcmtpbmdTZWxlY3RlZDogYm9vbGVhbiA9IHRydWU7XHJcbiAgcHVibGljIGZpbHRlcnMgPSB0aGlzLmRlZXBDb3B5T2JqZWN0KERFRkFVTFRfRklMVEVSUyk7XHJcbiAgcHVibGljIGZpbHRlcnNPcGVuID0gdHJ1ZTtcclxuICBwdWJsaWMgYWN0aXZlRmlsdGVyczoge1trZXk6c3RyaW5nXTogb2JqZWN0fTtcclxuXHJcbiAgcHJpdmF0ZSBmaWx0ZXJGb3JtU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XHJcblxyXG4gIEBWaWV3Q2hpbGQoJ2ZpbHRlckZvcm0nLCB7IHJlYWQ6IE5nRm9ybSB9KSBzZXQgZmlsdGVyRm9ybShmaWx0ZXJGb3JtOiBOZ0Zvcm0pIHtcclxuICAgIHRoaXMuZmlsdGVyRm9ybVN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcclxuICAgIHRoaXMuZmlsdGVyRm9ybVN1YnNjcmlwdGlvbiA9IGZpbHRlckZvcm0/LnZhbHVlQ2hhbmdlc1xyXG4gICAgICAucGlwZShcclxuICAgICAgICBkZWJvdW5jZVRpbWUoMzAwKSxcclxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxyXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCQpLFxyXG4gICAgICAgIGZpbHRlcihfID0+IGZpbHRlckZvcm0udmFsaWQpXHJcbiAgICAgIClcclxuICAgICAgLnN1YnNjcmliZSh2YWx1ZSA9PiB0aGlzLmhhbmRsZUZpbHRlcnNDaGFuZ2VkKHZhbHVlKSk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgdHJhbnNsYXRpb25CYXNlID0gVFJBTlNMQVRJT05fQkFTRTtcclxuICBwdWJsaWMgYWN0aW9uQnV0dG9ucyA9IEFDVElPTl9CVVRUT05TO1xyXG4gIHB1YmxpYyBkaXNhYmxlZFJhbmdlOiB7IFtrZXk6IHN0cmluZ106IERhdGVSYW5nZVtdIH0gPSB7fTtcclxuICBwcml2YXRlIGRhdGVGaWx0ZXJHcm91cEluaXRIZWFkZXIgPSAnRGF0ZSc7XHJcbiAgcHVibGljIGRhdGVGaWx0ZXJHcm91cEhlYWRlciA9IHRoaXMuZGF0ZUZpbHRlckdyb3VwSW5pdEhlYWRlcjtcclxuXHJcbiAgLy9ub3RpZmljYXRpb24gZGF0YXRhYmxlIG9wdGlvbnNcclxuICBwdWJsaWMgc2VsZWN0ZWRSb3dzOiBBdmxOb3RpZmljYXRpb25UYWJsZUl0ZW1bXSA9IFtdO1xyXG4gIHB1YmxpYyBwYWdlU2l6ZSA9IDE1O1xyXG5cclxuICBwcml2YXRlIF9ub3RpZmljYXRpb25zOiBBdmxOb3RpZmljYXRpb25bXSA9IFtdO1xyXG4gIHByb3RlY3RlZCBkZXN0cm95ZWQkOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3QoKTtcclxuXHJcbiAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgdGhpcy5kZXN0cm95ZWQkLm5leHQoKTtcclxuICAgIHRoaXMuZGVzdHJveWVkJC5jb21wbGV0ZSgpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xyXG4gICAgdGhpcy50cmFuc2xhdGVMYWJlbHMoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXRJY29uQnlUeXBlKHR5cGU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgY2FzZSAndW5yZWFkJzpcclxuICAgICAgICByZXR1cm4gU1RBVEVfSUNPTl9NQVBQSU5HU1snZmFsc2UnXTtcclxuICAgICAgY2FzZSAncmVhZCc6XHJcbiAgICAgICAgcmV0dXJuIFNUQVRFX0lDT05fTUFQUElOR1NbJ3RydWUnXTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBmb3IgKGxldCBbdHlwZUtleSwgdHlwZVZhbHVlXSBvZiBOT1RJRklDQVRJT05fVFlQRV9NQVBQSU5HUykge1xyXG4gICAgICAgICAgaWYgKHR5cGVWYWx1ZSA9PT0gdHlwZSAmJiB0eXBlb2YgdHlwZUtleSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRZUEVfSUNPTl9NQVBQSU5HU1t0eXBlS2V5XTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogRW1pdHMgZXZlbnQgd2hlbiBkaWFsb2cgb3BlbnMgb3IgY2xvc2VzICovXHJcbiAgcHVibGljIG9wZW5DaGFuZ2VkKG9wZW46IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIHRoaXMub3BlbkNoYW5nZS5lbWl0KG9wZW4pO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG9uU2VsZWN0ZWRQYWdlQ2hhbmdlZChldmVudCkge1xyXG4gICAgdGhpcy5zZWxlY3RlZFBhZ2VDaGFuZ2VkLmVtaXQoZXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG9uUGFnZVNpemVDaGFuZ2VkKGV2ZW50KSB7XHJcbiAgICB0aGlzLnBhZ2VTaXplQ2hhbmdlZC5lbWl0KGV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKiBUb2dnbGVzIGRpc3BsYXlpbmcgb2YgZmlsdGVyIHNoZWV0ICovXHJcbiAgcHVibGljIHRvZ2dsZUZpbHRlcnMoKTogdm9pZCB7XHJcbiAgICB0aGlzLmZpbHRlcnNPcGVuID0gIXRoaXMuZmlsdGVyc09wZW47XHJcbiAgfVxyXG5cclxuICAvKiogUmVmcmVzaGVzIHRoZSBkYXRhdGFibGUgd2hlbiByZWZyZXNoIGJ1dHRvbiBpcyBjbGlja2VkICovXHJcbiAgcHVibGljIHJlZnJlc2hUYWJsZSgpOiB2b2lkIHtcclxuICAgIHRoaXMudGFibGVSZWZyZXNoLmVtaXQoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBtYXJrQXMoc3RhdGU6IHN0cmluZykge1xyXG4gICAgc3RhdGUgPT09IE5PVElGSUNBVElPTl9UWVBFX01BUFBJTkdTLmdldCh0cnVlKSA/IHRoaXMubWFya0FzUmVhZCgpIDogdGhpcy5tYXJrQXNVbnJlYWQoKTtcclxuICB9XHJcblxyXG4gIC8qKiBDaGFuZ2VzIHNlbGVjdGVkIG5vdGlmaWNhdGlvbiBzdGF0ZSB0byByZWFkICovXHJcbiAgcHVibGljIG1hcmtBc1JlYWQoKTogdm9pZCB7XHJcbiAgICB0aGlzLm1hcmtTZWxlY3RlZEFzUmVhZC5lbWl0KHRoaXMuc2VsZWN0ZWRSb3dzKTtcclxuICB9XHJcblxyXG4gIC8qKiBDaGFuZ2VzIHNlbGVjdGVkIG5vdGlmaWNhdGlvbiBzdGF0ZSB0byB1bnJlYWQgKi9cclxuICBwdWJsaWMgbWFya0FzVW5yZWFkKCk6IHZvaWQge1xyXG4gICAgdGhpcy5tYXJrU2VsZWN0ZWRBc1VucmVhZC5lbWl0KHRoaXMuc2VsZWN0ZWRSb3dzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0cyBhbGwgZmlsdGVycy5cclxuICAgKi9cclxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XHJcbiAgICB0aGlzLmZpbHRlcnMgPSB0aGlzLmRlZXBDb3B5T2JqZWN0KERFRkFVTFRfRklMVEVSUyk7XHJcbiAgICB0aGlzLnVwZGF0ZUxhYmVscygpO1xyXG4gICAgdGhpcy5iYWRnZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqIENhbGxlZCB3aGVuIHNlbGVjdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSB0YWJsZSByb3dzICovXHJcbiAgcHVibGljIHNlbGVjdGVkVmFsdWVzQ2hhbmdlZCgpIHtcclxuICAgIHRoaXMuZGlzYWJsZU1hcmtpbmdTZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRSb3dzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgIHRoaXMuZGlzYWJsZU1hcmtpbmdTZWxlY3RlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogVXBkYXRlcyBkYXRlIGZpbHRlciBoZWFkZXIgbGFiZWxzIHdoZW4gZGF0ZSBjaGFuZ2VzICovXHJcbiAgcHVibGljIGFzeW5jIHVwZGF0ZUxhYmVscygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IHRyYW5zbGF0aW9uU2VydmljZSA9IEF2bExvY2FsaXphdGlvblNlcnZpY2UudHJhbnNsYXRpb25TZXJ2aWNlO1xyXG4gICAgY29uc3QgeyBkYXRlRnJvbSwgZGF0ZVRvIH0gPSB0aGlzLmZpbHRlcnMuZGF0ZTtcclxuICAgIGlmICghZGF0ZUZyb20gJiYgIWRhdGVUbykge1xyXG4gICAgICB0aGlzLmRhdGVGaWx0ZXJHcm91cEhlYWRlciA9IHRoaXMuZGF0ZUZpbHRlckdyb3VwSW5pdEhlYWRlcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZGF0ZUZpbHRlckdyb3VwSGVhZGVyID0gYXdhaXQgdHJhbnNsYXRpb25TZXJ2aWNlLnRyYW5zbGF0ZShcclxuICAgICAgICAnVml6Qm94Lk5vdGlmaWNhdGlvbkRpYWxvZy5EYXRlUmFuZ2UnLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGRhdGVGcm9tOiB0aGlzLmZvcm1hdERhdGVUaW1lKGRhdGVGcm9tKSxcclxuICAgICAgICAgIGRhdGVUbzogdGhpcy5mb3JtYXREYXRlVGltZShkYXRlVG8pXHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEV2ZW50IGZpcmVkIHdoZW4gdGFibGUgcm93IGlzIGNsaWNrZWRcclxuICAgKiBkZXBlbmRpbmcgb24gdGhlIG5vdGlmaWNhdGlvbiBmbGFnIGl0IG9wZW5zIGluIG5ldyB0YWJcclxuICAgKi9cclxuICBwdWJsaWMgb25Sb3dDbGlja2VkKGV2ZW50OiBFdmVudCk6IHZvaWQge1xyXG4gICAgY29uc3Qgcm93ID0gKDxDdXN0b21FdmVudD5ldmVudCkuZGV0YWlsO1xyXG4gICAgaWYgKHJvdy5saW5rKSB7XHJcbiAgICAgIGlmIChyb3cub3BlbkluTmV3VGFiKSB7XHJcbiAgICAgICAgd2luZG93Lm9wZW4ocm93LmxpbmssICdfYmxhbmsnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB3aW5kb3cub3Blbihyb3cubGluaywgJ19zZWxmJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgaGFuZGxlRmlsdGVyc0NoYW5nZWQodmFsdWUpOiB2b2lkIHtcclxuICAgIHRoaXMuYWN0aXZlRmlsdGVycyA9IHRoaXMuZ2V0QWN0aXZlRmlsdGVycyh2YWx1ZSk7XHJcbiAgICBpZiAodGhpcy5hY3RpdmVGaWx0ZXJzPy5kYXRlKSB7XHJcbiAgICAgIHRoaXMuZGlzYWJsZWRSYW5nZSA9IHRoaXMuZ2V0RGlzYWJsZWRSYW5nZSgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5iYWRnZSA9IEJvb2xlYW4odGhpcy5hY3RpdmVGaWx0ZXJzKTtcclxuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaWx0ZXJzQ2hhbmdlJywgeyBkZXRhaWw6IHRoaXMuYWN0aXZlRmlsdGVycyB9KTtcclxuICAgIHRoaXMuZmlsdGVyc0NoYW5nZS5lbWl0KGV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKiBDYWxjdWxhdGVzIGFjdGl2ZSBmaWx0ZXJzIGZyb20gZmlsdGVyIG9iamVjdCAqL1xyXG4gIHB1YmxpYyBnZXRBY3RpdmVGaWx0ZXJzKGZpbHRlcnM6IG9iamVjdCk6IGFueSB7XHJcbiAgICBPYmplY3Qua2V5cyhmaWx0ZXJzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGNvbnN0IGZpbHRlciA9IGZpbHRlcnNba2V5XTtcclxuICAgICAgLy9kb24ndCBpdGVyYXRlIHRocm91Z2ggc2VhcmNoXHJcbiAgICAgIGlmIChmaWx0ZXIgJiYgdHlwZW9mIGZpbHRlciAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICBmaWx0ZXJzW2tleV0gPSB0aGlzLnJlbW92ZUluYWN0aXZlRmlsdGVyS2V5cyhmaWx0ZXIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVJbmFjdGl2ZUZpbHRlcktleXMoZmlsdGVycyk7XHJcbiAgfVxyXG5cclxuICAvKiogZGlzYWJsZSBkYXRlcyBiZWZvcmUgZGF0ZUZyb20gaW4gZGF0ZVRvLCBhbmQgZGF0ZXMgYWZ0ZXIgZGF0ZVRvIGluIGRhdGVGcm9tICAqL1xyXG4gIHByaXZhdGUgZ2V0RGlzYWJsZWRSYW5nZSgpOiB7IFtrZXk6IHN0cmluZ106IERhdGVSYW5nZVtdIH0ge1xyXG4gICAgY29uc3QgeyBkYXRlRnJvbSwgZGF0ZVRvIH0gPSB0aGlzLmZpbHRlcnMuZGF0ZTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRhdGVGcm9tOiBkYXRlVG8gPyBbeyBmcm9tOiBkYXRlVG8gfV0gOiB1bmRlZmluZWQsXHJcbiAgICAgIGRhdGVUbzogZGF0ZUZyb20gPyBbeyB0bzogZGF0ZUZyb20gfV0gOiB1bmRlZmluZWRcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKiogUmVtb3ZlcyBpbmFjdGl2ZSBmaWx0ZXJzIGZyb20gZmlsdGVyIG9iamVjdCBhbmQgcmV0dXJucyBpdCAqL1xyXG4gIHByaXZhdGUgcmVtb3ZlSW5hY3RpdmVGaWx0ZXJLZXlzKGZpbHRlcik6IG9iamVjdCB7XHJcbiAgICBPYmplY3Qua2V5cyhmaWx0ZXIpXHJcbiAgICAgIC5maWx0ZXIoc2Vjb25kTGV2ZWxLZXkgPT4gIUJvb2xlYW4oZmlsdGVyW3NlY29uZExldmVsS2V5XSkpXHJcbiAgICAgIC5mb3JFYWNoKHNlY29uZExldmVsS2V5ID0+IGRlbGV0ZSBmaWx0ZXJbc2Vjb25kTGV2ZWxLZXldKTtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhmaWx0ZXIpPy5sZW5ndGggPyBmaWx0ZXIgOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKiogRm9ybWF0cyBkYXRlIHRpbWUgdG8gZGF0ZS1zaG9ydCAqL1xyXG4gIHByaXZhdGUgZm9ybWF0RGF0ZVRpbWUoZDogRGF0ZSk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gZCA/IEF2bExvY2FsaXphdGlvblNlcnZpY2UuZm9ybWF0RGF0ZVRpbWUoZCwgeyBmb3JtYXQ6ICdkYXRlLXNob3J0JyB9KSA6ICcoLSknO1xyXG4gIH1cclxuXHJcbiAgLyoqIERlZXAgY29weSBvZiBmaWx0ZXJzIG9iamVjdCAqL1xyXG4gIHByaXZhdGUgZGVlcENvcHlPYmplY3Qob2JqZWN0OiBhbnkpOiBhbnkge1xyXG4gICAgY29uc3QgY29waWVkT2JqZWN0ID0ge307XHJcbiAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgY29waWVkT2JqZWN0W2tleV0gPVxyXG4gICAgICAgIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ29iamVjdCcgPyBPYmplY3QuYXNzaWduKHt9LCBvYmplY3Rba2V5XSkgOiBvYmplY3Rba2V5XTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNvcGllZE9iamVjdDtcclxuICB9XHJcblxyXG4gIC8vIFRyYW5zbGF0aW9uc1xyXG4gIHByaXZhdGUgYXN5bmMgdHJhbnNsYXRlTGFiZWxzKCkge1xyXG4gICAgaWYgKCFBdmxMb2NhbGl6YXRpb25TZXJ2aWNlIHx8ICFBdmxMb2NhbGl6YXRpb25TZXJ2aWNlLnRyYW5zbGF0aW9uU2VydmljZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdHJhbnNsYXRpb25TZXJ2aWNlID0gQXZsTG9jYWxpemF0aW9uU2VydmljZS50cmFuc2xhdGlvblNlcnZpY2U7XHJcbiAgICB0aGlzLmRhdGVGaWx0ZXJHcm91cEluaXRIZWFkZXIgPSBhd2FpdCB0cmFuc2xhdGlvblNlcnZpY2UudHJhbnNsYXRlKFxyXG4gICAgICAnVml6Qm94Lk5vdGlmaWNhdGlvbkRpYWxvZy5EYXRlJ1xyXG4gICAgKTtcclxuICAgIHRoaXMuZGF0ZUZpbHRlckdyb3VwSGVhZGVyID0gdGhpcy5kYXRlRmlsdGVyR3JvdXBJbml0SGVhZGVyO1xyXG4gICAgdGhpcy5wYWdlU2l6ZU9wdGlvbnMgPSBhd2FpdCB0aGlzLnRyYW5zbGF0ZVBhZ2VTaXplT3B0aW9ucyh0aGlzLnBhZ2VTaXplT3B0aW9ucyk7XHJcbiAgICB0aGlzLmNvbHVtbkRlZmluaXRpb25zID0gYXdhaXQgdGhpcy50cmFuc2xhdGVDb2x1bW5zKHRoaXMuY29sdW1uRGVmaW5pdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyB0cmFuc2xhdGVQYWdlU2l6ZU9wdGlvbnMob3B0aW9uczogUGFnZVNpemVPcHRpb25bXSk6IFByb21pc2U8UGFnZVNpemVPcHRpb25bXT4ge1xyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIG9wdGlvbiA9PiB0aGlzLnRyYW5zbGF0ZVBhZ2VTaXplT3B0aW9uKG9wdGlvbikpKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgdHJhbnNsYXRlUGFnZVNpemVPcHRpb24oaXRlbTogUGFnZVNpemVPcHRpb24pOiBQcm9taXNlPFBhZ2VTaXplT3B0aW9uPiB7XHJcbiAgICBjb25zdCB0cmFuc2xhdGlvblNlcnZpY2UgPSBBdmxMb2NhbGl6YXRpb25TZXJ2aWNlLnRyYW5zbGF0aW9uU2VydmljZTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC4uLml0ZW0sXHJcbiAgICAgIGxhYmVsOlxyXG4gICAgICAgIGl0ZW0udmFsdWUgPT09IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXHJcbiAgICAgICAgICA/IGF3YWl0IHRyYW5zbGF0aW9uU2VydmljZS50cmFuc2xhdGUoJ1ZpekJveC5Ob3RpZmljYXRpb25EaWFsb2cuU2hvd0FsbCcpXHJcbiAgICAgICAgICA6IGF3YWl0IHRyYW5zbGF0aW9uU2VydmljZS50cmFuc2xhdGUoJ1ZpekJveC5Ob3RpZmljYXRpb25EaWFsb2cuU2hvd1hQZXJQYWdlJywge1xyXG4gICAgICAgICAgICAgIHJvd3M6IGl0ZW0udmFsdWVcclxuICAgICAgICAgICAgfSlcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHRyYW5zbGF0ZUNvbHVtbnMoY29sdW1uOiBDb2x1bW5bXSk6IFByb21pc2U8Q29sdW1uW10+IHtcclxuICAgIHJldHVybiBQcm9taXNlLmFsbChjb2x1bW4ubWFwKGFzeW5jIGl0ZW0gPT4gdGhpcy50cmFuc2xhdGVDb2x1bW5JdGVtKGl0ZW0pKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHRyYW5zbGF0ZUNvbHVtbkl0ZW0oaXRlbTogQ29sdW1uKTogUHJvbWlzZTxDb2x1bW4+IHtcclxuICAgIGNvbnN0IHRyYW5zbGF0ZVNlcnZpY2UgPSBBdmxMb2NhbGl6YXRpb25TZXJ2aWNlLnRyYW5zbGF0aW9uU2VydmljZTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC4uLml0ZW0sXHJcbiAgICAgIGNhcHRpb246IGF3YWl0IHRyYW5zbGF0ZVNlcnZpY2UudHJhbnNsYXRlKGl0ZW0uY2FwdGlvbilcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsIjxhdmwtZGlhbG9nXHJcbiAgaWQ9XCJvdXRlckRpYWxvZ1wiXHJcbiAgW29wZW5dPVwib3BlblwiXHJcbiAgKG9wZW5DaGFuZ2UpPVwib3BlbkNoYW5nZWQoJGV2ZW50KVwiXHJcbiAgW2Nsb3NlT25TY3JpbUNsaWNrXT1cImZhbHNlXCJcclxuICBbZnVsbHNjcmVlbl09XCJ0cnVlXCJcclxuPlxyXG4gIDxuZy10ZW1wbGF0ZSAjY29udGVudD5cclxuICAgIDxhdmwtZGlhbG9nLWhlYWRlcj57eyB0cmFuc2xhdGlvbkJhc2UgKyAnRGV0YWlscycgfCB0cmFuc2xhdGUgfX08L2F2bC1kaWFsb2ctaGVhZGVyPlxyXG4gICAgPGF2bC1kaWFsb2ctY29udGVudD5cclxuICAgICAgPGRpdiBjbGFzcz1cIm1haW4tY29udGFpbmVyXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJsZS1oZWFkZXJcIj5cclxuICAgICAgICAgICAgPGgxPlxyXG4gICAgICAgICAgICAgIHt7IHRyYW5zbGF0aW9uQmFzZSArICdOb3RpZmljYXRpb25zJyB8IHRyYW5zbGF0ZSB9fSAoe3sgbm90aWZpY2F0aW9ucz8ubGVuZ3RoIH19XHJcbiAgICAgICAgICAgICAgPHNwYW5cclxuICAgICAgICAgICAgICAgICpuZ0lmPVwiXHJcbiAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbnNDb3VudC50b3RhbCAmJiBub3RpZmljYXRpb25zQ291bnQudG90YWwgIT09IG5vdGlmaWNhdGlvbnM/Lmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgXCJcclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAve3sgbm90aWZpY2F0aW9uc0NvdW50LnRvdGFsIH19IDwvc3BhblxyXG4gICAgICAgICAgICAgID4pXHJcbiAgICAgICAgICAgIDwvaDE+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJsZS1oZWFkZXItcmlnaHRcIj5cclxuICAgICAgICAgICAgICA8YXZsLWljb24tYnV0dG9uXHJcbiAgICAgICAgICAgICAgICBpZD1cInVwZGF0ZUljb25cIlxyXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cInJlZnJlc2hUYWJsZSgpXCJcclxuICAgICAgICAgICAgICAgIGNsYXNzPVwicG9pbnRlclwiXHJcbiAgICAgICAgICAgICAgICBpY29uPVwiaWNvbnM6cmVmcmVzaFwiXHJcbiAgICAgICAgICAgICAgICBbYmFkZ2VdPVwicmVmcmVzaEJhZGdlXCJcclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgPC9hdmwtaWNvbi1idXR0b24+XHJcbiAgICAgICAgICAgICAgPGF2bC10b29sdGlwIGZvcj1cInVwZGF0ZUljb25cIj5cclxuICAgICAgICAgICAgICAgIHt7IHRyYW5zbGF0aW9uQmFzZSArICdSZWZyZXNoJyB8IHRyYW5zbGF0ZSB9fTwvYXZsLXRvb2x0aXBcclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRpdmlkZXIgdmVydGljYWxcIj48L2Rpdj5cclxuICAgICAgICAgICAgICA8ZGl2ICpuZ0Zvcj1cImxldCBidXR0b24gb2YgYWN0aW9uQnV0dG9uc1wiPlxyXG4gICAgICAgICAgICAgICAgPGF2bC1pY29uLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICBpZD1cInt7IGJ1dHRvbi5pZCB9fUljb25cIlxyXG4gICAgICAgICAgICAgICAgICAoY2xpY2spPVwibWFya0FzKGJ1dHRvbi5pZClcIlxyXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cInBvaW50ZXJcIlxyXG4gICAgICAgICAgICAgICAgICBbaWNvbl09XCJnZXRJY29uQnlUeXBlKGJ1dHRvbi5pZClcIlxyXG4gICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZU1hcmtpbmdTZWxlY3RlZFwiXHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8L2F2bC1pY29uLWJ1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxhdmwtdG9vbHRpcCBmb3I9XCJ7eyBidXR0b24uaWQgfX1JY29uXCI+e3tcclxuICAgICAgICAgICAgICAgICAgYnV0dG9uLnRvb2x0aXAgfCB0cmFuc2xhdGVcclxuICAgICAgICAgICAgICAgIH19PC9hdmwtdG9vbHRpcD5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZGl2aWRlciB2ZXJ0aWNhbFwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgIDxkaXYgKm5nSWY9XCIhZmlsdGVyc09wZW5cIiBjbGFzcz1cInNlYXJjaC1iYXItaG9sZGVyXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2ICpuZ1RlbXBsYXRlT3V0bGV0PVwic2VhcmNoQmFyXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPGF2bC1pY29uLWJ1dHRvblxyXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZUZpbHRlcnMoKVwiXHJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInBvaW50ZXJcIlxyXG4gICAgICAgICAgICAgICAgaWNvbj1cImljb25zOmZpbHRlci1saXN0XCJcclxuICAgICAgICAgICAgICAgIFtiYWRnZV09XCJiYWRnZVwiXHJcbiAgICAgICAgICAgICAgPjwvYXZsLWljb24tYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPGF2bC1kYXRhdGFibGVcclxuICAgICAgICAgICAgI25vdGlmaWNhdGlvblRhYmxlXHJcbiAgICAgICAgICAgIGNsYXNzPVwiZmlsdGVyRGF0YXRhYmxlXCJcclxuICAgICAgICAgICAgbXVsdGktc2VsZWN0XHJcbiAgICAgICAgICAgIGFsbG93LWFjdGl2ZS1yb3dcclxuICAgICAgICAgICAgcGFnaW5hdGlvblxyXG4gICAgICAgICAgICBbY29sdW1uRGVmaW5pdGlvbnNdPVwiY29sdW1uRGVmaW5pdGlvbnNcIlxyXG4gICAgICAgICAgICBbcGFnZVNpemVdPVwicGFnZVNpemVcIlxyXG4gICAgICAgICAgICBbZGF0YV09XCJub3RpZmljYXRpb25zIHwgcHJlcGFyZU5vdGlmaWNhdGlvbnM6ICdkaWFsb2cnXCJcclxuICAgICAgICAgICAgW3BhZ2VTaXplT3B0aW9uc109XCJwYWdlU2l6ZU9wdGlvbnNcIlxyXG4gICAgICAgICAgICBbKHNlbGVjdGVkVmFsdWVzKV09XCJzZWxlY3RlZFJvd3NcIlxyXG4gICAgICAgICAgICAoc2VsZWN0ZWRWYWx1ZXNDaGFuZ2UpPVwic2VsZWN0ZWRWYWx1ZXNDaGFuZ2VkKClcIlxyXG4gICAgICAgICAgICAocGFnZS1zaXplLWNoYW5nZWQpPVwib25QYWdlU2l6ZUNoYW5nZWQoJGV2ZW50KVwiXHJcbiAgICAgICAgICAgIChzZWxlY3RlZC1wYWdlLWNoYW5nZWQpPVwib25TZWxlY3RlZFBhZ2VDaGFuZ2VkKCRldmVudClcIlxyXG4gICAgICAgICAgICAob24tcm93LWNsaWNrZWQpPVwib25Sb3dDbGlja2VkKCRldmVudClcIlxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgPC9hdmwtZGF0YXRhYmxlPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxhdmwtc2lkZS1zaGVldCBjbGFzcz1cImZpbHRlci1zaGVldFwiIGRpdmlkZXIgWyhvcGVuKV09XCJmaWx0ZXJzT3BlblwiICNmaWx0ZXJTaGVldD5cclxuICAgICAgICAgIDxkaXYgc2xvdD1cInRpdGxlXCI+XHJcbiAgICAgICAgICAgIDxoMj57eyB0cmFuc2xhdGlvbkJhc2UgKyAnRmlsdGVycycgfCB0cmFuc2xhdGUgfX08L2gyPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IHNsb3Q9XCJjb250ZW50XCI+XHJcbiAgICAgICAgICAgIDxmb3JtICNmaWx0ZXJGb3JtPVwibmdGb3JtXCI+XHJcbiAgICAgICAgICAgICAgPCEtLW5nSWYgaXMgbmVlZGVkIHRvIHJlcmVuZGVyIHRlbXBsYXRlIG9uIGZpbHRlcnNoZWV0IHRvZ2dsZS0tPlxyXG4gICAgICAgICAgICAgIDxkaXYgKm5nSWY9XCJmaWx0ZXJzT3BlblwiIGNsYXNzPVwic2VhcmNoLWJhci1ob2xkZXJcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgKm5nVGVtcGxhdGVPdXRsZXQ9XCJzZWFyY2hCYXJcIj48L2Rpdj5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgPGF2bC1saXN0LWV4cGFuZGVyXHJcbiAgICAgICAgICAgICAgICBbb3Blbl09XCJ0cnVlXCJcclxuICAgICAgICAgICAgICAgIFtuYXJyb3ddPVwidHJ1ZVwiXHJcbiAgICAgICAgICAgICAgICAjZmlsdGVyRm9ybVR5cGU9XCJuZ01vZGVsR3JvdXBcIlxyXG4gICAgICAgICAgICAgICAgbmdNb2RlbEdyb3VwPVwidHlwZVwiXHJcbiAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPGRpdiByb2xlPVwiaGVhZGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxoMz5cclxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57eyB0cmFuc2xhdGlvbkJhc2UgKyAnVHlwZScgfCB0cmFuc2xhdGUgfX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJhY3RpdmVGaWx0ZXJzPy50eXBlIHwgaXRlcmFibGVPYmplY3QgYXMgYWN0aXZlRmlsdGVyR3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SGVhZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUZpbHRlckdyb3VwOiBhY3RpdmVGaWx0ZXJHcm91cCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckdyb3VwOiBmaWx0ZXJzPy50eXBlIHwgaXRlcmFibGVPYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICA+PC9uZy1jb250YWluZXI+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICA8L2gzPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHJvbGU9XCJjb250ZW50XCIgY2xhc3M9XCJmaWx0ZXJDb250ZW50XCI+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgKm5nRm9yPVwibGV0IHR5cGUgb2YgZmlsdGVycz8udHlwZSB8IGl0ZXJhYmxlT2JqZWN0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGF2bC1jaGVja2JveCBuYW1lPVwie3sgdHlwZSB9fVwiIFsobmdNb2RlbCldPVwiZmlsdGVycy50eXBlW3R5cGVdXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICB7eyB0cmFuc2xhdGlvbkJhc2UgKyAodHlwZSB8IHRpdGxlY2FzZSkgfCB0cmFuc2xhdGUgfX1cclxuICAgICAgICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwibm90aWZpY2F0aW9ucy5sZW5ndGhcIj4oe3sgbm90aWZpY2F0aW9uc0NvdW50W3R5cGVdIH19KTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2F2bC1jaGVja2JveD5cclxuICAgICAgICAgICAgICAgICAgICA8YXZsLWljb25cclxuICAgICAgICAgICAgICAgICAgICAgIGlkPVwie3sgdHlwZSB9fUljb25cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ0eXBlSWNvbnNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImljb25zOnt7IGdldEljb25CeVR5cGUodHlwZSkgfX1cIlxyXG4gICAgICAgICAgICAgICAgICAgID48L2F2bC1pY29uPlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvYXZsLWxpc3QtZXhwYW5kZXI+XHJcbiAgICAgICAgICAgICAgPGF2bC1saXN0LWV4cGFuZGVyXHJcbiAgICAgICAgICAgICAgICBbb3Blbl09XCJ0cnVlXCJcclxuICAgICAgICAgICAgICAgIFtuYXJyb3ddPVwidHJ1ZVwiXHJcbiAgICAgICAgICAgICAgICAjZmlsdGVyRm9ybVN0YXRlPVwibmdNb2RlbEdyb3VwXCJcclxuICAgICAgICAgICAgICAgIG5nTW9kZWxHcm91cD1cInN0YXRlXCJcclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHJvbGU9XCJoZWFkZXJcIj5cclxuICAgICAgICAgICAgICAgICAgPGgzPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPnt7IHRyYW5zbGF0aW9uQmFzZSArICdTdGF0ZScgfCB0cmFuc2xhdGUgfX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJhY3RpdmVGaWx0ZXJzPy5zdGF0ZSB8IGl0ZXJhYmxlT2JqZWN0IGFzIGFjdGl2ZUZpbHRlckdyb3VwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEhlYWRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVGaWx0ZXJHcm91cDogYWN0aXZlRmlsdGVyR3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJHcm91cDogZmlsdGVycz8uc3RhdGUgfCBpdGVyYWJsZU9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcclxuICAgICAgICAgICAgICAgICAgICAgID48L25nLWNvbnRhaW5lcj5cclxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgIDwvaDM+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgcm9sZT1cImNvbnRlbnRcIiBjbGFzcz1cImZpbHRlckNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgICAgPGRpdiAqbmdGb3I9XCJsZXQgc3RhdGUgb2YgZmlsdGVycz8uc3RhdGUgfCBpdGVyYWJsZU9iamVjdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxhdmwtY2hlY2tib3ggbmFtZT1cInt7IHN0YXRlIH19XCIgWyhuZ01vZGVsKV09XCJmaWx0ZXJzLnN0YXRlW3N0YXRlXVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAge3sgdHJhbnNsYXRpb25CYXNlICsgKHN0YXRlIHwgdGl0bGVjYXNlKSB8IHRyYW5zbGF0ZSB9fSAoe3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uc0NvdW50W3N0YXRlXVxyXG4gICAgICAgICAgICAgICAgICAgICAgfX0pXHJcbiAgICAgICAgICAgICAgICAgICAgPC9hdmwtY2hlY2tib3g+XHJcbiAgICAgICAgICAgICAgICAgICAgPGF2bC1pY29uXHJcbiAgICAgICAgICAgICAgICAgICAgICBpZD1cInt7IHN0YXRlIH19SWNvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInR5cGVJY29uc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiaWNvbnM6e3sgZ2V0SWNvbkJ5VHlwZShzdGF0ZSkgfX1cIlxyXG4gICAgICAgICAgICAgICAgICAgID48L2F2bC1pY29uPlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvYXZsLWxpc3QtZXhwYW5kZXI+XHJcbiAgICAgICAgICAgICAgPGF2bC1saXN0LWV4cGFuZGVyXHJcbiAgICAgICAgICAgICAgICBbb3Blbl09XCJ0cnVlXCJcclxuICAgICAgICAgICAgICAgIFtuYXJyb3ddPVwidHJ1ZVwiXHJcbiAgICAgICAgICAgICAgICAjZmlsdGVyRm9ybURhdGU9XCJuZ01vZGVsR3JvdXBcIlxyXG4gICAgICAgICAgICAgICAgbmdNb2RlbEdyb3VwPVwiZGF0ZVwiXHJcbiAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPGRpdiByb2xlPVwiaGVhZGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxoMyBpZD1cImRhdGUtZ3JvdXBcIiAjZGF0ZUdyb3VwPlxyXG4gICAgICAgICAgICAgICAgICAgIHt7IGRhdGVGaWx0ZXJHcm91cEhlYWRlciB9fVxyXG4gICAgICAgICAgICAgICAgICA8L2gzPlxyXG4gICAgICAgICAgICAgICAgICA8YXZsLXRvb2x0aXBcclxuICAgICAgICAgICAgICAgICAgICBmb3I9XCJkYXRlLWdyb3VwXCJcclxuICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImRhdGVHcm91cC5zY3JvbGxXaWR0aCA+IGRhdGVHcm91cC5jbGllbnRXaWR0aFwiXHJcbiAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICB7eyBkYXRlRmlsdGVyR3JvdXBIZWFkZXIgfX1cclxuICAgICAgICAgICAgICAgICAgPC9hdmwtdG9vbHRpcD5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiByb2xlPVwiY29udGVudFwiPlxyXG4gICAgICAgICAgICAgICAgICA8YXZsLWRhdGVcclxuICAgICAgICAgICAgICAgICAgICAqbmdGb3I9XCJsZXQgZGF0ZSBvZiBmaWx0ZXJzPy5kYXRlIHwgaXRlcmFibGVPYmplY3RcIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZGF0ZS1jb250cm9sXCJcclxuICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cImZpbHRlcnMuZGF0ZVtkYXRlXVwiXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZT1cInt7IGRhdGUgfX1cIlxyXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJ1cGRhdGVMYWJlbHMoKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgW2xhYmVsXT1cInRyYW5zbGF0aW9uQmFzZSArIChkYXRlIHwgY2FwaXRhbGl6ZSkgfCB0cmFuc2xhdGVcIlxyXG4gICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZFJhbmdlc109XCJkaXNhYmxlZFJhbmdlW2RhdGVdXCJcclxuICAgICAgICAgICAgICAgICAgICAjZGF0ZUVsXHJcbiAgICAgICAgICAgICAgICAgICAgYXV0by12YWxpZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIFtkYXRlSW52YWxpZF09XCJkYXRlRWxcIlxyXG4gICAgICAgICAgICAgICAgICA+PC9hdmwtZGF0ZT5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvYXZsLWxpc3QtZXhwYW5kZXI+XHJcbiAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNzZWFyY2hCYXI+XHJcbiAgICAgICAgICAgICAgICA8YXZsLXNlYXJjaC1iYXJcclxuICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJ7eyB0cmFuc2xhdGlvbkJhc2UgKyAnU2VhcmNoJyB8IHRyYW5zbGF0ZSB9fVwiXHJcbiAgICAgICAgICAgICAgICAgIGFsd2F5cy1vcGVuXHJcbiAgICAgICAgICAgICAgICAgICNzZWFyY2hCYXJFbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgIG5hbWU9XCJzZWFyY2hcIlxyXG4gICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cImZpbHRlcnMuc2VhcmNoXCJcclxuICAgICAgICAgICAgICAgID48L2F2bC1zZWFyY2gtYmFyPlxyXG4gICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XHJcbiAgICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPGRpdiBzbG90PVwiYWN0aW9uc1wiPlxyXG4gICAgICAgICAgICA8YXZsLWJ1dHRvbiAoY2xpY2spPVwicmVzZXQoKVwiPnt7IHRyYW5zbGF0aW9uQmFzZSArICdSZXNldCcgfCB0cmFuc2xhdGUgfX08L2F2bC1idXR0b24+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2F2bC1zaWRlLXNoZWV0PlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvYXZsLWRpYWxvZy1jb250ZW50PlxyXG4gIDwvbmctdGVtcGxhdGU+XHJcblxyXG4gIDxuZy10ZW1wbGF0ZVxyXG4gICAgI2N1cnJlbnRIZWFkZXJcclxuICAgIGxldC1hY3RpdmVGaWx0ZXJHcm91cD1cImFjdGl2ZUZpbHRlckdyb3VwXCJcclxuICAgIGxldC1maWx0ZXJHcm91cD1cImZpbHRlckdyb3VwXCJcclxuICA+XHJcbiAgICA8c3Bhbj46IDwvc3Bhbj48c3BhbiAqbmdJZj1cImFjdGl2ZUZpbHRlckdyb3VwLmxlbmd0aCA9PT0gZmlsdGVyR3JvdXAubGVuZ3RoXCI+YWxsPC9zcGFuPlxyXG4gICAgPHNwYW4gKm5nSWY9XCJhY3RpdmVGaWx0ZXJHcm91cC5sZW5ndGggIT09IGZpbHRlckdyb3VwLmxlbmd0aFwiPlxyXG4gICAgICA8c3BhbiAqbmdGb3I9XCJsZXQgaXRlbSBvZiBhY3RpdmVGaWx0ZXJHcm91cDsgaW5kZXggYXMgaVwiPlxyXG4gICAgICAgIDxzcGFuPnt7IHRyYW5zbGF0aW9uQmFzZSArIChpdGVtIHwgdGl0bGVjYXNlKSB8IHRyYW5zbGF0ZSB9fTwvc3Bhbj5cclxuICAgICAgICA8c3BhbiAqbmdJZj1cImkgPCBhY3RpdmVGaWx0ZXJHcm91cC5sZW5ndGggLSAxXCI+LCA8L3NwYW4+XHJcbiAgICAgIDwvc3Bhbj5cclxuICAgIDwvc3Bhbj5cclxuICA8L25nLXRlbXBsYXRlPlxyXG48L2F2bC1kaWFsb2c+XHJcbiJdfQ==