import { Directive, HostBinding, Input } from '@angular/core';
import { animate, style } from '@angular/animations';
import { ANIMATION_DURATION, MARGIN } from '../avl-notification-container.consts';
import * as i0 from "@angular/core";
import * as i1 from "@angular/animations";
/** @hidden */
export class AnimateSnackbar {
    constructor(builder, el) {
        this.builder = builder;
        /** @hidden */
        this.defaultClass = true;
        this.getAnimation = (animationName, initialStyle) => {
            const elementWidth = this.element.nativeElement.offsetWidth - 3 * MARGIN;
            const inStackStyle = style({
                marginTop: MARGIN + 'px',
                marginLeft: MARGIN + 'px',
                marginRight: MARGIN + 'px',
                width: elementWidth + 'px'
            });
            switch (animationName) {
                case 4 /* FromStack */:
                    return [animate(ANIMATION_DURATION + 'ms ease-in', inStackStyle), initialStyle];
                case 3 /* ToStack */: {
                    return [initialStyle, animate(ANIMATION_DURATION + 'ms ease-in', inStackStyle)];
                }
                default:
                    return [initialStyle, animate('1ms ease-in', initialStyle)];
            }
        };
        this.element = el;
    }
    ngOnChanges(changes) {
        if (changes.animateSnackbar) {
            const isInStack = changes.animateSnackbar.currentValue === 3 /* ToStack */;
            if (isInStack) {
                this.move();
            }
            else if (changes.animateSnackbar.previousValue === 3 /* ToStack */) {
                this.move();
            }
        }
    }
    show(metadata) {
        if (this.player) {
            this.player.destroy();
        }
        if (metadata) {
            const factory = this.builder.build(metadata);
            const player = factory.create(this.element.nativeElement);
            player.play();
        }
    }
    move() {
        const animationMetadata = this.animate();
        this.show(animationMetadata);
    }
    animate() {
        const initialStyle = style({
            marginTop: '0',
            width: '100%',
            marginLeft: '0',
            marginRight: '0'
        });
        return this.getAnimation(this.animateSnackbar, initialStyle);
    }
}
AnimateSnackbar.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AnimateSnackbar, deps: [{ token: i1.AnimationBuilder }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AnimateSnackbar.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.3", type: AnimateSnackbar, selector: "[animateSnackbar]", inputs: { animateSnackbar: "animateSnackbar", positionAnimation: "positionAnimation", notification: "notification", reopen: "reopen" }, host: { properties: { "class.in-stack": "this.inStack", "class.no-animation": "this.noAnimation", "class.snackbar-container": "this.defaultClass" } }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AnimateSnackbar, decorators: [{
            type: Directive,
            args: [{ selector: '[animateSnackbar]' }]
        }], ctorParameters: function () { return [{ type: i1.AnimationBuilder }, { type: i0.ElementRef }]; }, propDecorators: { animateSnackbar: [{
                type: Input
            }], positionAnimation: [{
                type: Input
            }], notification: [{
                type: Input,
                args: ['notification']
            }], reopen: [{
                type: Input,
                args: ['reopen']
            }], inStack: [{
                type: HostBinding,
                args: ['class.in-stack']
            }], noAnimation: [{
                type: HostBinding,
                args: ['class.no-animation']
            }], defaultClass: [{
                type: HostBinding,
                args: ['class.snackbar-container']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5pbWF0ZS1zbmFja2Jhci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9ub3RpZmljYXRpb24vc3JjL2xpYi9jb21wb25lbnRzL2F2bC1ub3RpZmljYXRpb24tY29udGFpbmVyL2RpcmVjdGl2ZXMvYW5pbWF0ZS1zbmFja2Jhci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBYyxXQUFXLEVBQUUsS0FBSyxFQUE0QixNQUFNLGVBQWUsQ0FBQztBQUNwRyxPQUFPLEVBQ0wsT0FBTyxFQUtQLEtBQUssRUFDTixNQUFNLHFCQUFxQixDQUFDO0FBRzdCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQzs7O0FBQ2xGLGNBQWM7QUFHZCxNQUFNLE9BQU8sZUFBZTtJQXlCMUIsWUFBcUIsT0FBeUIsRUFBRSxFQUFjO1FBQXpDLFlBQU8sR0FBUCxPQUFPLENBQWtCO1FBTjlDLGNBQWM7UUFDMkIsaUJBQVksR0FBRyxJQUFJLENBQUM7UUE0Q3JELGlCQUFZLEdBQUcsQ0FDckIsYUFBZ0MsRUFDaEMsWUFBb0MsRUFDZixFQUFFO1lBQ3ZCLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLFdBQVcsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDO1lBQ3pFLE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQztnQkFDekIsU0FBUyxFQUFFLE1BQU0sR0FBRyxJQUFJO2dCQUN4QixVQUFVLEVBQUUsTUFBTSxHQUFHLElBQUk7Z0JBQ3pCLFdBQVcsRUFBRSxNQUFNLEdBQUcsSUFBSTtnQkFDMUIsS0FBSyxFQUFFLFlBQVksR0FBRyxJQUFJO2FBQzNCLENBQUMsQ0FBQztZQUNILFFBQVEsYUFBYSxFQUFFO2dCQUNyQjtvQkFDRSxPQUFPLENBQUMsT0FBTyxDQUFDLGtCQUFrQixHQUFHLFlBQVksRUFBRSxZQUFZLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQztnQkFFbEYsb0JBQThCLENBQUMsQ0FBQztvQkFDOUIsT0FBTyxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsa0JBQWtCLEdBQUcsWUFBWSxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUM7aUJBQ2pGO2dCQUNEO29CQUNFLE9BQU8sQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLGFBQWEsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO2FBQy9EO1FBQ0gsQ0FBQyxDQUFDO1FBM0RBLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDaEMsSUFBSSxPQUFPLENBQUMsZUFBZSxFQUFFO1lBQzNCLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsWUFBWSxvQkFBOEIsQ0FBQztZQUNyRixJQUFJLFNBQVMsRUFBRTtnQkFDYixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDYjtpQkFBTSxJQUFJLE9BQU8sQ0FBQyxlQUFlLENBQUMsYUFBYSxvQkFBOEIsRUFBRTtnQkFDOUUsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO2FBQ2I7U0FDRjtJQUNILENBQUM7SUFFTyxJQUFJLENBQUMsUUFBNkI7UUFDeEMsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUN2QjtRQUNELElBQUksUUFBUSxFQUFFO1lBQ1osTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDN0MsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQzFELE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUNmO0lBQ0gsQ0FBQztJQUNPLElBQUk7UUFDVixNQUFNLGlCQUFpQixHQUF3QixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDOUQsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFDTyxPQUFPO1FBQ2IsTUFBTSxZQUFZLEdBQUcsS0FBSyxDQUFDO1lBQ3pCLFNBQVMsRUFBRSxHQUFHO1lBQ2QsS0FBSyxFQUFFLE1BQU07WUFDYixVQUFVLEVBQUUsR0FBRztZQUNmLFdBQVcsRUFBRSxHQUFHO1NBQ2pCLENBQUMsQ0FBQztRQUNILE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQy9ELENBQUM7OzRHQTlEVSxlQUFlO2dHQUFmLGVBQWU7MkZBQWYsZUFBZTtrQkFEM0IsU0FBUzttQkFBQyxFQUFFLFFBQVEsRUFBRSxtQkFBbUIsRUFBRTtnSUFHeEIsZUFBZTtzQkFBaEMsS0FBSztnQkFHWSxpQkFBaUI7c0JBQWxDLEtBQUs7Z0JBRzBCLFlBQVk7c0JBQTNDLEtBQUs7dUJBQUMsY0FBYztnQkFHSyxNQUFNO3NCQUEvQixLQUFLO3VCQUFDLFFBQVE7Z0JBR2dCLE9BQU87c0JBQXJDLFdBQVc7dUJBQUMsZ0JBQWdCO2dCQUdNLFdBQVc7c0JBQTdDLFdBQVc7dUJBQUMsb0JBQW9CO2dCQUdRLFlBQVk7c0JBQXBELFdBQVc7dUJBQUMsMEJBQTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgSW5wdXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge1xyXG4gIGFuaW1hdGUsXHJcbiAgQW5pbWF0aW9uQnVpbGRlcixcclxuICBBbmltYXRpb25NZXRhZGF0YSxcclxuICBBbmltYXRpb25QbGF5ZXIsXHJcbiAgQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSxcclxuICBzdHlsZVxyXG59IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xyXG5pbXBvcnQgeyBBdmxOb3RpZmljYXRpb24gfSBmcm9tICdAYXZsLWludGVyZmFjZXMvaW50ZXJmYWNlcyc7XHJcbmltcG9ydCB7IFBvc2l0aW9uQW5pbWF0aW9uIH0gZnJvbSAnLi9hbmltYXRlLXN0YWNrLmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IEFOSU1BVElPTl9EVVJBVElPTiwgTUFSR0lOIH0gZnJvbSAnLi4vYXZsLW5vdGlmaWNhdGlvbi1jb250YWluZXIuY29uc3RzJztcclxuLyoqIEBoaWRkZW4gKi9cclxuXHJcbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1thbmltYXRlU25hY2tiYXJdJyB9KVxyXG5leHBvcnQgY2xhc3MgQW5pbWF0ZVNuYWNrYmFyIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcclxuICAvKiogQGhpZGRlbiAqL1xyXG4gIEBJbnB1dCgpIHJlYWRvbmx5IGFuaW1hdGVTbmFja2JhcjogUG9zaXRpb25BbmltYXRpb247XHJcblxyXG4gIC8qKiBAaGlkZGVuICovXHJcbiAgQElucHV0KCkgcmVhZG9ubHkgcG9zaXRpb25BbmltYXRpb246IFBvc2l0aW9uQW5pbWF0aW9uO1xyXG5cclxuICAvKiogQGhpZGRlbiAqL1xyXG4gIEBJbnB1dCgnbm90aWZpY2F0aW9uJykgcmVhZG9ubHkgbm90aWZpY2F0aW9uOiBBdmxOb3RpZmljYXRpb247XHJcblxyXG4gIC8qKiBAaGlkZGVuICovXHJcbiAgQElucHV0KCdyZW9wZW4nKSByZWFkb25seSByZW9wZW46IGJvb2xlYW47XHJcblxyXG4gIC8qKiBAaGlkZGVuICovXHJcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pbi1zdGFjaycpIGluU3RhY2s6IGJvb2xlYW47XHJcblxyXG4gIC8qKiBAaGlkZGVuICovXHJcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5uby1hbmltYXRpb24nKSBub0FuaW1hdGlvbjogYm9vbGVhbjtcclxuXHJcbiAgLyoqIEBoaWRkZW4gKi9cclxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnNuYWNrYmFyLWNvbnRhaW5lcicpIGRlZmF1bHRDbGFzcyA9IHRydWU7XHJcblxyXG4gIHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZjtcclxuICBwcml2YXRlIHBsYXllcjogQW5pbWF0aW9uUGxheWVyO1xyXG5cclxuICBjb25zdHJ1Y3RvcihyZWFkb25seSBidWlsZGVyOiBBbmltYXRpb25CdWlsZGVyLCBlbDogRWxlbWVudFJlZikge1xyXG4gICAgdGhpcy5lbGVtZW50ID0gZWw7XHJcbiAgfVxyXG5cclxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICBpZiAoY2hhbmdlcy5hbmltYXRlU25hY2tiYXIpIHtcclxuICAgICAgY29uc3QgaXNJblN0YWNrID0gY2hhbmdlcy5hbmltYXRlU25hY2tiYXIuY3VycmVudFZhbHVlID09PSBQb3NpdGlvbkFuaW1hdGlvbi5Ub1N0YWNrO1xyXG4gICAgICBpZiAoaXNJblN0YWNrKSB7XHJcbiAgICAgICAgdGhpcy5tb3ZlKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2hhbmdlcy5hbmltYXRlU25hY2tiYXIucHJldmlvdXNWYWx1ZSA9PT0gUG9zaXRpb25BbmltYXRpb24uVG9TdGFjaykge1xyXG4gICAgICAgIHRoaXMubW92ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNob3cobWV0YWRhdGE6IEFuaW1hdGlvbk1ldGFkYXRhW10pIHtcclxuICAgIGlmICh0aGlzLnBsYXllcikge1xyXG4gICAgICB0aGlzLnBsYXllci5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgICBpZiAobWV0YWRhdGEpIHtcclxuICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuYnVpbGRlci5idWlsZChtZXRhZGF0YSk7XHJcbiAgICAgIGNvbnN0IHBsYXllciA9IGZhY3RvcnkuY3JlYXRlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcclxuICAgICAgcGxheWVyLnBsYXkoKTtcclxuICAgIH1cclxuICB9XHJcbiAgcHJpdmF0ZSBtb3ZlKCkge1xyXG4gICAgY29uc3QgYW5pbWF0aW9uTWV0YWRhdGE6IEFuaW1hdGlvbk1ldGFkYXRhW10gPSB0aGlzLmFuaW1hdGUoKTtcclxuICAgIHRoaXMuc2hvdyhhbmltYXRpb25NZXRhZGF0YSk7XHJcbiAgfVxyXG4gIHByaXZhdGUgYW5pbWF0ZSgpOiBBbmltYXRpb25NZXRhZGF0YVtdIHtcclxuICAgIGNvbnN0IGluaXRpYWxTdHlsZSA9IHN0eWxlKHtcclxuICAgICAgbWFyZ2luVG9wOiAnMCcsXHJcbiAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgIG1hcmdpbkxlZnQ6ICcwJyxcclxuICAgICAgbWFyZ2luUmlnaHQ6ICcwJ1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRBbmltYXRpb24odGhpcy5hbmltYXRlU25hY2tiYXIsIGluaXRpYWxTdHlsZSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldEFuaW1hdGlvbiA9IChcclxuICAgIGFuaW1hdGlvbk5hbWU6IFBvc2l0aW9uQW5pbWF0aW9uLFxyXG4gICAgaW5pdGlhbFN0eWxlOiBBbmltYXRpb25TdHlsZU1ldGFkYXRhXHJcbiAgKTogQW5pbWF0aW9uTWV0YWRhdGFbXSA9PiB7XHJcbiAgICBjb25zdCBlbGVtZW50V2lkdGggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCAtIDMgKiBNQVJHSU47XHJcbiAgICBjb25zdCBpblN0YWNrU3R5bGUgPSBzdHlsZSh7XHJcbiAgICAgIG1hcmdpblRvcDogTUFSR0lOICsgJ3B4JyxcclxuICAgICAgbWFyZ2luTGVmdDogTUFSR0lOICsgJ3B4JyxcclxuICAgICAgbWFyZ2luUmlnaHQ6IE1BUkdJTiArICdweCcsXHJcbiAgICAgIHdpZHRoOiBlbGVtZW50V2lkdGggKyAncHgnXHJcbiAgICB9KTtcclxuICAgIHN3aXRjaCAoYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgICBjYXNlIFBvc2l0aW9uQW5pbWF0aW9uLkZyb21TdGFjazpcclxuICAgICAgICByZXR1cm4gW2FuaW1hdGUoQU5JTUFUSU9OX0RVUkFUSU9OICsgJ21zIGVhc2UtaW4nLCBpblN0YWNrU3R5bGUpLCBpbml0aWFsU3R5bGVdO1xyXG5cclxuICAgICAgY2FzZSBQb3NpdGlvbkFuaW1hdGlvbi5Ub1N0YWNrOiB7XHJcbiAgICAgICAgcmV0dXJuIFtpbml0aWFsU3R5bGUsIGFuaW1hdGUoQU5JTUFUSU9OX0RVUkFUSU9OICsgJ21zIGVhc2UtaW4nLCBpblN0YWNrU3R5bGUpXTtcclxuICAgICAgfVxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBbaW5pdGlhbFN0eWxlLCBhbmltYXRlKCcxbXMgZWFzZS1pbicsIGluaXRpYWxTdHlsZSldO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuIl19