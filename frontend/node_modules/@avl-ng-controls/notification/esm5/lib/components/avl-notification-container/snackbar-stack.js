var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import { BehaviorSubject } from 'rxjs';
import { skipWhile } from 'rxjs/operators';
import { ANIMATION_DURATION, ACTION_BUTTON_MESSAGE } from './avl-notification-container.consts';
import { SnackbarMethodDescription } from './directives/show-hide-snackbar.directive';
/** @hidden */
var SnackbarStack = /** @class */ (function () {
    function SnackbarStack(stackType) {
        var _this = this;
        /** @hidden */
        this.notificationList = [];
        /** @hidden */
        this.activeNotification$ = new BehaviorSubject(undefined);
        /** @hidden */
        this.stackIndicator = false;
        /** @hidden */
        this.actionButtonMessage = ACTION_BUTTON_MESSAGE;
        this.openNextNotification = function (stackType) {
            _this.methodDescription = new SnackbarMethodDescription('show', !_this.reopen);
            if (!_this.reopen) {
                _this.stackAnimation = 1 /* ToTop */;
            }
            else {
                _this.stackAnimation = 4 /* FromStack */;
            }
            _this.setStackIndicatorProperties(stackType);
            _this.reopen = false;
            _this.dismissedSilently = false;
        };
        this.resetValues = function () {
            _this.notificationList = [];
            _this.previousNotification = undefined;
            _this.stackIndicator = undefined;
        };
        this.setStackIndicatorProperties = function (stackType) {
            var notificationsCount = _this.notificationList.length;
            _this.stackIndicator = notificationsCount > 1;
            var timeout = setTimeout(function () {
                _this.previousNotification = _this.notificationList[notificationsCount - 1];
                _this.buttonLabel = _this.setButtonLabel(notificationsCount, stackType);
                _this.stackIndicatorButtonLabel = _this.setButtonLabel(notificationsCount - 1, stackType);
                clearTimeout(timeout);
            }, _this.previousNotification ? ANIMATION_DURATION : 0);
        };
        this.setButtonLabel = function (notificationsCount, type) {
            return notificationsCount > 0
                ? _this.actionButtonMessage
                    .replace('_TYPE ', type === 'info' ? '' : type + ' ')
                    .replace('_X', String(notificationsCount))
                : null;
        };
        this.translateLabels();
        this.methodDescription = new SnackbarMethodDescription(undefined, undefined);
        this.activeNotification$
            .pipe(skipWhile(function (notification) { return notification === undefined; }))
            .subscribe(function (notification) {
            if (notification) {
                if (_this.notificationList.length > 0) {
                    var timeout_1 = setTimeout(function () {
                        _this.openNextNotification(stackType);
                        clearTimeout(timeout_1);
                    }, _this.previousNotification ? ANIMATION_DURATION : 0);
                }
                else {
                    _this.openNextNotification(stackType);
                }
            }
            else {
                _this.resetValues();
            }
        });
    }
    SnackbarStack.prototype.translateLabels = function () {
        return __awaiter(this, void 0, void 0, function () {
            var translationService, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!AvlLocalizationService || !AvlLocalizationService.translationService) {
                            return [2 /*return*/];
                        }
                        translationService = AvlLocalizationService.translationService;
                        _a = this;
                        return [4 /*yield*/, translationService.translate('VizBox.NotificationContainer._X_more_TYPE_notifications')];
                    case 1:
                        _a.actionButtonMessage = _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return SnackbarStack;
}());
export { SnackbarStack };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic25hY2tiYXItc3RhY2suanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYXZsLW5nLWNvbnRyb2xzL25vdGlmaWNhdGlvbi8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL2F2bC1ub3RpZmljYXRpb24tY29udGFpbmVyL3NuYWNrYmFyLXN0YWNrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdkMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQ2hHLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLDJDQUEyQyxDQUFDO0FBRXRGLGNBQWM7QUFDZDtJQXFDRSx1QkFBWSxTQUFpQjtRQUE3QixpQkFzQkM7UUF2REQsY0FBYztRQUNQLHFCQUFnQixHQUFzQixFQUFFLENBQUM7UUFFaEQsY0FBYztRQUNQLHdCQUFtQixHQUFxQyxJQUFJLGVBQWUsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQVE5RixjQUFjO1FBQ1AsbUJBQWMsR0FBRyxLQUFLLENBQUM7UUFpQjlCLGNBQWM7UUFDUCx3QkFBbUIsR0FBRyxxQkFBcUIsQ0FBQztRQW1DM0MseUJBQW9CLEdBQUcsVUFBQyxTQUFTO1lBQ3ZDLEtBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLHlCQUF5QixDQUFDLE1BQU0sRUFBRSxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM3RSxJQUFJLENBQUMsS0FBSSxDQUFDLE1BQU0sRUFBRTtnQkFDaEIsS0FBSSxDQUFDLGNBQWMsZ0JBQTBCLENBQUM7YUFDL0M7aUJBQU07Z0JBQ0wsS0FBSSxDQUFDLGNBQWMsb0JBQThCLENBQUM7YUFDbkQ7WUFDRCxLQUFJLENBQUMsMkJBQTJCLENBQUMsU0FBUyxD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QkFBTzt5QkFDUjt3QkFFSyxrQkFBa0IsR0FBRyxzQkFBc0IsQ0FBQyxrQkFBa0IsQ0FBQzt3QkFDckUsS0FBQSxJQUFJLENBQUE7d0JBQXVCLHFCQUFNLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyx5REFBeUQsQ0FBQyxFQUFBOzt3QkFBeEgsR0FBSyxtQkFBbUIsR0FBRyxTQUE2RixDQUFDOzs7OztLQUMxSDtJQXVDSCxvQkFBQztBQUFELENBQUMsQUEzR0QsSUEyR0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBdmxOb3RpZmljYXRpb24gfSBmcm9tICdAYXZsLWNvbnRyb2xzL2ludGVyZmFjZXMnO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgc2tpcFdoaWxlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBQb3NpdGlvbkFuaW1hdGlvbiB9IGZyb20gJy4vZGlyZWN0aXZlcy9hbmltYXRlLXN0YWNrLmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IEFOSU1BVElPTl9EVVJBVElPTiwgQUNUSU9OX0JVVFRPTl9NRVNTQUdFIH0gZnJvbSAnLi9hdmwtbm90aWZpY2F0aW9uLWNvbnRhaW5lci5jb25zdHMnO1xyXG5pbXBvcnQgeyBTbmFja2Jhck1ldGhvZERlc2NyaXB0aW9uIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3Nob3ctaGlkZS1zbmFja2Jhci5kaXJlY3RpdmUnO1xyXG5cclxuLyoqIEBoaWRkZW4gKi9cclxuZXhwb3J0IGNsYXNzIFNuYWNrYmFyU3RhY2sge1xyXG4gIC8qKiBAaGlkZGVuICovXHJcbiAgcHVibGljIGJ1dHRvbkxhYmVsOiBzdHJpbmc7XHJcblxyXG4gIC8qKiBAaGlkZGVuICovXHJcbiAgcHVibGljIG5vdGlmaWNhdGlvbkxpc3Q6IEF2bE5vdGlmaWNhdGlvbltdID0gW107XHJcblxyXG4gIC8qKiBAaGlkZGVuICovXHJcbiAgcHVibGljIGFjdGl2ZU5vdGlmaWNhdGlvbiQ6IEJlaGF2aW9yU3ViamVjdDxBdmxOb3RpZmljYXRpb24+ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xyXG5cclxuICAvKiogQGhpZGRlbiAqL1xyXG4gIHB1YmxpYyBzdGFja0FuaW1hdGlvbjogUG9zaXRpb25BbmltYXRpb247XHJcblxyXG4gIC8qKiBAaGlkZGVuICovXHJcbiAgcHVibGljIHNuYWNrYmFyQW5pbWF0aW9uOiBQb3NpdGlvbkFuaW1hdGlvbjtcclxuXHJcbiAgLyoqIEBoaWRkZW4gKi9cclxuICBwdWJsaWMgc3RhY2tJbmRpY2F0b3IgPSBmYWxzZTtcclxuXHJcbiAgLyoqIEBoaWRkZW4gKi9cclxuICBwdWJsaWMgc3RhY2tJbmRpY2F0b3JCdXR0b25MYWJlbDogc3RyaW5nO1xyXG5cclxuICAvKiogQGhpZGRlbiAqL1xyXG4gIHB1YmxpYyBwcmV2aW91c05vdGlmaWNhdGlvbjogQXZsTm90aWZpY2F0aW9uO1xyXG5cclxuICAvKiogQGhpZGRlbiAqL1xyXG4gIHB1YmxpYyBtZXRob2REZXNjcmlwdGlvbjogU25hY2tiYXJNZXRob2REZXNjcmlwdGlvbjtcclxuICBcclxuICAvKiogQGhpZGRlbiAqL1xyXG4gIHB1YmxpYyByZW9wZW46IGJvb2xlYW47XHJcbiAgXHJcbiAgLyoqIEBoaWRkZW4gKi9cclxuICBwdWJsaWMgZGlzbWlzc2VkU2lsZW50bHk6IGJvb2xlYW47XHJcblxyXG4gIC8qKiBAaGlkZGVuICovXHJcbiAgcHVibGljIGFjdGlvbkJ1dHRvbk1lc3NhZ2UgPSBBQ1RJT05fQlVUVE9OX01FU1NBR0U7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHN0YWNrVHlwZTogc3RyaW5nKSB7XHJcbiAgICB0aGlzLnRyYW5zbGF0ZUxhYmVscygpO1xyXG4gICAgdGhpcy5tZXRob2REZXNjcmlwdGlvbiA9IG5ldyBTbmFja2Jhck1ldGhvZERlc2NyaXB0aW9uKHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxyXG4gICAgdGhpcy5hY3RpdmVOb3RpZmljYXRpb24kXHJcbiAgICAgIC5waXBlKHNraXBXaGlsZShub3RpZmljYXRpb24gPT4gbm90aWZpY2F0aW9uID09PSB1bmRlZmluZWQpKVxyXG4gICAgICAuc3Vic2NyaWJlKChub3RpZmljYXRpb246IEF2bE5vdGlmaWNhdGlvbikgPT4ge1xyXG4gICAgICAgIGlmIChub3RpZmljYXRpb24pIHtcclxuICAgICAgICAgIGlmICh0aGlzLm5vdGlmaWNhdGlvbkxpc3QubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChcclxuICAgICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5OZXh0Tm90aWZpY2F0aW9uKHN0YWNrVHlwZSk7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzTm90aWZpY2F0aW9uID8gQU5JTUFUSU9OX0RVUkFUSU9OIDogMFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVuTmV4dE5vdGlmaWNhdGlvbihzdGFja1R5cGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnJlc2V0VmFsdWVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgdHJhbnNsYXRlTGFiZWxzKCkge1xyXG4gICAgaWYgKCFBdmxMb2NhbGl6YXRpb25TZXJ2aWNlIHx8ICFBdmxMb2NhbGl6YXRpb25TZXJ2aWNlLnRyYW5zbGF0aW9uU2VydmljZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdHJhbnNsYXRpb25TZXJ2aWNlID0gQXZsTG9jYWxpemF0aW9uU2VydmljZS50cmFuc2xhdGlvblNlcnZpY2U7XHJcbiAgICB0aGlzLmFjdGlvbkJ1dHRvbk1lc3NhZ2UgPSBhd2FpdCB0cmFuc2xhdGlvblNlcnZpY2UudHJhbnNsYXRlKCdWaXpCb3guTm90aWZpY2F0aW9uQ29udGFpbmVyLl9YX21vcmVfVFlQRV9ub3RpZmljYXRpb25zJyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG9wZW5OZXh0Tm90aWZpY2F0aW9uID0gKHN0YWNrVHlwZSk6IHZvaWQgPT4ge1xyXG4gICAgdGhpcy5tZXRob2REZXNjcmlwdGlvbiA9IG5ldyBTbmFja2Jhck1ldGhvZERlc2NyaXB0aW9uKCdzaG93JywgIXRoaXMucmVvcGVuKTtcclxuICAgIGlmICghdGhpcy5yZW9wZW4pIHtcclxuICAgICAgdGhpcy5zdGFja0FuaW1hdGlvbiA9IFBvc2l0aW9uQW5pbWF0aW9uLlRvVG9wO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zdGFja0FuaW1hdGlvbiA9IFBvc2l0aW9uQW5pbWF0aW9uLkZyb21TdGFjaztcclxuICAgIH1cclxuICAgIHRoaXMuc2V0U3RhY2tJbmRpY2F0b3JQcm9wZXJ0aWVzKHN0YWNrVHlwZSk7XHJcbiAgICB0aGlzLnJlb3BlbiA9IGZhbHNlO1xyXG4gICAgdGhpcy5kaXNtaXNzZWRTaWxlbnRseSA9IGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIHByaXZhdGUgcmVzZXRWYWx1ZXMgPSAoKSA9PiB7XHJcbiAgICB0aGlzLm5vdGlmaWNhdGlvbkxpc3QgPSBbXTtcclxuICAgIHRoaXMucHJldmlvdXNOb3RpZmljYXRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnN0YWNrSW5kaWNhdG9yID0gdW5kZWZpbmVkO1xyXG4gIH07XHJcbiAgcHJpdmF0ZSBzZXRTdGFja0luZGljYXRvclByb3BlcnRpZXMgPSAoc3RhY2tUeXBlOiBzdHJpbmcpOiB2b2lkID0+IHtcclxuICAgIGNvbnN0IG5vdGlmaWNhdGlvbnNDb3VudCA9IHRoaXMubm90aWZpY2F0aW9uTGlzdC5sZW5ndGg7XHJcbiAgICB0aGlzLnN0YWNrSW5kaWNhdG9yID0gbm90aWZpY2F0aW9uc0NvdW50ID4gMTtcclxuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KFxyXG4gICAgICAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c05vdGlmaWNhdGlvbiA9IHRoaXMubm90aWZpY2F0aW9uTGlzdFtub3RpZmljYXRpb25zQ291bnQtMV07XHJcbiAgICAgICAgdGhpcy5idXR0b25MYWJlbCA9IHRoaXMuc2V0QnV0dG9uTGFiZWwobm90aWZpY2F0aW9uc0NvdW50LCBzdGFja1R5cGUpO1xyXG4gICAgICAgIHRoaXMuc3RhY2tJbmRpY2F0b3JCdXR0b25MYWJlbCA9IHRoaXMuc2V0QnV0dG9uTGFiZWwobm90aWZpY2F0aW9uc0NvdW50IC0gMSwgc3RhY2tUeXBlKTtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHRoaXMucHJldmlvdXNOb3RpZmljYXRpb24gPyBBTklNQVRJT05fRFVSQVRJT04gOiAwXHJcbiAgICApO1xyXG4gIH07XHJcbiAgcHJpdmF0ZSBzZXRCdXR0b25MYWJlbCA9IChub3RpZmljYXRpb25zQ291bnQ6IG51bWJlciwgdHlwZTogc3RyaW5nKTogc3RyaW5nID0+IHtcclxuICAgIHJldHVybiBub3RpZmljYXRpb25zQ291bnQgPiAwXHJcbiAgICAgID8gdGhpcy5hY3Rpb25CdXR0b25NZXNzYWdlXHJcbiAgICAgICAgLnJlcGxhY2UoJ19UWVBFICcsIHR5cGUgPT09ICdpbmZvJyA/ICcnIDogdHlwZSArICcgJylcclxuICAgICAgICAucmVwbGFjZSgnX1gnLCBTdHJpbmcobm90aWZpY2F0aW9uc0NvdW50KSlcclxuICAgICAgOiBudWxsO1xyXG4gIH07XHJcbn1cclxuIl19