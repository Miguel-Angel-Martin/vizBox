import { EventEmitter, Input, HostBinding, Output, Component, ViewEncapsulation, ElementRef, ContentChild, Directive, Renderer2, Inject, PLATFORM_ID, ContentChildren, QueryList, ChangeDetectorRef, ViewChildren, ViewChild, HostListener, NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import { ActivationEnd, Router, ActivatedRoute, NavigationEnd, RouterModule } from '@angular/router';
import '@avl-controls/core/dist/avl-app-switcher/avl-app-switcher';
import '@avl-controls/core/dist/avl-icon/avl-icon.js';
import { trigger, transition, style, animate } from '@angular/animations';
import { filter, throttleTime, map } from 'rxjs/operators';
import '@avl-controls/core/dist/avl-icon/avl-icon';
import { BehaviorSubject, asyncScheduler } from 'rxjs';
import '@avl-controls/core/dist/avl-search-bar/avl-search-bar';
import { AvlNgBindersModule } from '@avl-controls/ng-binders';

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
class MenuButtonItems {
    constructor(headerText, headerIconName, items, footerItems) {
        this.headerText = headerText;
        this.headerIconName = headerIconName;
        this.items = items;
        this.footerItems = footerItems;
    }
}
/**
 * Object representing sub-application that is added to app-bar drop-down
 */
class ApplicationReference {
}
let AvlAppBarComponent = class AvlAppBarComponent {
    constructor() {
        /**
         * List of sub-applications used
         */
        this.applications = [];
        /**
         * Event emitted when new application is added.
         */
        this.applicationListChange = new EventEmitter();
        /**
         * Flag indicating app-bar has fixed positioning or no
         */
        this.fixed = true;
        /**
         * Event emitted when application is changed in app-bar drop-down
         */
        this.currentApplicationChange = new EventEmitter();
        /**
         * Event emmited when Burger menu is clicked.
         * Toggles side-nav visibility if app-bar is part of app-layout in responsive mode
         */
        this.burgerClicked = new EventEmitter();
        /** @hidden */
        this.appLogoSet = false;
        this.appLogoPreset = false;
    }
    /**
     * True if only one element added to applications array
     */
    get isSingleApp() {
        return !this.applications || this._appsLength < 2;
    }
    /**
     * @hidden
     */
    get showAppLogo() {
        if (this.currentApplication == null)
            return false;
        const image = this.currentApplication.image;
        return !(image == null || image === '');
    }
    /**
     * @hidden
     */
    burgerIconClicked() {
        this.burgerClicked.emit();
    }
    /**
     * @hidden
     */
    onApplicationChanged(app) {
        this.currentApplication = app;
        if (!this.appLogoPreset) {
            setTimeout(() => {
                this.appLogoSet = true;
                this.appLogo = this.currentApplication.image;
            });
        }
        this.currentApplicationChange.emit(this.currentApplication);
    }
    /**
     * @hidden
     */
    onApplicationListChanged(apps) {
        this.applications = apps;
        this.applicationListChange.emit(apps);
    }
    /** @hidden */
    ngOnInit() {
        if (this.appLogo) {
            this.appLogoSet = true;
            this.appLogoPreset = true;
        }
        else {
            this.appLogo = this.currentApplication ? this.currentApplication.image : '';
            this.appLogoSet = true;
        }
        this._appsLength = this.applications ? this.applications.length : 0;
    }
};
__decorate([
    Input(),
    __metadata("design:type", ApplicationReference)
], AvlAppBarComponent.prototype, "currentApplication", void 0);
__decorate([
    Input(),
    HostBinding('class.responsive'),
    __metadata("design:type", Boolean)
], AvlAppBarComponent.prototype, "responsive", void 0);
__decorate([
    Input(),
    HostBinding('class.mobile'),
    __metadata("design:type", Boolean)
], AvlAppBarComponent.prototype, "mobile", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AvlAppBarComponent.prototype, "homePageUrl", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AvlAppBarComponent.prototype, "appLogo", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], AvlAppBarComponent.prototype, "applications", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlAppBarComponent.prototype, "applicationListChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], AvlAppBarComponent.prototype, "fixed", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlAppBarComponent.prototype, "currentApplicationChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlAppBarComponent.prototype, "burgerClicked", void 0);
AvlAppBarComponent = __decorate([
    Component({
        selector: 'avl-app-bar',
        template: "<header id=\"header\" class=\"mdc-toolbar mdc-toolbar--waterfall\" [ngClass]=\"{'mdc-toolbar--fixed': fixed}\">\r\n  <div class=\"mdc-toolbar__row\">\r\n    <section class=\"mdc-toolbar__section mdc-toolbar__section--align-start mdc-toolbar__section--shrink-to-fit section-with-switcher\">\r\n      <avl-app-bar-item class=\"burger-container\">\r\n        <avl-icon class=\"burgerMenu\" icon=\"menu\" theme=\"dark\" (click)=\"burgerIconClicked()\"></avl-icon>\r\n      </avl-app-bar-item>\r\n      <avl-app-bar-item class=\"noselect\" *ngIf=\"appLogoSet && appLogo != undefined\">\r\n        <a class=\"avl-app-logo\"\r\n          [style.background-image]=\"'url(' + appLogo + ')'\"\r\n          [style.background-repeat]=\"'no-repeat'\"\r\n          routerLink=\"{{homePageUrl ? homePageUrl : '/' }}\"></a>\r\n      </avl-app-bar-item>\r\n\r\n      <div *ngIf=\"isSingleApp; then singleApp else multiApp\"></div>\r\n      <ng-template #singleApp>\r\n        <avl-app-bar-item class=\"single-app-name\" [innerHTML]=\"currentApplication?.name\">\r\n        </avl-app-bar-item>\r\n      </ng-template>\r\n      <ng-template #multiApp>\r\n        <avl-app-bar-item class=\"toolbar-item-with-switcher\">\r\n          <avl-app-switcher [items]=\"applications\" (itemsChange)=\"onApplicationListChanged($event)\" [selectedValue]=\"currentApplication\" (selectedValueChange)=\"onApplicationChanged($event)\">\r\n          </avl-app-switcher>\r\n        </avl-app-bar-item>\r\n      </ng-template>\r\n    </section>\r\n    <section id=\"additionalContent\" class=\"mdc-toolbar__section mdc-toolbar__section--align-end \">\r\n      <ng-content></ng-content>\r\n      <ng-content select=\"avl-overflow-menu[slot=menu]\"></ng-content>\r\n    </section>\r\n  </div>\r\n</header>\r\n",
        encapsulation: ViewEncapsulation.Emulated,
        styles: [".mdc-toolbar{background-color:#3f51b5;background-color:var(--mdc-theme-primary,#3f51b5);color:#fff;color:var(--mdc-theme-text-primary-on-primary,#fff);display:flex;position:relative;flex-direction:column;justify-content:space-between;box-sizing:border-box;width:100%}.mdc-toolbar__row{display:flex;position:relative;align-items:center;box-sizing:border-box;width:100%;height:auto;min-height:64px}.mdc-toolbar__section{display:inline-flex;flex:1;align-items:flex-start;justify-content:center;min-width:0;height:100%}.mdc-toolbar__section--align-start{justify-content:flex-start;order:-1}.mdc-toolbar__section--align-end{justify-content:flex-end;order:1}.mdc-toolbar__title{font-family:Roboto,sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:1.25rem;font-weight:500;letter-spacing:.02em;text-decoration:inherit;text-transform:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;margin-left:24px;margin-right:0;align-self:center;padding:16px 0;line-height:1.5rem;z-index:1}.mdc-toolbar__title[dir=rtl],[dir=rtl] .mdc-toolbar__title{margin-left:0;margin-right:24px}.mdc-toolbar__icon{display:flex;align-items:center;justify-content:center;border:none;background-color:inherit;text-decoration:none;color:#fff;color:var(--mdc-theme-text-primary-on-primary,#fff);cursor:pointer}.mdc-toolbar__icon:last-of-type[dir=rtl],[dir=rtl] .mdc-toolbar__icon:last-of-type{padding-left:24px;padding-right:12px}.mdc-toolbar__menu-icon{display:flex;align-items:center;justify-content:center;padding:16px 24px;border:none;background-color:inherit;text-decoration:none;color:#fff;color:var(--mdc-theme-text-primary-on-primary,#fff);cursor:pointer}.mdc-toolbar__menu-icon+.mdc-toolbar__title{margin-left:8px;margin-right:0}.mdc-toolbar__menu-icon+.mdc-toolbar__title[dir=rtl],[dir=rtl] .mdc-toolbar__menu-icon+.mdc-toolbar__title{margin-left:0;margin-right:8px}.mdc-toolbar--fixed{box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12);position:fixed;top:0;left:0;z-index:4;box-shadow:none}.mdc-toolbar--flexible{--mdc-toolbar-ratio-to-extend-flexible:4}.mdc-toolbar--flexible .mdc-toolbar__row:first-child{height:256px;height:calc(64px * var(--mdc-toolbar-ratio-to-extend-flexible,4))}.mdc-toolbar--flexible .mdc-toolbar__row:first-child::after{position:absolute;content:\"\"}.mdc-toolbar--flexible-default-behavior .mdc-toolbar__title{font-family:Roboto,sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:2.125rem;font-weight:400;letter-spacing:normal;text-decoration:inherit;text-transform:inherit;align-self:flex-end;line-height:1.5rem}.mdc-toolbar--flexible-default-behavior .mdc-toolbar__row:first-child::after{top:0;left:0;width:100%;height:100%;transition:opacity .2s;opacity:1}.mdc-toolbar--flexible-default-behavior.mdc-toolbar--flexible-space-minimized .mdc-toolbar__row:first-child::after{opacity:0}.mdc-toolbar--flexible-default-behavior.mdc-toolbar--flexible-space-minimized .mdc-toolbar__title{font-weight:500}.mdc-toolbar--waterfall.mdc-toolbar--fixed{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12);transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);will-change:box-shadow}.mdc-toolbar--waterfall.mdc-toolbar--fixed.mdc-toolbar--flexible-space-minimized{box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)}.mdc-toolbar--waterfall.mdc-toolbar--fixed.mdc-toolbar--fixed-lastrow-only.mdc-toolbar--flexible-space-minimized{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12)}.mdc-toolbar--waterfall.mdc-toolbar--fixed.mdc-toolbar--fixed-lastrow-only.mdc-toolbar--fixed-at-last-row{box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)}.mdc-toolbar-fixed-adjust{margin-top:64px}@media (max-width:959px) and (orientation:landscape){.mdc-toolbar__row{min-height:48px}.mdc-toolbar-fixed-adjust{margin-top:48px}}@media (max-width:599px){.mdc-toolbar__row{min-height:56px}.mdc-toolbar__title{margin-left:16px;margin-right:0}.mdc-toolbar__title[dir=rtl],[dir=rtl] .mdc-toolbar__title{margin-left:0;margin-right:16px}.mdc-toolbar__icon{padding-right:8px;padding-left:8px}.mdc-toolbar__icon:last-of-type{padding-left:8px;padding-right:16px}.mdc-toolbar__icon:last-of-type[dir=rtl],[dir=rtl] .mdc-toolbar__icon:last-of-type{padding-left:16px;padding-right:8px}.mdc-toolbar__menu-icon{padding-right:16px;padding-left:16px}.mdc-toolbar__menu-icon+.mdc-toolbar__title{margin-left:16px;margin-right:0}.mdc-toolbar__menu-icon+.mdc-toolbar__title[dir=rtl],[dir=rtl] .mdc-toolbar__menu-icon+.mdc-toolbar__title{margin-left:0;margin-right:16px}.mdc-toolbar--flexible .mdc-toolbar__row:first-child{height:224px;height:calc(56px * var(--mdc-toolbar-ratio-to-extend-flexible,4))}.mdc-toolbar-fixed-adjust{margin-top:56px}}.mdc-toolbar__section--shrink-to-fit{flex:none}:host(){--item-color:var(--avl-app-bar-item-color, var(--avl-on-primary-color));--bar-height:var(--avl-app-bar-height, 53px);--background-color:var(--avl-app-bar-background-color, var(--avl-primary-color));--line-underline-color:var(--avl-app-bar-underline-color, var(--avl-product-color));color:var(--item-color);font-family:var(--avl-font-family);font-size:20px}#additionalContent{margin-right:12px;z-index:2}.material-icons{font-family:'Material Icons';font-weight:400;font-style:normal;font-size:24px;display:inline-block;line-height:1;text-transform:none;letter-spacing:normal;word-wrap:normal;white-space:nowrap;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:'liga'}.mdc-toolbar{background-color:var(--background-color);background-repeat:no-repeat;background-position:calc(100% - 61px) -30px;background-size:158px;color:var(--item-color);box-shadow:none;z-index:4;border-bottom:3px solid var(--line-underline-color)}#header{box-shadow:var(--avl-box-shadow-4dp)}avl-menu-button avl-icon-button{height:24px;width:24px;margin:0 16px 0 13px;padding:0}.mdc-toolbar__icon{color:var(--item-color);margin-bottom:0;padding:0}.mdc-toolbar__icon:active{color:var(--item-color)}.mdc-toolbar__icon:last-of-type{padding:0 16px}.search-bar-container{margin-left:24px;display:flex;justify-content:space-between;--avl-search-bar-text-color:var(--item-color, #fff);--avl-search-bar-search-color:var(--item-color, #fff)}.mdc-toolbar__row{min-height:var(--bar-height,53px);max-height:var(--bar-height,53px)}.mdc-toolbar__section{align-items:center;z-index:0}.avl-app-logo{width:32px;height:32px;background-size:100%}.burgerMenu{height:24px;width:24px}avl-icon-button{--avl-icon-button-color:white}.detailsMenuButtonSeparator{height:1px;background:#000}.icons-placeholder{font-size:20px;margin-bottom:0;margin-right:10px}.header-container{display:inline-flex;padding-bottom:5px;padding-top:5px}.header-icon{font-size:20px;margin-bottom:0;margin-right:10px;margin-top:5px}.header-text{display:inline;margin-left:-5px;font-size:25px;font-weight:700;padding-bottom:5px}.toolbar-item-with-switcher{padding-left:12px!important}avl-app-bar-item{cursor:initial!important}.section-with-switcher{position:relative;z-index:2}.burgerMenu{display:none;cursor:pointer}.avl-app-logo{margin:12px 0 12px 20px}.single-app-name{cursor:default}:host(.mobile) .burgerMenu{display:block}@media (max-width:960px){:host(.responsive) .burgerMenu{display:block}}@media (min-width:400px){:host(.mobile) .burgerMenu,:host(.responsive) .burgerMenu{margin:16px 0 16px 24px}}@media (max-width:400px){:host(.mobile) .avl-app-logo,:host(.responsive) .avl-app-logo{display:none}:host(.mobile) .burgerMenu,:host(.responsive) .burgerMenu{margin:16px -4px 16px 16px}}"]
    })
], AvlAppBarComponent);

var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let AvlAppBarItemComponent = class AvlAppBarItemComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.elementRef.nativeElement.classList.add('mdc-toolbar__icon');
    }
};
AvlAppBarItemComponent.ctorParameters = () => [
    { type: ElementRef }
];
AvlAppBarItemComponent = __decorate$1([
    Component({
        selector: 'avl-app-bar-item',
        template: '<ng-content></ng-content>'
    }),
    __metadata$1("design:paramtypes", [ElementRef])
], AvlAppBarItemComponent);

var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
const rowHeightPx = 48;
let AvlSideNavComponent = class AvlSideNavComponent {
    constructor(router, activeRoute) {
        this.router = router;
        this.activeRoute = activeRoute;
        this.openValue = false;
        /**
         * Emitted when the open property changes.
         */
        this.openChange = new EventEmitter();
        activeRoute.queryParams.subscribe(p => {
            this.params = p;
        });
        this.subscription = this.router.events
            .pipe(filter(event => event instanceof ActivationEnd))
            .subscribe((event) => {
            this.selectItems();
        });
    }
    /**
     * Can be set to open or close the side nav.
     * Returns the current state of the side nav.
     */
    get open() {
        return this.openValue;
    }
    set open(val) {
        this.openValue = val;
        this.openChange.next(val);
    }
    /**
     * @hidden
     */
    toggleOpen() {
        if (!this.manuallyOpened) {
            this.open = !this.open;
        }
    }
    /**
     * @hidden
     */
    arrowToggleOpen() {
        this.manuallyOpened = !this.open;
        this.open = !this.open;
    }
    /**
     * @hidden
     */
    mobileClose() {
        if (Math.max(document.documentElement.clientWidth, window.innerWidth) < 960) {
            this.open = false;
        }
    }
    /**
     * @hidden
     */
    groupClicked(item) {
        if (!this.open) {
            this.open = true;
            if (!item.expanded) {
                item.expanded = true;
            }
        }
        else {
            item.expanded = !item.expanded;
        }
    }
    /**
     * @hidden
     */
    getScrubberStyle() {
        return {
            height: this.selectedParagraph ? '14px' : '0px',
            top: `${this.selectedParagraphIndex * rowHeightPx}px`
        };
    }
    /**
    * @hidden
    */
    trimSlash(str) {
        if (str[0] === '/') {
            str = str.substring(1, str.length);
        }
        if (str[str.length - 1] === '/') {
            str = str.substring(0, str.length - 1);
        }
        return str;
    }
    selectItems() {
        if (!this.menuItems) {
            return;
        }
        const fragment = this.router.parseUrl(this.router.url).fragment;
        const url = this.router.url.split('#')[0];
        const queue = this.menuItems.slice();
        let currentGroup;
        this.selectedGroup = undefined;
        this.selectedPage = undefined;
        this.selectedParagraph = undefined;
        let fallbackSelectedPage;
        while (queue.length) {
            const item = queue.pop();
            if (isGroup(item)) {
                currentGroup = item;
                item.subItems.map(subitem => { queue.push(subitem); });
            }
            else {
                if (fallbackSelectedPage == null && this.trimSlash(url).startsWith(this.trimSlash(item.route))) {
                    fallbackSelectedPage = item;
                }
                if (item.route && this.trimSlash(url).endsWith(this.trimSlash(item.route + this.getUrlParams(item.params)))) {
                    if (this.selectedPage && this.selectedPage.route && this.selectedPage.route.length > item.route.length) {
                        continue;
                    }
                    if (item.params && item.params.length > 0) {
                        const object = new Object();
                        item.params.forEach(i => {
                            object[i.name] = i.value;
                        });
                        if (JSON.stringify(this.params) === JSON.stringify(object)) {
                            this.selectedPage = item;
                        }
                    }
                    else {
                        this.selectedPage = item;
                    }
                    if (isTopLevelPage(item)) {
                        this.selectedGroup = undefined;
                    }
                    else {
                        this.selectedGroup = currentGroup;
                    }
                    if (item.paragraphs && item.paragraphs.length > 0) {
                        const paragraphIndex = item.paragraphs.findIndex((p) => p.id === fragment);
                        if (fragment && item.paragraphs && paragraphIndex !== -1) {
                            this.selectedParagraph = fragment;
                            this.selectedParagraphIndex = paragraphIndex;
                        }
                    }
                }
            }
        }
        if (this.selectedPage == null) {
            this.selectedPage = fallbackSelectedPage;
        }
    }
    /**
    * @hidden
    */
    ngOnChanges(changes) {
        if (changes['menuItems']) {
            this.selectItems();
        }
    }
    /**
    * @hidden
    */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
    * @hidden
    */
    getParams(params) {
        if (params && params.length > 0) {
            const object = {};
            params.forEach(param => {
                object[param.name] = param.value;
            });
            return object;
        }
        else {
            return null;
        }
    }
    /**
    * @hidden
    */
    getUrlParams(params) {
        if (params && params.length > 0) {
            let url = '?';
            params.forEach(param => {
                url += param.name + '=' + param.value + '&';
            });
            return url.slice(0, -1);
        }
        else {
            return '';
        }
    }
};
AvlSideNavComponent.ctorParameters = () => [
    { type: Router },
    { type: ActivatedRoute }
];
__decorate$2([
    Input(),
    HostBinding('class.open'),
    __metadata$2("design:type", Boolean),
    __metadata$2("design:paramtypes", [Boolean])
], AvlSideNavComponent.prototype, "open", null);
__decorate$2([
    Input(),
    __metadata$2("design:type", Array)
], AvlSideNavComponent.prototype, "menuItems", void 0);
__decorate$2([
    Input(),
    HostBinding('class.responsive'),
    __metadata$2("design:type", Boolean)
], AvlSideNavComponent.prototype, "responsive", void 0);
__decorate$2([
    Input(),
    HostBinding('class.mobile'),
    __metadata$2("design:type", Boolean)
], AvlSideNavComponent.prototype, "mobile", void 0);
__decorate$2([
    Output(),
    __metadata$2("design:type", EventEmitter)
], AvlSideNavComponent.prototype, "openChange", void 0);
AvlSideNavComponent = __decorate$2([
    Component({
        selector: 'avl-side-nav',
        template: "<div #outerContainer [class.closed]=\"!open\" class=\"outer-container toolbar-spacing\">\r\n  <div class=\"item-scroll\">\r\n    <div #innerContainer class=\"inner-container\">\r\n      <ng-template ngFor let-item [ngForOf]=\"menuItems\">\r\n        <!-- Top level page -->\r\n        <a *ngIf=\"!item.subItems\" tabindex=\"0\" class=\"item top-level-page\" routerLink={{item.route}} [queryParams]=\"getParams(item.params)\" [class.selected]=\"item === selectedPage\" (click)=\"mobileClose()\">\r\n          <div class=\"image-div\">\r\n            <avl-icon *ngIf=\"item.icon\" attr.icon=\"{{item.icon}}\"></avl-icon>\r\n            <img *ngIf=\"item.iconUrl\" [src]=\"item.iconUrl\">\r\n          </div>\r\n          <div class=\"label-div\">{{item.label}}</div>\r\n          <div class=\"item-overlay\"></div>\r\n        </a>\r\n        <!-- Paragraphs of a top level page -->\r\n        <div class=\"child-container\" *ngIf=\"open && item.paragraphs && item.paragraphs.length > 0 && item === selectedPage\" [@expandCollapse]>\r\n          <!-- div for preventing reversing of the items by flex-direction: column-reverse -->\r\n          <div>\r\n            <a *ngFor=\"let paragraph of item.paragraphs\" class=\"item top-level-paragraph\"\r\n              href=\"{{trimSlash(item.route + getUrlParams(item.params) + '#' + paragraph.id)}}\" [class.selected]=\"paragraph.id === selectedParagraph\" (click)=\"mobileClose()\">\r\n              <div class=\"label-div\">{{paragraph.label}}</div>\r\n            </a>\r\n          </div>\r\n          <div class=\"page-progress-bar\">\r\n            <div class=\"page-progress-bar-background\"></div>\r\n            <div class=\"page-progress-bar-scrubber\" [ngStyle]=\"getScrubberStyle()\"></div>\r\n          </div>\r\n        </div>\r\n        <!-- Group -->\r\n        <div *ngIf=\"item.subItems\" tabindex=\"0\" class=\"item group\" [class.expanded]=\"item.expanded\" (click)=\"groupClicked(item)\"\r\n          [class.selected]=\"!open && item === selectedGroup\">\r\n          <div class=\"image-div\">\r\n            <avl-icon *ngIf=\"item.icon\" attr.icon=\"{{item.icon}}\"></avl-icon>\r\n            <img *ngIf=\"item.iconUrl\" [src]=\"item.iconUrl\">\r\n          </div>\r\n          <div class=\"label-div group\">{{item.label}}</div>\r\n          <avl-icon class=\"group-arrow\" icon=\"arrow-drop-down\"></avl-icon>\r\n          <div class=\"item-overlay\"></div>\r\n        </div>\r\n        <!-- Subpages -->\r\n        <div class=\"child-container\" *ngIf=\"open && item.subItems && item.subItems.length > 0 && item.expanded\" [@expandCollapse] (click)=\"toggleOpen()\">\r\n          <!-- div for preventing reversing of the items by flex-direction: column-reverse -->\r\n          <div>\r\n            <ng-template ngFor let-subItem [ngForOf]=\"item.subItems\">\r\n              <a class=\"item subpage\" routerLink={{subItem.route}} [queryParams]=\"getParams(subItem.params)\" [class.selected]=\"subItem === selectedPage\" (click)=\"mobileClose()\">\r\n                <div class=\"label-div\">{{subItem.label}}</div>\r\n                <div class=\"item-overlay\"></div>\r\n              </a>\r\n              <!-- Paragraphs of a subpage -->\r\n              <div class=\"child-container\" *ngIf=\"subItem.paragraphs && subItem.paragraphs.length > 0 && subItem === selectedPage\" [@expandCollapse]>\r\n                <!-- div for preventing reversing of the items by flex-direction: column-reverse -->\r\n                <div>\r\n                  <a *ngFor=\"let paragraph of subItem.paragraphs\" class=\"item subpage-paragraph\" href=\"{{subItem.route}}{{getUrlParams(item.params)}}#{{paragraph.id}}\"\r\n                    [class.selected]=\"paragraph.id === selectedParagraph\" (click)=\"mobileClose()\">\r\n                    <div class=\"label-div\">{{paragraph.label}}</div>\r\n                  </a>\r\n                </div>\r\n                <div class=\"page-progress-bar\">\r\n                  <div class=\"page-progress-bar-background\"></div>\r\n                  <div class=\"page-progress-bar-scrubber\" [ngStyle]=\"getScrubberStyle()\"></div>\r\n                </div>\r\n              </div>\r\n            </ng-template>\r\n          </div>\r\n        </div>\r\n      </ng-template>\r\n    </div>\r\n  </div>\r\n  <div class=\"arrow-spacer\"></div>\r\n\r\n  <svg (click)=\"arrowToggleOpen()\" [class.closed]=\"!open\" class=\"open-close-arrow\"  id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\r\n    <g transform=\"translate(405 102) rotate(-180)\">\r\n      <path d=\"M-972.955,492l6.774-6,1.581,1.4-5.194,4.6,5.194,4.6-1.581,1.4Zm-5.645,0,6.773-6,1.581,1.4-5.193,4.6,5.193,4.6-1.581,1.4Z\" transform=\"translate(1364.6 -402)\"/>\r\n    </g>\r\n  </svg>\r\n\r\n</div>\r\n<div class=\"scrim\" (click)=\"open = false;\"></div>",
        animations: [
            trigger('expandCollapse', [
                transition(':enter', [
                    style({ 'max-height': '0px' }),
                    animate('225ms ease-in', style({ transform: 'translateY(0%)', 'max-height': '200px' }))
                ]),
                transition(':leave', [
                    style({ 'max-height': '200px' }),
                    animate('180ms ease-in', style({ 'max-height': '0px' }))
                ])
            ])
        ],
        styles: [":host{font-family:var(--avl-font-family);height:100%;display:block;--text-color:var(--avl-side-nav-text-color, var(--avl-emphasis-high-color));--icons-color:var(--avl-side-nav-icons-color, var(--avl-emphasis-medium-color));--background-color:var(--avl-side-nav-background-color, var(--avl-side-nav-color));--item-icon-width:72px;--side-nav-mini-width:var(--item-icon-width);--side-nav-open-width:var(--avl-side-nav-open-width, 256px);--item-height:48px;box-shadow:var(--avl-box-shadow-12dp);z-index:3}.outer-container{position:relative;box-sizing:content-box;height:calc(100% - var(--avl-app-bar-height,56px));background-color:var(--background-color);width:var(--side-nav-open-width);overflow:hidden}.inner-container{width:var(--side-nav-open-width)}.toolbar-spacing{padding-top:var(--avl-app-bar-height,56px)}.open-close-arrow{position:absolute;bottom:12px;right:24px;font-size:24px;fill:var(--icons-color);cursor:pointer;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:24px}.open-close-arrow:not(.closed){transform:scale(-1,1)}.outer-container.closed{width:var(--side-nav-mini-width);-webkit-animation-name:closing;animation-name:closing;-webkit-animation-timing-function:cubic-bezier(0,0,.2,1);animation-timing-function:cubic-bezier(0,0,.2,1);transition-duration:195ms}.arrow-spacer{height:48px}.item-scroll{height:calc(100% - 48px);overflow-y:auto;overflow-x:hidden}.item{display:flex;align-items:center;cursor:pointer;color:var(--text-color);height:var(--item-height);position:relative;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;isolation:isolate;outline:0;white-space:pre-wrap;padding-right:24px}.item:active{color:var(--text-color)}.top-level-paragraph{padding-left:88px}.subpage{padding-left:72px}.subpage-paragraph{padding-left:88px}.label-div{z-index:10;font-family:Roboto;max-width:160px;overflow:hidden;text-overflow:ellipsis;max-height:40px;word-break:break-word;-webkit-box-orient:vertical;display:-webkit-box;-webkit-line-clamp:2}.group.expanded>.label-div.group{font-family:Roboto-Medium}.label-div.group{max-width:calc(100% - 112px)}.image-div{color:var(--avl-emphasis-medium-color);display:flex;align-items:center;justify-content:center;width:var(--item-icon-width);height:var(--item-height);margin-right:0;z-index:9}img{height:auto;width:auto;max-height:24px;max-width:24px}avl-icon{margin-bottom:0;font-size:24px;color:var(--avl-emphasis-medium-color)}.group-arrow{position:absolute;right:24px}.group.expanded>.group-arrow{transform:rotate(180deg)}.item-overlay{box-sizing:border-box;position:absolute;height:100%;width:100%;left:0;z-index:0}.item.selected>.item-overlay{background-color:var(--avl-side-nav-product-color,var(--avl-product-focus-color))}.item:hover:not(.selected)>.item-overlay{background-color:var(--avl-side-nav-product-color-hover,var(--avl-product-hover-color))}.item.selected{font-weight:500}.child-container{position:relative;display:flex;overflow:hidden;flex-direction:column-reverse}.page-progress-bar{position:absolute;left:72px;top:11px;bottom:11px;width:2px;overflow:hidden}.page-progress-bar-background{background-color:var(--text-color);opacity:.2;width:100%;height:100%}.page-progress-bar-scrubber{position:absolute;width:100%;background-color:var(--text-color);opacity:1;transition:height .2s,top .2s;margin-top:6px;margin-bottom:2px}@-webkit-keyframes closing{from{width:var(--side-nav-open-width)}to{width:var(--side-nav-mini-width)}}@keyframes closing{from{width:var(--side-nav-open-width)}to{width:var(--side-nav-mini-width)}}@-webkit-keyframes opening{from{width:var(--side-nav-mini-width)}to{width:var(--side-nav-open-width)}}@keyframes opening{from{width:var(--side-nav-mini-width)}to{width:var(--side-nav-open-width)}}.outer-container:not(.closed){-webkit-animation-name:opening;animation-name:opening;-webkit-animation-timing-function:cubic-bezier(0,0,.2,1);animation-timing-function:cubic-bezier(0,0,.2,1);transition-duration:225ms}@media (max-width:960px){:host(.responsive){position:absolute;--side-nav-mini-width:0;transition:box-shadow 250ms}:host(.responsive[slot=left-side]){left:0}:host(.responsive[slot=right-side]){right:0}:host(.responsive:not(.open)){box-shadow:none}:host(.responsive) .item-scroll{height:100%}:host(.responsive) .open-close-arrow{display:none}:host(.responsive) .arrow-spacer{display:none;visibility:hidden}:host(.responsive) .scrim{transition:250ms;transition-duration:250px}:host(.responsive[slot=left-side]:not(.open)) .scrim{visibility:hidden;left:0}:host(.responsive.open) .scrim{background-color:var(--avl-scrim-color);position:fixed;visibility:visible;top:0;width:100%;height:100%}:host(.responsive[slot=left-side].open) .scrim{left:var(--side-nav-open-width)}:host(.responsive[slot=right-side].open) .scrim{right:var(--side-nav-open-width)}:host(.responsive[slot=right-side]:not(.open)) .scrim{visibility:hidden;right:0}}:host(.mobile){position:absolute;--side-nav-mini-width:0;transition:box-shadow 250ms}:host(.mobile[slot=left-side]){left:0}:host(.mobile[slot=right-side]){right:0}:host(.mobile:not(.open)){box-shadow:none}:host(.mobile) .item-scroll{height:100%}:host(.mobile) .open-close-arrow{display:none}:host(.mobile) .arrow-spacer{display:none;visibility:hidden}:host(.mobile) .scrim{transition:250ms;transition-duration:250px}:host(.mobile[slot=left-side]:not(.open)) .scrim{visibility:hidden;left:0}:host(.mobile.open) .scrim{background-color:var(--avl-scrim-color);position:fixed;visibility:visible;top:0;width:100%;height:100%}:host(.mobile[slot=left-side].open) .scrim{left:var(--side-nav-open-width)}:host(.mobile[slot=right-side].open) .scrim{right:var(--side-nav-open-width)}:host(.mobile[slot=right-side]:not(.open)) .scrim{visibility:hidden;right:0}"]
    }),
    __metadata$2("design:paramtypes", [Router,
        ActivatedRoute])
], AvlSideNavComponent);
/**
* @hidden
*/
function isGroup(item) {
    return item.subItems !== undefined && item.subItems.length > 0;
}
/**
* @hidden
*/
function isTopLevelPage(item) {
    return !isGroup(item) && (item.icon !== undefined || item.iconUrl !== undefined);
}

var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$3 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let AvlAppLayoutComponent = class AvlAppLayoutComponent {
    constructor() { }
    ngAfterContentInit() {
        if (this.sideNav && this.appBar) {
            this.appBar.burgerClicked.subscribe(() => this.sideNav.open = !this.sideNav.open);
        }
    }
};
__decorate$3([
    ContentChild(AvlSideNavComponent),
    __metadata$3("design:type", AvlSideNavComponent)
], AvlAppLayoutComponent.prototype, "sideNav", void 0);
__decorate$3([
    ContentChild(AvlAppBarComponent),
    __metadata$3("design:type", AvlAppBarComponent)
], AvlAppLayoutComponent.prototype, "appBar", void 0);
AvlAppLayoutComponent = __decorate$3([
    Component({
        selector: 'avl-app-layout',
        template: "<ng-content select=\"[slot=toolbar]\"></ng-content>\r\n<div class=\"sideNavAndContent\">\r\n  <ng-content select=\"[slot=left-side]\"></ng-content>\r\n  <main>\r\n    <ng-content></ng-content>\r\n  </main>\r\n  <ng-content select=\"[slot=right-side]\"></ng-content>\r\n</div>\r\n",
        encapsulation: ViewEncapsulation.Emulated,
        styles: [".sideNavAndContent{display:flex;flex-direction:row;flex-flow:row nowrap;height:100%;padding-bottom:4px;position:relative}.scrim{display:none;visibility:hidden}main{--app-bar-height:var(--avl-app-bar-height, 53px);color:var(--avl-primary-text-color);width:100%;padding:var(--avl-app-layout-content-padding,24px);overflow:auto;margin-top:var(--app-bar-height)}:host([noPadding]) main{padding:0}"]
    }),
    __metadata$3("design:paramtypes", [])
], AvlAppLayoutComponent);

var __decorate$4 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$4 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let AvlNoPaddingDirective = class AvlNoPaddingDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
    /** @hidden */
    ngOnInit() {
        const appLayout = this.findAppLayout();
        if (appLayout) {
            appLayout.setAttribute('noPadding', '');
        }
    }
    /** @hidden */
    ngOnDestroy() {
        const appLayout = this.findAppLayout();
        if (appLayout) {
            appLayout.removeAttribute('noPadding');
        }
    }
    findAppLayout() {
        let element = this.elementRef.nativeElement;
        while (element) {
            if (element.tagName.toLowerCase() == 'avl-app-layout') {
                return element;
            }
            element = element.parentElement;
        }
    }
};
AvlNoPaddingDirective.ctorParameters = () => [
    { type: ElementRef }
];
AvlNoPaddingDirective = __decorate$4([
    Directive({
        selector: '[avl-no-padding]'
    }),
    __metadata$4("design:paramtypes", [ElementRef])
], AvlNoPaddingDirective);

var __decorate$5 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$5 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let AvlParagraphDirective = class AvlParagraphDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
};
AvlParagraphDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate$5([
    Input('avl-paragraph'),
    __metadata$5("design:type", String)
], AvlParagraphDirective.prototype, "paragraphName", void 0);
AvlParagraphDirective = __decorate$5([
    Directive({
        selector: '[avl-paragraph]'
    }),
    __metadata$5("design:paramtypes", [ElementRef])
], AvlParagraphDirective);

var __decorate$6 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$6 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
* avl-long-page should only be used inside avl-app-layout. The only scrollable container should
* be avl-app-layout (already set by default) and avl-long-page and components that are using it must
* not scroll in order for avl-long-page to work properly.
*/
let AvlLongPageComponent = class AvlLongPageComponent {
    /**
    * @hidden
    */
    constructor(router, renderer, platformId) {
        this.router = router;
        this.renderer = renderer;
        this.platformId = platformId;
        this.scrollListener = (event) => {
            let newParagraph;
            if (this.scrollContainer.scrollHeight < Math.round(this.scrollContainer.scrollTop + this.scrollContainer.getBoundingClientRect().height)) {
                newParagraph = this.paragraphs.last;
            }
            else {
                this.paragraphs.forEach(paragraph => {
                    const p = paragraph.elementRef.nativeElement;
                    const rect = p.getBoundingClientRect();
                    if (rect.top < window.innerHeight * 0.1) {
                        newParagraph = paragraph;
                    }
                });
            }
            if (newParagraph) {
                this.currentFragment = newParagraph.paragraphName;
                this.router.navigate([], { queryParamsHandling: 'preserve', fragment: newParagraph.paragraphName });
            }
        };
    }
    handleRouteChange() {
        const paragraphName = this.router.parseUrl(this.router.url).fragment;
        const paragraph = this.paragraphs.find(p => p.paragraphName === paragraphName);
        if (this.currentFragment === paragraphName) {
            return;
        }
        if (paragraph) {
            setTimeout(() => paragraph.elementRef.nativeElement.scrollIntoView({ behavior: 'instant', block: 'start', inline: 'nearest' }), 0);
        }
    }
    /**
    * @hidden
    */
    ngAfterViewInit() {
        if (isPlatformBrowser(this.platformId)) {
            this.scrollContainer = document.querySelector('avl-app-layout main');
            this.scrollSubscription = this.renderer.listen(this.scrollContainer, 'scroll', this.scrollListener);
        }
        this.handleRouteChange();
        this.routerSubscription = this.router.events.subscribe(newRoute => {
            if (newRoute instanceof NavigationEnd) {
                this.handleRouteChange();
            }
        });
        this.paragraphsSubscription = this.paragraphs.changes.subscribe(_ => {
            /* if scrollIntoView has not occured yet try it with new paragraphs
               this is needed for components which render content (paragraphs)
               after view has been initialized
            */
            if (!this.currentFragment) {
                this.handleRouteChange();
            }
        });
    }
    /**
    * @hidden
    */
    ngOnDestroy() {
        if (this.routerSubscription) {
            this.routerSubscription.unsubscribe();
        }
        if (this.paragraphsSubscription) {
            this.paragraphsSubscription.unsubscribe();
        }
        if (this.scrollSubscription) {
            this.scrollSubscription();
        }
    }
};
AvlLongPageComponent.ctorParameters = () => [
    { type: Router },
    { type: Renderer2 },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
__decorate$6([
    ContentChildren(AvlParagraphDirective),
    __metadata$6("design:type", QueryList)
], AvlLongPageComponent.prototype, "paragraphs", void 0);
AvlLongPageComponent = __decorate$6([
    Component({
        selector: 'avl-long-page',
        template: "<ng-content></ng-content>",
        encapsulation: ViewEncapsulation.None,
        styles: [":host{font-family:var(--avl-font-family)}"]
    }),
    __param(2, Inject(PLATFORM_ID)),
    __metadata$6("design:paramtypes", [Router, Renderer2, Object])
], AvlLongPageComponent);

/** @hidden */
class KeyboardNavigator {
    constructor(numberOfItems, gridWidth) {
        this.numberOfItems = numberOfItems;
        this.gridWidth = gridWidth;
    }
    /** @returns to which item to navigate to from the current item and undefined to not move. */
    navigate(currentItemIndex, keyPressed, nextGroupSize = 0, prevGroupSize = 0) {
        nextGroupSize = nextGroupSize || 0;
        prevGroupSize = prevGroupSize || 0;
        const currentItemColumn = currentItemIndex % this.gridWidth;
        const currentItemRow = Math.floor(currentItemIndex / this.gridWidth);
        const maxRows = Math.ceil(this.numberOfItems / this.gridWidth);
        let nextIndex;
        switch (keyPressed) {
            case 'ArrowUp':
            case 'Up':
                nextIndex = currentItemIndex - this.gridWidth;
                if (currentItemRow === 0) {
                    if (prevGroupSize === 0) {
                        return undefined;
                    }
                    if (nextIndex < 0) {
                        const prevLastIndex = prevGroupSize - 1;
                        // columns of last element and targeted element of previous group
                        // - 0 based index
                        const lastColumn = prevLastIndex % this.gridWidth;
                        return currentItemColumn <= lastColumn
                            ? currentItemColumn - lastColumn - 1 // negative indexes -> -1 is last element
                            : prevGroupSize <= this.gridWidth
                                // focus last element of previous group if focus should go on 2 groups before current
                                ? -1
                                : -this.gridWidth - currentItemColumn;
                    }
                }
                return nextIndex;
            case 'ArrowDown':
            case 'Down': {
                nextIndex = currentItemIndex + this.gridWidth;
                const indexExists = nextIndex < this.numberOfItems;
                if (currentItemRow === maxRows - 1) {
                    if (nextGroupSize === 0) {
                        return undefined;
                    }
                    if (!indexExists) {
                        const nextLastIndex = nextGroupSize - 1;
                        const lastColumn = nextLastIndex % this.gridWidth;
                        return lastColumn >= currentItemColumn
                            ? currentItemColumn
                            : nextGroupSize <= this.gridWidth
                                ? 0
                                : this.gridWidth + currentItemColumn;
                    }
                }
                else if (!indexExists) {
                    return this.numberOfItems - 1;
                }
                return nextIndex;
            }
            case 'ArrowLeft':
            case 'Left':
                if (currentItemIndex === 0) {
                    return prevGroupSize === 0 ? undefined : -1;
                }
                return currentItemIndex - 1;
            case 'ArrowRight':
            case 'Right': {
                if (currentItemIndex === this.numberOfItems - 1) {
                    return nextGroupSize === 0 ? undefined : 0;
                }
                nextIndex = currentItemIndex + 1;
                return nextIndex;
            }
            default:
                return undefined;
        }
    }
}

var __decorate$7 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$7 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let AvlSolutionOverviewComponent = class AvlSolutionOverviewComponent {
    constructor(cdr) {
        this.cdr = cdr;
        /**
         * Emits search query string on change
         */
        this.searchQueryChange = new EventEmitter();
        /**
         * Emits value of the search query when search triggered
         */
        this.search = new EventEmitter();
        this.gridWidth$ = new BehaviorSubject(-1);
        this.largestItemsIndex = -1;
        this.maxItems = 0;
    }
    get groupsOfItems() {
        let v = [];
        for (const gRef of this.groupElementRefs) {
            const gEl = gRef.nativeElement;
            const items = Array.prototype.slice.call(gEl.querySelectorAll('a.item'));
            v = [...v, items];
        }
        return v;
    }
    get iconButtonElements() {
        if (this.iconButtonElementsCache == null) {
            this.iconButtonElementsCache = Array.prototype.slice.call(this.iconButtonsContainer
                .nativeElement.querySelectorAll('avl-icon-button'));
        }
        return this.iconButtonElementsCache;
    }
    ngOnInit() {
        this.setupReferenceVars();
        this.gridWidthClass$ = this.gridWidth$.asObservable().pipe(throttleTime(50, asyncScheduler, { trailing: true }), map(gridWidth => {
            return `grid-width-${gridWidth}`;
        }));
    }
    ngOnDestroy() {
        if (this.groupElementRefsChangesSubscription) {
            this.groupElementRefsChangesSubscription.unsubscribe();
        }
    }
    ngOnChanges(changes) {
        if (changes.groups && !changes.groups.isFirstChange()) {
            this.setupReferenceVars();
            this.gridWidth$.next(this.getGridWidth());
            this.setTopMargin();
        }
    }
    /** @hidden */
    ngAfterViewInit() {
        this.setTopMargin();
        this.setupFocusOrdering();
        this.gridWidth$.next(this.getGridWidth());
    }
    /** @hidden */
    getMaxColumnsClass() {
        if (this.maxColumns && window.outerWidth === this.screenWidth) {
            return `max-columns-${this.maxColumns}`;
        }
        if (this.maxItems === 0) {
            return;
        }
        let maxColumns;
        switch (this.maxItems) {
            case 1:
                maxColumns = 1;
                break;
            case 2:
            case 4:
                maxColumns = 2;
                break;
            case 3:
            case 5:
            case 6:
            case 9:
                maxColumns = 3;
                break;
            case 7:
            case 8:
            case 11:
            case 12:
                maxColumns = 4;
                break;
            default:
                maxColumns = 5;
        }
        this.maxColumns = maxColumns;
        return `max-columns-${maxColumns}`;
    }
    /** @hidden **/
    onResize() {
        this.gridWidth$.next(this.getGridWidth());
    }
    /** @hidden */
    onKeydownHandler(event) {
        const gOfItems = this.groupsOfItems;
        const numGroups = gOfItems.length;
        if (numGroups === 0) {
            return;
        }
        const activeEl = document.activeElement;
        const isDown = ['Down', 'ArrowDown'].includes(event.key);
        const isUp = ['Up', 'ArrowUp'].includes(event.key);
        const isRight = ['Right', 'ArrowRight'].includes(event.key);
        const isLeft = ['Left', 'ArrowLeft'].includes(event.key);
        const isTab = event.key === 'Tab';
        const searchbar = this.showSearchBar
            ? this.searchbarRef.nativeElement
            : undefined;
        let gNum;
        let iIdx;
        for (const items of gOfItems) {
            if (items.indexOf(activeEl) !== -1) {
                iIdx = items.indexOf(activeEl);
                gNum = gOfItems.indexOf(items);
                // Go to route on 'Space'. 'Enter' already works on <a>.
                if (event.key === ' ') {
                    items[iIdx].click();
                    return;
                }
            }
        }
        if (this.iconButtonElements.includes(activeEl)) {
            const numIconButtons = this.iconButtonElements.length;
            const idx = this.iconButtonElements.indexOf(activeEl);
            if ((isRight || isTab) && idx === numIconButtons - 1) {
                if (searchbar != null) {
                    searchbar.focus();
                }
                else {
                    gOfItems[0][0].focus();
                }
            }
            else if (isLeft && idx === 0) {
                const g = gOfItems[numGroups - 1];
                const gLen = g.length;
                g[gLen - 1].focus();
            }
            else if (isLeft) {
                this.iconButtonElements[idx - 1].focus();
            }
            else if (isRight) {
                this.iconButtonElements[idx + 1].focus();
            }
            event.preventDefault();
        }
        const itemElements = gOfItems[gNum];
        const gridWidth = this.gridWidth$.value;
        if (searchbar != null && iIdx < gridWidth && gNum === 0 && isUp) {
            searchbar.focus();
            event.preventDefault();
        }
        else if ((isRight || isTab) &&
            gNum === gOfItems.length - 1 &&
            iIdx === itemElements.length - 1) {
            const iconButtons = this.iconButtonElements;
            if (iconButtons != null && iconButtons.length > 0) {
                iconButtons[0].focus();
                event.preventDefault();
            }
        }
        else if (searchbar != null && searchbar === activeEl && isDown) {
            gOfItems[0][0].focus();
            event.preventDefault();
        }
        else if (gNum != null) {
            const nextGroup = gNum === gOfItems.length - 1 ? undefined : gOfItems[gNum + 1];
            const prevGroup = gNum === 0 ? undefined : gOfItems[gNum - 1];
            const nGLen = nextGroup == null ? 0 : nextGroup.length;
            const pGLen = prevGroup == null ? 0 : prevGroup.length;
            const keyboardNavigator = new KeyboardNavigator(itemElements.length, gridWidth);
            const itemIndexToMoveTo = keyboardNavigator.navigate(iIdx, event.key, nGLen, pGLen);
            if (itemIndexToMoveTo != null) {
                if ((isUp || isLeft) && itemIndexToMoveTo < 0) {
                    prevGroup[itemIndexToMoveTo + pGLen].focus();
                }
                else if ((isDown || isRight) && iIdx + 1 > itemIndexToMoveTo) {
                    nextGroup[itemIndexToMoveTo].focus();
                }
                else {
                    gOfItems[gNum][itemIndexToMoveTo].focus();
                }
                event.preventDefault();
            }
        }
    }
    /** @hidden */
    onQueryChange(event) {
        this.searchQueryChange.emit(event.detail.value);
    }
    /** @hidden */
    onSearch(event) {
        this.search.emit(event.detail.value);
    }
    setupReferenceVars() {
        let max = 0;
        for (const g of this.groups) {
            const itemSz = g.items.length;
            if (max < itemSz) {
                max = itemSz;
                this.largestItemsIndex = this.groups.indexOf(g);
            }
        }
        this.maxItems = max;
    }
    setTopMargin() {
        this.contentHasScroll = false;
        this.cdr.detectChanges();
        const content = this.groupsContainer.nativeElement;
        this.contentHasScroll = content.scrollHeight > content.clientHeight;
        this.cdr.detectChanges();
    }
    getGridWidth() {
        if (this.largestItemsIndex < 0) {
            this.setupReferenceVars();
        }
        const items = this.groupsOfItems[this.largestItemsIndex];
        const firstItemOffsetTop = items[0].offsetTop;
        let i = 0;
        for (const item of items) {
            if (item.offsetTop > firstItemOffsetTop) {
                return i;
            }
            i++;
        }
        return items.length;
    }
    setupFocusOrdering() {
        const buttonElements = this.buttonRefs.map(elRef => elRef.nativeElement);
        let focusableElements = [];
        if (this.showSearchBar) {
            focusableElements.push(this.searchbarRef.nativeElement);
        }
        focusableElements = [
            ...focusableElements,
            ...buttonElements,
            ...this.iconButtonElements
        ];
        focusableElements.forEach((el) => {
            el.addEventListener('focus', (event) => {
                const t = event.target;
                if (t.tagName.toLowerCase() === 'avl-icon-button') {
                    if (this.showSearchBar && (['body', 'html'].includes(document.activeElement.tagName.toLowerCase()) ||
                        this.lastFocusedEl == null ||
                        (this.lastFocusedEl.tagName.toLowerCase() !== 'avl-icon-button' &&
                            this.lastFocusedEl !== buttonElements[buttonElements.length - 1]))) {
                        this.searchbarRef.nativeElement.focus();
                        event.preventDefault();
                    }
                }
                this.lastFocusedEl = event.target;
            });
        });
    }
};
AvlSolutionOverviewComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate$7([
    Input(),
    __metadata$7("design:type", Array)
], AvlSolutionOverviewComponent.prototype, "groups", void 0);
__decorate$7([
    Input(),
    __metadata$7("design:type", String)
], AvlSolutionOverviewComponent.prototype, "solutionName", void 0);
__decorate$7([
    Input(),
    __metadata$7("design:type", String)
], AvlSolutionOverviewComponent.prototype, "solutionIconUrl", void 0);
__decorate$7([
    Input(),
    __metadata$7("design:type", String)
], AvlSolutionOverviewComponent.prototype, "solutionSubtitle", void 0);
__decorate$7([
    Input(),
    __metadata$7("design:type", Boolean)
], AvlSolutionOverviewComponent.prototype, "showSearchBar", void 0);
__decorate$7([
    Output(),
    __metadata$7("design:type", Object)
], AvlSolutionOverviewComponent.prototype, "searchQueryChange", void 0);
__decorate$7([
    Output(),
    __metadata$7("design:type", Object)
], AvlSolutionOverviewComponent.prototype, "search", void 0);
__decorate$7([
    ViewChildren('itemElement'),
    __metadata$7("design:type", QueryList)
], AvlSolutionOverviewComponent.prototype, "buttonRefs", void 0);
__decorate$7([
    ViewChildren('group'),
    __metadata$7("design:type", QueryList)
], AvlSolutionOverviewComponent.prototype, "groupElementRefs", void 0);
__decorate$7([
    ViewChild('searchbar'),
    __metadata$7("design:type", ElementRef)
], AvlSolutionOverviewComponent.prototype, "searchbarRef", void 0);
__decorate$7([
    ViewChild('iconButtons'),
    __metadata$7("design:type", ElementRef)
], AvlSolutionOverviewComponent.prototype, "iconButtonsContainer", void 0);
__decorate$7([
    ViewChild('searchbarContainer'),
    __metadata$7("design:type", ElementRef)
], AvlSolutionOverviewComponent.prototype, "searchbarContainer", void 0);
__decorate$7([
    ViewChild('groupsContainer'),
    __metadata$7("design:type", ElementRef)
], AvlSolutionOverviewComponent.prototype, "groupsContainer", void 0);
__decorate$7([
    HostListener('window:resize'),
    __metadata$7("design:type", Function),
    __metadata$7("design:paramtypes", []),
    __metadata$7("design:returntype", void 0)
], AvlSolutionOverviewComponent.prototype, "onResize", null);
__decorate$7([
    HostListener('keydown', ['$event']),
    __metadata$7("design:type", Function),
    __metadata$7("design:paramtypes", [KeyboardEvent]),
    __metadata$7("design:returntype", void 0)
], AvlSolutionOverviewComponent.prototype, "onKeydownHandler", null);
AvlSolutionOverviewComponent = __decorate$7([
    Component({
        selector: 'avl-solution-overview',
        template: "<div class=\"container\">\r\n  <div class=\"top-bar\">\r\n    <div class=\"row\">\r\n      <img class=\"solution-logo\" src=\"{{solutionIconUrl}}\" />\r\n      <h1 class=\"solution-name\">{{solutionName}}</h1>\r\n      <div class=\"action-buttons\" #iconButtons>\r\n        <ng-content></ng-content>\r\n      </div>\r\n    </div>\r\n    <div class=\"row\" *ngIf=\"solutionSubtitle\">\r\n      <h2 class=\"solution-subtitle\">{{solutionSubtitle}}</h2>\r\n    </div>\r\n  </div>\r\n  <div class=\"outer-container\" [ngClass]=\"{'top-margin': contentHasScroll === false}\">\r\n    <div class=\"searchbar-container\" [ngClass]=\"gridWidthClass$ | async\" #searchbarContainer>\r\n      <avl-search-bar class=\"search-bar\" *ngIf=\"showSearchBar\"\r\n        #searchbar\r\n        always-open\r\n        (query-changed)=\"onQueryChange($event)\"\r\n        (search)=\"onSearch($event)\">\r\n      </avl-search-bar>\r\n    </div>\r\n    <div class=\"groups\" #groupsContainer>\r\n      <ng-container *ngFor=\"let group of groups\">\r\n        <div class=\"group-container\">\r\n          <div class=\"item-container\" #group [ngClass]=\"getMaxColumnsClass()\">\r\n            <ng-container *ngTemplateOutlet=\"groupTpl; context: { group: group }\"></ng-container>\r\n          </div>\r\n        </div>\r\n      </ng-container>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<ng-template #groupTpl let-group=\"group\">\r\n  <h2 class=\"group-name\" *ngIf=\"group.title\">{{group.title}}</h2>\r\n  <div class=\"text-container\" *ngIf=\"group.header\">{{group.header}}</div>\r\n  <ng-container *ngFor=\"let item of group.items\">\r\n    <ng-container *ngIf=\"item.route\">\r\n      <a class=\"item\"\r\n         #itemElement\r\n         [routerLink]=\"item.route\"\r\n         [ngClass]=\"{'with-description': group.description}\"\r\n         tabindex=\"0\">\r\n        <ng-container *ngTemplateOutlet=\"buttonContent; context: { item: item }\">\r\n        </ng-container>\r\n      </a>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"item.link\">\r\n      <a class=\"item\"\r\n         #itemElement\r\n         [attr.href]=\"item.link\"\r\n         [attr.target]=\"item.target\"\r\n         [attr.rel]=\"item.target == '_blank' ? 'noopener' : null\"\r\n         [ngClass]=\"{'with-description': group.description}\"\r\n         tabindex=\"0\">\r\n        <ng-container *ngTemplateOutlet=\"buttonContent; context: { item: item }\">\r\n        </ng-container>\r\n      </a>\r\n    </ng-container>\r\n  </ng-container>\r\n  <div class=\"text-container\" *ngIf=\"group.footer\">{{group.footer}}</div>\r\n</ng-template>\r\n\r\n<ng-template #buttonContent let-item=\"item\">\r\n  <div class=\"icon-container\" [ngClass]=\"{'no-icon-circle': item.noIconCircle}\">\r\n    <avl-icon\r\n      *ngIf=\"item.icon\"\r\n      class=\"item-icon\"\r\n      [icon]=\"item.icon\">\r\n    </avl-icon>\r\n    <img *ngIf=\"item.iconUrl\" class=\"item-icon\" src=\"{{item.iconUrl}}\" />\r\n  </div>\r\n  <div class=\"icon-label\"><span class=\"label\">{{item.label}}</span></div>\r\n  <div class=\"description\">\r\n    <span class=\"text\">\r\n      {{item.description}}\r\n    </span>\r\n  </div>\r\n</ng-template>\r\n",
        styles: [":host{--avl-solution-overview-background-color:var(--avl-background-1-color);--avl-solution-overview-background-image:auto;--avl-solution-overview-text-color:var(--avl-foreground-color);--avl-solution-overview-title-color:var(--avl-foreground-color);--avl-solution-overview-subtitle-color:var(--avl-foreground-medium-color);--avl-solution-overview-item-background-color:var(\r\n    --avl-container-background-color\r\n  );--avl-solution-overview-item-hover-color:var(\r\n    --avl-container-background-product-hover-color,\r\n  );--avl-solution-overview-item-focus-color:var(\r\n    --avl-container-background-product-focus-color\r\n  );--avl-solution-overview-item-pressed-color:var(\r\n    --avl-container-background-product-pressed-color\r\n  );--avl-solution-overview-item-icon-circle-color:var(--avl-product-color);--avl-solution-overview-item-icon-color:var(--avl-on-primary-color);--avl-solution-overview-item-icon-color-no-circle:var(--avl-hint-color);--avl-solution-overview-item-description-color:var(\r\n    --avl-foreground-medium-color\r\n  );--avl-solution-overview-item-icon-pressed-color:var(\r\n    --avl-solution-overview-item-icon-color\r\n  );display:block;width:100%;--item-width:184px;--item-margin:24px;--total-width:calc(var(--item-width) + var(--item-margin));--total-height:100vh;height:var(--total-height);font-family:var(--avl-font-family)}.container{background-image:var(--avl-solution-overview-background-image);background-size:cover;background-color:var(--avl-solution-overview-background-color);height:100%;display:flex;flex-direction:column}.groups{margin-bottom:24px;width:99%;overflow-y:auto}.group-container{display:flex;width:100%;justify-content:center;position:relative}.outer-container{display:flex;align-items:center;flex-direction:column;justify-content:center;overflow:hidden;height:100%}.outer-container.top-margin{margin-top:-50px}.searchbar-container{display:flex;justify-content:space-between}.search-bar{padding-right:20px}.external-link-container,.item-container{display:grid;width:100%;margin:0 12px 2px;padding-top:24px;grid-template-columns:repeat(auto-fill,var(--item-width)) [end];grid-gap:var(--item-margin);justify-content:center}.text-container{color:var(--avl-solution-overview-text-color);grid-column:1/end}.max-columns-1{max-width:calc(var(--total-width) * 1)}.max-columns-2{max-width:calc(var(--total-width) * 2)}.max-columns-3{max-width:calc(var(--total-width) * 3)}.max-columns-4{max-width:calc(var(--total-width) * 4)}.max-columns-5{max-width:calc(var(--total-width) * 5)}.grid-width-1{width:calc(var(--total-width) * 1)}.grid-width-2{width:calc(var(--total-width) * 2)}.grid-width-3{width:calc(var(--total-width) * 3)}.grid-width-4{width:calc(var(--total-width) * 4)}.grid-width-5{width:calc(var(--total-width) * 5)}.item{position:relative;display:flex;flex-direction:column;align-items:center;padding:12px;width:var(--item-width);height:112px;box-sizing:border-box;background-color:var(--avl-solution-overview-item-background-color);outline:0;box-shadow:var(--avl-box-shadow-1dp);transition:box-shadow .15s cubic-bezier(.4,0,.2,1)}.item.with-description{height:204px}.description{display:none}.item.with-description .description{overflow:hidden;display:block;font-weight:400;text-align:center;font-size:14px;line-height:16px;color:var(--avl-foreground-medium-color)}.item:active,.item:focus,.item:hover{box-shadow:var(--avl-box-shadow-8dp)}.item:focus{background-color:var(--avl-solution-overview-item-focus-color)}.item:hover{background-color:var(--avl-solution-overview-item-hover-color)}.item:active{background-color:var(--avl-solution-overview-item-pressed-color)}.icon-container{background:var(--avl-solution-overview-item-icon-circle-color);display:flex;align-items:center;justify-content:center;width:48px;height:48px;min-height:48px;border-radius:50%}.icon-container.no-icon-circle{background:0 0}.no-icon-circle .item-icon{--avl-icon-custom-color:var(--avl-solution-overview-item-icon-color-no-circle)}.item-icon{width:24px;height:24px;--avl-icon-custom-color:var(--avl-solution-overview-item-icon-color)}.item:active .item-icon{--avl-icon-custom-color:var(--avl-solution-overview-item-icon-pressed-color)}.icon-label{display:flex;justify-content:center;flex-flow:column;width:100%;font-size:14px;line-height:16px;margin:8px 0;font-weight:500;text-align:center;height:32px;color:var(--avl-solution-overview-text-color)}.group-name{margin:0 0 -8px;font-weight:400;font-size:24px;color:var(--avl-solution-overview-text-color);grid-column:1/end}.solution-name{font-weight:400;font-size:24px;margin:0 0 0 32px;height:32px;line-height:32px;flex:auto;color:var(--avl-solution-overview-title-color)}.solution-subtitle{font-weight:400;font-size:20px;margin:0 0 0 64px;color:var(--avl-solution-overview-subtitle-color)}.top-bar{display:flex;flex-direction:column;padding:32px 32px 0}.top-bar .row{display:flex;flex-direction:row;justify-content:space-between;align-items:flex-start;height:32px}.top-bar .row:last-child{margin-top:12px;height:24px}.action-buttons{margin-top:-8px;justify-self:flex-end;height:32px}.solution-logo{top:32px;left:32px;width:32px;height:32px}avl-search-bar{padding-top:20px}"]
    }),
    __metadata$7("design:paramtypes", [ChangeDetectorRef])
], AvlSolutionOverviewComponent);

var __decorate$8 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$8 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let AvlListExpanderComponent = class AvlListExpanderComponent {
    constructor() {
        /**
         * Boolean that changes modes between wide and narrow, false by default.
         */
        this.narrow = false;
        this._open = false;
        /**
         * Event that emits when the expander is opened or closed.
         * Sends boolean value of new open state.
         */
        this.openChange = new EventEmitter();
    }
    /**
     * Boolean that tells whether the expander is open or closed, expander is closed by default.
     */
    set open(value) {
        this._open = value;
        this.openChange.emit(this._open);
    }
    get open() {
        return this._open;
    }
    toggleClick() {
        this.open = !this.open;
    }
    /** @hidden */
    keyEvent(event) {
        const activeEl = document.activeElement;
        if (event.key === ' ' || event.key === 'Enter') {
            activeEl.click();
            return;
        }
    }
};
__decorate$8([
    Input(),
    __metadata$8("design:type", Boolean)
], AvlListExpanderComponent.prototype, "narrow", void 0);
__decorate$8([
    Input(),
    __metadata$8("design:type", Boolean),
    __metadata$8("design:paramtypes", [Boolean])
], AvlListExpanderComponent.prototype, "open", null);
__decorate$8([
    Output(),
    __metadata$8("design:type", Object)
], AvlListExpanderComponent.prototype, "openChange", void 0);
__decorate$8([
    HostListener('keydown', ['$event']),
    __metadata$8("design:type", Function),
    __metadata$8("design:paramtypes", [KeyboardEvent]),
    __metadata$8("design:returntype", void 0)
], AvlListExpanderComponent.prototype, "keyEvent", null);
AvlListExpanderComponent = __decorate$8([
    Component({
        selector: 'avl-list-expander',
        template: "<hr/>\r\n<div id=\"expander\">\r\n    <div  [ngClass]=\"narrow ? 'title-container-narrow' : 'title-container'\" tabindex=\"0\" (click)=\"toggleClick()\">\r\n        <div [ngClass]=\"narrow ? 'icon-narrow' : 'icon'\" *ngIf=\"!open\">\r\n            <avl-icon icon=\"hardware:keyboard-arrow-down\" id=\"starsIcon\"></avl-icon>\r\n        </div>\r\n        <div [ngClass]=\"narrow ? 'icon-narrow' : 'icon'\" *ngIf=\"open\">\r\n            <avl-icon icon=\"hardware:keyboard-arrow-up\" id=\"starsIcon\"></avl-icon>\r\n        </div>\r\n        <div [ngClass]=\"narrow ? 'title-narrow' : 'title'\">\r\n            <ng-content select=\"div[role=header]\"></ng-content>\r\n        </div>\r\n    </div>\r\n\r\n    <div *ngIf=\"open\" [ngClass]=\"narrow ? 'content-narrow' : 'content'\">\r\n        <ng-content select=\"div[role=content]\"></ng-content>\r\n    </div>\r\n</div>\r\n\r\n",
        styles: [".title-container:hover{background-color:var(--avl-list-expander-header-hover-color,var(--avl-ink-default-hover-color))}.title-container:focus{background-color:var(--avl-list-expander-header-focus-color,var(--avl-ink-default-focus-color));outline:0}.title-container:active{background-color:var(--avl-list-expander-header-pressed-color,var(--avl-ink-default-pressed-color))}.title-container{height:48px;display:flex;flex-flow:row;align-items:center;cursor:pointer}.title{font-size:17px;color:var(--avl-list-expander-title-color,var(--avl-foreground-color))}.icon{margin:12px 12px 12px 24px;height:24px}.content{margin:4px 24px}hr{display:block;border:0;border-top:1px solid var(--avl-list-expander-divider-color,var(--avl-divider-color));margin:0}avl-icon{--avl-icon-custom-color:var(--avl-list-expander-icon-color, var(--avl-hint-color))}.icon-narrow{margin:16px 24px 16px 16px;position:absolute;right:0;bottom:0;height:24px}.title-container-narrow{position:relative;height:56px;display:flex;flex-flow:row;align-items:center;cursor:pointer}.content-narrow{margin:0 24px 24px}.title-narrow{margin-left:24px;font-size:17px;margin-right:64px;white-space:nowrap;overflow:hidden}.title-container-narrow:hover{background-color:var(--avl-list-expander-header-hover-color,var(--avl-ink-default-hover-color))}.title-container-narrow:focus{background-color:var(--avl-list-expander-header-focus-color,var(--avl-ink-default-focus-color));outline:0}.title-container-narrow:active{background-color:var(--avl-list-expander-header-pressed-color,var(--avl-ink-default-pressed-color))}"]
    }),
    __metadata$8("design:paramtypes", [])
], AvlListExpanderComponent);

var __decorate$9 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const componentsAndDirectives = [
    AvlAppBarComponent,
    AvlAppBarItemComponent,
    AvlSideNavComponent,
    AvlAppLayoutComponent,
    AvlNoPaddingDirective,
    AvlLongPageComponent,
    AvlParagraphDirective,
    AvlSolutionOverviewComponent,
    AvlListExpanderComponent,
];
let AvlNavigationModule = class AvlNavigationModule {
};
AvlNavigationModule = __decorate$9([
    NgModule({
        imports: [
            CommonModule,
            RouterModule,
            AvlNgBindersModule
        ],
        declarations: componentsAndDirectives,
        schemas: [
            CUSTOM_ELEMENTS_SCHEMA
        ],
        exports: componentsAndDirectives
    })
], AvlNavigationModule);

class Paragraph {
    constructor(
    /**
     * Id/fragment of the paragraph header in the page.
     */
    id, 
    /**
     * Label of the paragraph shown in the side nav.
     */
    label) {
        this.id = id;
        this.label = label;
    }
}
class Params {
    constructor(
    /**
     * Name of the query parameter.
     */
    name, 
    /**
     * Value of the query parameter.
     */
    value) {
        this.name = name;
        this.value = value;
    }
}
class Page {
    constructor(
    /**
     * Label of the page shown in the side nav.
     */
    label, 
    /**
     * Route to the page.
     */
    route, 
    /**
     * Paragraphs of the long page.
     * It's a regular page if no paragraphs are defined.
     */
    paragraphs, 
    /**
     * Query parameters of the page.
     */
    params, expanded) {
        this.label = label;
        this.route = route;
        this.paragraphs = paragraphs;
        this.params = params;
        this.expanded = expanded;
        this.paragraphs = paragraphs ? paragraphs : [];
        this.params = params ? params : [];
    }
}
class TopLevelPage extends Page {
    constructor(
    /**
     * Label of the page shown in the side nav.
     */
    label, 
    /**
     * Route to the page.
     */
    route, 
    /**
     * Material icon name for the icon to show next to the label.
     * https://material.io/tools/icons
     * Only one of icon and iconUrl can be used. The other should be undefined.
     */
    icon, 
    /**
     * URL to the icon image to show next to the label.
     * Only one of icon and iconUrl can be used. The other should be undefined.
     */
    iconUrl, 
    /**
     * Paragraphs of the long page.
     * It's a regular page if no paragraphs are defined.
     */
    paragraphs, 
    /**
     * Query parameters of the page.
     */
    params, 
    /**
     * Sub pages of the top level page.
     */
    subItems, expanded) {
        super(label, route, paragraphs, params, expanded);
        this.icon = icon;
        this.iconUrl = iconUrl;
        this.paragraphs = paragraphs;
        this.params = params;
        this.subItems = subItems;
    }
}
class Group extends Page {
    constructor(
    /**
     * Label of the Group shown in the side nav.
     */
    label, 
    /**
     * Material icon name for the icon to show next to the label.
     * https://material.io/tools/icons
     * Only one of icon and iconUrl can be used. The other should be undefined.
     */
    icon, 
    /**
     * URL to the icon image to show next to the label.
     * Only one of icon and iconUrl can be used. The other should be undefined.
     */
    iconUrl, 
    /**
     * Sub pages of the group.
     */
    subItems, 
    /**
     * Route to the page.
     */
    route, 
    /**
 * Paragraphs of the long page.
 * It's a regular page if no paragraphs are defined.
 */
    paragraphs, params, expanded) {
        super(label, route, paragraphs, params, expanded);
        this.icon = icon;
        this.iconUrl = iconUrl;
        this.subItems = subItems;
        this.subItems = subItems ? subItems : [];
    }
}

/*
 * Public API Surface of navigation
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ApplicationReference, AvlAppBarComponent, AvlAppBarItemComponent, AvlAppLayoutComponent, AvlListExpanderComponent, AvlLongPageComponent, AvlNavigationModule, AvlNoPaddingDirective, AvlParagraphDirective, AvlSideNavComponent, AvlSolutionOverviewComponent, Group, KeyboardNavigator, MenuButtonItems, Page, Paragraph, Params, TopLevelPage };
//# sourceMappingURL=avl-ng-controls-navigation.js.map
