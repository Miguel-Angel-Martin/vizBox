(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/common/http'),require('@angular/router'),require('@angular/common'),exports, require('@angular/core'), require('rxjs'), require('@angular/common'), require('@angular/common/http'), require('@angular/router'), require('rxjs/operators'), require('crypto-js')) :
    typeof define === 'function' && define.amd ? define('@avl-ng-controls/auth', ['@angular/core','@angular/common/http','@angular/router','@angular/common','exports', '@angular/core', 'rxjs', '@angular/common', '@angular/common/http', '@angular/router', 'rxjs/operators', 'crypto-js'], factory) :
    (global = global || self, factory(global.ng.core,global.ng.common.http,global.ng.router,global.ng.common,(global['avl-ng-controls'] = global['avl-ng-controls'] || {}, global['avl-ng-controls'].auth = {}), global.ng.core, global.rxjs, global.ng.common, global.ng.common.http, global.ng.router, global.rxjs.operators, global.cryptoJs));
}(this, (function (ɵngcc0,ɵngcc1,ɵngcc2,ɵngcc3,exports, core, rxjs, common, http, router, operators, cryptoJs) { 'use strict';

    var AUTH_CONFIG = new core.InjectionToken(undefined);
    var INTERCEPTOR_BASE_PATHS = new core.InjectionToken(undefined);

    var AvlAuthService = /** @class */ (function () {
        function AvlAuthService() {
            /**
             * User data is held in this property
             */
            this.userSubject = new rxjs.BehaviorSubject(undefined);
            /**
             * Current user as Observable
             */
            this.user$ = this.userSubject.asObservable();
            /**
             * String holding error message in case user couldn't authenticate
             */
            this.errorMessageSubject = new rxjs.BehaviorSubject(undefined);
            /**
             * Error messsage in case failed authentication as Observable
             */
            this.errorMessage$ = this.errorMessageSubject.asObservable();
        }
        Object.defineProperty(AvlAuthService.prototype, "currentUser", {
            /**
             * Currently authenticated user data
             */
            get: function () {
                return this.userSubject.value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AvlAuthService.prototype, "errorMessage", {
            /**
             * Current error message for fail authentication
             * Undefined when user is logged in
             */
            get: function () {
                return this.errorMessageSubject.value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Use to clear error message after user is informed
         */
        AvlAuthService.prototype.clearErrorMessage = function () {
            this.errorMessageSubject.next(undefined);
        };
        return AvlAuthService;
    }());

    var TokensPending = /** @class */ (function () {
        function TokensPending(waiting, success) {
            this.waiting = waiting;
            this.success = success;
        }
        return TokensPending;
    }());

    var StorageNames;
    (function (StorageNames) {
        StorageNames["AccessToken"] = "access_token";
        StorageNames["AccessTokenExpiresAt"] = "access_token_expires_at";
        StorageNames["AccessTokenStoredAt"] = "access_token_stored_at";
        StorageNames["RefreshToken"] = "refresh_token";
        StorageNames["RefreshTokenExpiresAt"] = "refresh_token_expires_at";
        StorageNames["IdToken"] = "id_token";
        StorageNames["Roles"] = "roles";
        StorageNames["UserName"] = "username";
        StorageNames["Name"] = "name";
    })(StorageNames || (StorageNames = {}));

    var TokenStorage = /** @class */ (function () {
        function TokenStorage(prefix) {
            this.prefix = '';
            this.prefix = prefix !== null && prefix !== void 0 ? prefix : '';
        }
        TokenStorage.prototype.readUser = function () {
            var roles = JSON.parse(this.getItem(StorageNames.Roles));
            return {
                username: this.getItem(StorageNames.UserName),
                name: this.getItem(StorageNames.Name),
                access_token: this.getItem(StorageNames.AccessToken),
                access_token_expires: this.getNumber(StorageNames.AccessTokenExpiresAt),
                refresh_token: this.getItem(StorageNames.RefreshToken),
                refresh_token_expires: this.getNumber(StorageNames.RefreshTokenExpiresAt),
                id_token: this.getItem(StorageNames.IdToken),
                roles: roles
            };
        };
        TokenStorage.prototype.storeUser = function (user) {
            this.setItem(StorageNames.UserName, user.username);
            this.setItem(StorageNames.Name, user.name);
            this.setItem(StorageNames.AccessToken, user.access_token);
            this.setItem(StorageNames.AccessTokenExpiresAt, "" + user.access_token_expires);
            this.setItem(StorageNames.RefreshToken, user.refresh_token);
            this.setItem(StorageNames.RefreshTokenExpiresAt, "" + user.refresh_token_expires);
            this.setItem(StorageNames.IdToken, user.id_token);
            var rolesStr = JSON.stringify(user.roles);
            sessionStorage.setItem(StorageNames.Roles, "" + rolesStr);
        };
        TokenStorage.prototype.clearUser = function () {
            for (var name_1 in StorageNames) {
                if (StorageNames.hasOwnProperty(name_1)) {
                    this.removeItem(StorageNames[name_1]);
                }
            }
        };
        TokenStorage.prototype.getNumber = function (key) {
            return parseInt(this.getItem(key), 10);
        };
        TokenStorage.prototype.getItem = function (key) {
            return sessionStorage.getItem(this.prefix + key);
        };
        TokenStorage.prototype.setItem = function (key, value) {
            sessionStorage.setItem(this.prefix + key, value);
        };
        TokenStorage.prototype.removeItem = function (key) {
            sessionStorage.removeItem(this.prefix + key);
        };
        return TokenStorage;
    }());

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __param = (this && this.__param) || function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (this && this.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __read = (this && this.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread = (this && this.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
    };
    var __values = (this && this.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var AvlOidcCodeAuthService = /** @class */ (function (_super) {
        __extends(AvlOidcCodeAuthService, _super);
        function AvlOidcCodeAuthService(httpBackend, authConfig, router, loc) {
            var _this = _super.call(this) || this;
            _this.httpBackend = httpBackend;
            _this.authConfig = authConfig;
            _this.router = router;
            _this.loc = loc;
            // success will be set after tokens are successfully fetched or not
            _this.tokensPendingSubject = new rxjs.BehaviorSubject(new TokensPending(false));
            /**
             * Observable tracking if redirected from idb
             * Resolves to true on redirection, false otherwise
             */
            _this.redirectedFromLogIn = new rxjs.BehaviorSubject(undefined);
            _this.http = new http.HttpClient(_this.httpBackend);
            _this.tokensPending$ = _this.tokensPendingSubject.asObservable();
            _this.isLoggedIn$ = new rxjs.Observable(function (observer) {
                var tokensPendingState = _this.tokensPendingSubject.value;
                _this.tokensPending$.pipe(operators.distinctUntilKeyChanged('waiting'), operators.skipWhile(function (tokenPending) { return tokenPending.waiting !== false; }), operators.map(function (tokenPending) {
                    if (tokenPending.success != null) {
                        observer.next(tokenPending.success);
                    }
                }), operators.take(1)).subscribe();
                if (tokensPendingState.waiting !== true && tokensPendingState.success !== null) {
                    observer.next(_this.currentUser != null && _this.isAccessTokenValid());
                }
            });
            _this.storage = new TokenStorage(_this.authConfig.tokenPrefix);
            var user = _this.storage.readUser();
            if (_this.persistedUserInvalid(user)) {
                _this.clearUser();
            }
            else {
                _this.persistUser(user);
            }
            // if user is not logged in and pkce exists handle redirect from oidc server if possible
            if (_this.currentUser == null && _this.pkce) {
                _this.handleOidcRedirect();
            }
            else {
                _this.redirectedFromLogIn.next(Boolean(_this.currentUser));
            }
            return _this;
        }
        AvlOidcCodeAuthService.prototype.persistedUserInvalid = function (data) {
            return (data.username == null || data.access_token == null || data.access_token_expires < Date.now());
        };
        Object.defineProperty(AvlOidcCodeAuthService.prototype, "pkce", {
            get: function () {
                return this.storage.getItem('pkce') || undefined;
            },
            set: function (c) {
                if (c) {
                    this.storage.setItem('pkce', c);
                }
                else {
                    this.storage.removeItem('pkce');
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AvlOidcCodeAuthService.prototype, "nonce", {
            get: function () {
                return sessionStorage.getItem('nonce') || undefined;
            },
            set: function (c) {
                if (c) {
                    this.storage.setItem('nonce', c);
                }
                else {
                    this.storage.removeItem('nonce');
                }
            },
            enumerable: true,
            configurable: true
        });
        AvlOidcCodeAuthService.prototype.isAccessTokenValid = function () {
            return Date.now() < this.currentUser.access_token_expires;
        };
        AvlOidcCodeAuthService.prototype.persistUser = function (user) {
            if (!user) {
                this.clearUser();
                return;
            }
            this.storage.storeUser(user);
            this.userSubject.next(user);
        };
        AvlOidcCodeAuthService.prototype.clearUser = function () {
            this.storage.clearUser();
            this.userSubject.next(undefined);
        };
        /*
         * Checks if current url is redirect from oidc server and gets access token from the server.
         */
        AvlOidcCodeAuthService.prototype.handleOidcRedirect = function () {
            return __awaiter(this, void 0, void 0, function () {
                var pkce, urlParts, urlHash, first, last, urlPartSplit, query, queryCode, i, nonce, httpOptions, user, error_1;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            pkce = this.pkce;
                            this.pkce = undefined;
                            urlParts = this.loc.path(true).split('?', 2);
                            if (urlParts.length === 2) {
                                first = urlParts[1].lastIndexOf('#');
                                if (first !== -1) {
                                    last = urlParts[1].lastIndexOf('&');
                                    urlHash = urlParts[1].slice(first, last);
                                    urlPartSplit = urlParts[1].split('#', 2);
                                    urlParts[1] = urlParts[1].split('&').pop();
                                    urlParts[1] = urlPartSplit[0].concat('&').concat(urlParts[1]);
                                }
                            }
                            query = urlParts.length === 2 ? this.parseQueryString(urlParts[1]) : [];
                            for (i = query.length - 1; i >= 0; i--) {
                                if (query[i].key === 'code') {
                                    queryCode = query[i].value;
                                    query = __spread(query.slice(0, i), query.slice(i + 1));
                                    break;
                                }
                            }
                            if (!(urlParts.length === 2 && queryCode)) return [3 /*break*/, 4];
                            nonce = this.nonce;
                            this.nonce = undefined;
                            httpOptions = {
                                headers: new http.HttpHeaders({
                                    code: queryCode,
                                    verifier: pkce,
                                    nonce: nonce
                                })
                            };
                            this.updateTokensPending(new TokensPending(true));
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.http
                                    .post(this.authConfig.tokenUrl, {}, httpOptions)
                                    .pipe(operators.map(function (token) { return _this.readUserFromToken(token); }))
                                    .toPromise()];
                        case 2:
                            user = _a.sent();
                            this.persistUser(user);
                            this.updateTokensPending(new TokensPending(false, true));
                            return [3 /*break*/, 4];
                        case 3:
                            error_1 = _a.sent();
                            this.updateTokensPending(new TokensPending(false, false), error_1.message);
                            return [3 /*break*/, 4];
                        case 4:
                            if (urlHash) {
                                this.router.navigateByUrl("" + urlParts[0] + this.reconstructQueryParamString(query) + urlHash, { replaceUrl: true });
                                this.redirectedFromLogIn.next(true);
                            }
                            else {
                                this.router.navigateByUrl("" + urlParts[0] + this.reconstructQueryParamString(query), {
                                    replaceUrl: true
                                });
                                this.redirectedFromLogIn.next(Boolean(this.currentUser));
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        AvlOidcCodeAuthService.prototype.reloadPersistedUserData = function () {
            var user = this.storage.readUser();
            if (this.persistedUserInvalid(user)) {
                this.clearUser();
            }
            else {
                this.persistUser(user);
            }
        };
        AvlOidcCodeAuthService.prototype.reconstructQueryParamString = function (queryParams) {
            var e_1, _a;
            var s = '?';
            if (queryParams.length === 0) {
                return '';
            }
            try {
                for (var queryParams_1 = __values(queryParams), queryParams_1_1 = queryParams_1.next(); !queryParams_1_1.done; queryParams_1_1 = queryParams_1.next()) {
                    var q = queryParams_1_1.value;
                    if (s === '?') {
                        s += encodeURIComponent(q.key) + "=" + encodeURIComponent(q.value);
                    }
                    else {
                        s += "&" + encodeURIComponent(q.key) + "=" + encodeURIComponent(q.value);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (queryParams_1_1 && !queryParams_1_1.done && (_a = queryParams_1.return)) _a.call(queryParams_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return s;
        };
        AvlOidcCodeAuthService.prototype.updateTokensPending = function (state, errorMessage) {
            // the order here is important
            // errorMessage will be set before isLoggedIn becomes false
            if (state.waiting === false) {
                this.errorMessageSubject.next(errorMessage);
            }
            this.tokensPendingSubject.next(state);
        };
        AvlOidcCodeAuthService.prototype.readUserFromToken = function (token) {
            var _a;
            var accessTokenClaims = this.readClaimsFromToken(token.accesstoken);
            // Calculate actual expiry date for this machine
            var accessTokenStoredAt = Date.now(); // [ms]
            var accessTokenExpiresAt = accessTokenStoredAt + token.expiresIn * 1000;
            var refreshTokenClaims = this.readClaimsFromToken(token.refreshtoken);
            var refreshTokenExpiresAt = null;
            if (refreshTokenClaims) {
                // If time value is 0 token lasts indefinitely
                var refreshTokenExpiresIn = refreshTokenClaims['exp'] !== 0 ? refreshTokenClaims['exp'] - refreshTokenClaims['iat'] : 0;
                var refreshTokenStoredAt = accessTokenStoredAt;
                refreshTokenExpiresAt =
                    refreshTokenExpiresIn !== 0 ? refreshTokenStoredAt + refreshTokenExpiresIn * 1000 : 0;
            }
            var roles = accessTokenClaims === null || accessTokenClaims === void 0 ? void 0 : accessTokenClaims.roles;
            if (roles && this.hasRequiredRole(roles)) {
                this.storage.setItem(StorageNames.AccessTokenStoredAt, "" + accessTokenStoredAt);
                return {
                    username: accessTokenClaims.preferred_username,
                    name: (_a = accessTokenClaims.name) !== null && _a !== void 0 ? _a : accessTokenClaims.preferred_username,
                    access_token: token.accesstoken,
                    access_token_expires: accessTokenExpiresAt,
                    refresh_token: token.refreshtoken,
                    refresh_token_expires: refreshTokenExpiresAt,
                    id_token: token.idToken,
                    roles: roles
                };
            }
            else {
                throw new Error("Role " + this.authConfig.requiredRole + " not in claims");
            }
        };
        AvlOidcCodeAuthService.prototype.hasRequiredRole = function (roles) {
            return (!this.authConfig.requiredRole ||
                (this.authConfig.requiredRole && roles.indexOf(this.authConfig.requiredRole) !== -1));
        };
        /**
         * If needed, this method can be called to refresh tokens for current user
         * @returns Promise resolved with object containing new tokens
         */
        AvlOidcCodeAuthService.prototype.refreshTokens = function () {
            return __awaiter(this, void 0, void 0, function () {
                var httpOptions, user, error_2;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            httpOptions = {
                                headers: new http.HttpHeaders({
                                    grant_type: 'refresh_token',
                                    'refresh-token': this.storage.getItem(StorageNames.RefreshToken)
                                })
                            };
                            if (!this.authConfig.refreshUrl) {
                                throw new Error('refreshUrl missing in AuthConfig');
                            }
                            this.updateTokensPending(new TokensPending(true));
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.http
                                    .post(this.authConfig.refreshUrl, {}, httpOptions)
                                    .pipe(operators.map(function (token) { return _this.readUserFromToken(token); }))
                                    .toPromise()];
                        case 2:
                            user = _a.sent();
                            this.persistUser(user);
                            this.updateTokensPending(new TokensPending(false, true));
                            return [3 /*break*/, 4];
                        case 3:
                            error_2 = _a.sent();
                            this.updateTokensPending(new TokensPending(false, false), error_2.message);
                            throw error_2;
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Login user and redirect after successful authentication.
         * Custom auth services need to provide implementation
         * @param redirectUrl Url to redirect after successful authentication
         */
        AvlOidcCodeAuthService.prototype.login = function (redirectUrl) {
            location.href = this.generateLoginUrl(redirectUrl ? redirectUrl : location.href);
        };
        /**
         * Log out user and redirect after.
         * Custom auth services need to provide implementation
         * @param redirectUrl Url to redirect after logging out
         */
        AvlOidcCodeAuthService.prototype.logout = function (redirectUrl) {
            var logoutConfigSet = this.authConfig.logoutUrl != null || this.authConfig.logoutUrlParamIdToken != null;
            var user = this.userSubject.getValue();
            this.clearUser();
            if (!logoutConfigSet) {
                console.warn('User signed out locally, but logout request towards OIDC server not initiated since logoutUrl or logoutUrlParamIdToken not set in authConfig.');
                return;
            }
            var url = this.authConfig.logoutUrl + "?" + this.authConfig.logoutUrlParamIdToken + "=" + encodeURIComponent(user.id_token);
            if (this.authConfig.logoutUrlParamRedirect) {
                // Avoid any query parameters for the logout redirect url
                redirectUrl = redirectUrl !== null && redirectUrl !== void 0 ? redirectUrl : location.href.split('?')[0];
                url = url + "&" + this.authConfig.logoutUrlParamRedirect + "=" + encodeURIComponent(redirectUrl);
            }
            location.href = url;
        };
        AvlOidcCodeAuthService.prototype.generateLoginUrl = function (redirectUrl) {
            var redirect_b64 = '' + cryptoJs.enc.Base64.stringify(cryptoJs.enc.Utf8.parse(redirectUrl));
            // Generate a session value.
            var nonce = cryptoJs.lib.WordArray.random(16).toString();
            // Generate pkce
            var pkce = cryptoJs.lib.WordArray.random(32).toString();
            var bytes = cryptoJs.SHA256(pkce);
            var pkce_hash = cryptoJs.enc.Base64.stringify(bytes);
            // KeyCloak requires this - https://tools.ietf.org/html/rfc7636#appendix-A
            pkce_hash = pkce_hash.replace(/=/g, '');
            pkce_hash = pkce_hash.replace(/\+/g, '-');
            pkce_hash = pkce_hash.replace(/\//g, '_');
            this.pkce = pkce;
            this.nonce = nonce;
            var url = this.authConfig.loginUrl;
            url += '?' + this.authConfig.loginUrlParamRedirect + '=' + encodeURIComponent(redirect_b64);
            url += '&' + this.authConfig.loginUrlParamChallenge + '=' + encodeURIComponent(pkce_hash);
            url += '&' + this.authConfig.loginUrlParamNonce + '=' + encodeURIComponent(nonce);
            return url;
        };
        AvlOidcCodeAuthService.prototype.readClaimsFromToken = function (token) {
            if (!token.includes('.')) {
                // Token is not a valid JWT token
                return null;
            }
            var tokenParts = token.split('.');
            var claimsString = this.b64DecodeUnicode(tokenParts[1]);
            return JSON.parse(claimsString);
        };
        AvlOidcCodeAuthService.prototype.b64DecodeUnicode = function (str) {
            var base64 = str.replace(/\-/g, '+').replace(/\_/g, '/');
            return decodeURIComponent(atob(base64)
                .split('')
                .map(function (c) { return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2); })
                .join(''));
        };
        AvlOidcCodeAuthService.prototype.parseQueryString = function (queryString) {
            var e_2, _a;
            if (!queryString.length) {
                return [];
            }
            var queryDict = [];
            var pairs = queryString.split('&');
            try {
                for (var pairs_1 = __values(pairs), pairs_1_1 = pairs_1.next(); !pairs_1_1.done; pairs_1_1 = pairs_1.next()) {
                    var pair = pairs_1_1.value;
                    var index = pair.indexOf('=');
                    var key = void 0;
                    var value = void 0;
                    if (index === -1) {
                        key = pair;
                        value = undefined;
                    }
                    else {
                        key = pair.substr(0, index);
                        value = pair.substr(index + 1);
                    }
                    queryDict.push({
                        key: decodeURIComponent(key),
                        value: decodeURIComponent(value)
                    });
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (pairs_1_1 && !pairs_1_1.done && (_a = pairs_1.return)) _a.call(pairs_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return queryDict;
        };
        AvlOidcCodeAuthService.ctorParameters = function () { return [
            { type: http.HttpBackend },
            { type: undefined, decorators: [{ type: core.Inject, args: [AUTH_CONFIG,] }] },
            { type: router.Router },
            { type: common.Location }
        ]; };
        AvlOidcCodeAuthService = __decorate([ __param(1, core.Inject(AUTH_CONFIG)),
            __metadata("design:paramtypes", [http.HttpBackend, Object, router.Router, common.Location])
        ], AvlOidcCodeAuthService);
AvlOidcCodeAuthService.ɵfac = function AvlOidcCodeAuthService_Factory(t) { return new (t || AvlOidcCodeAuthService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpBackend), ɵngcc0.ɵɵinject(AUTH_CONFIG), ɵngcc0.ɵɵinject(ɵngcc2.Router), ɵngcc0.ɵɵinject(ɵngcc3.Location)); };
AvlOidcCodeAuthService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AvlOidcCodeAuthService, factory: function (t) { return AvlOidcCodeAuthService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlOidcCodeAuthService, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc1.HttpBackend }, { type: undefined, decorators: [{
                type: core.Inject,
                args: [AUTH_CONFIG]
            }] }, { type: ɵngcc2.Router }, { type: ɵngcc3.Location }]; }, null); })();
        return AvlOidcCodeAuthService;
    }(AvlAuthService));

    var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$1 = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __param$1 = (this && this.__param) || function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };
    var __values$1 = (this && this.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var AvlTokenInterceptor = /** @class */ (function () {
        function AvlTokenInterceptor(auth, basePaths) {
            this.auth = auth;
            this.basePaths = basePaths;
            this.enabled = true;
            for (var i in this.basePaths) {
                if (this.basePaths.hasOwnProperty(i)) {
                    this.basePaths[i] = this.basePaths[i].toLowerCase();
                }
            }
        }
        AvlTokenInterceptor.prototype.setAuthHeader = function (req) {
            var access_token = this.auth.currentUser.access_token;
            var header = "Bearer " + access_token;
            var headers = req.headers.set('Authorization', header);
            return req.clone({ headers: headers });
        };
        AvlTokenInterceptor.prototype.intercept = function (req, next) {
            var e_1, _a;
            var _this = this;
            if (!this.enabled) {
                return next.handle(req);
            }
            // check if we need to add token into request
            var url = req.url.toLowerCase();
            try {
                for (var _b = __values$1(this.basePaths), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var basePath = _c.value;
                    if (url.startsWith(basePath)) {
                        if (this.auth.currentUser != null) {
                            req = this.setAuthHeader(req);
                        }
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return next.handle(req).pipe(operators.catchError(function (err) {
                if (err.status === 401) {
                    return rxjs.from(_this.auth.refreshTokens()).pipe(operators.switchMap(function (_) { return next.handle(_this.setAuthHeader(req)); }), operators.catchError(function (_) { return rxjs.throwError(err); }));
                }
                return rxjs.throwError(err);
            }));
        };
        AvlTokenInterceptor.ctorParameters = function () { return [
            { type: AvlAuthService },
            { type: Array, decorators: [{ type: core.Inject, args: [INTERCEPTOR_BASE_PATHS,] }] }
        ]; };
        AvlTokenInterceptor = __decorate$1([ __param$1(1, core.Inject(INTERCEPTOR_BASE_PATHS)),
            __metadata$1("design:paramtypes", [AvlAuthService, Array])
        ], AvlTokenInterceptor);
AvlTokenInterceptor.ɵfac = function AvlTokenInterceptor_Factory(t) { return new (t || AvlTokenInterceptor)(ɵngcc0.ɵɵinject(AvlAuthService), ɵngcc0.ɵɵinject(INTERCEPTOR_BASE_PATHS)); };
AvlTokenInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AvlTokenInterceptor, factory: function (t) { return AvlTokenInterceptor.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlTokenInterceptor, [{
        type: core.Injectable
    }], function () { return [{ type: AvlAuthService }, { type: Array, decorators: [{
                type: core.Inject,
                args: [INTERCEPTOR_BASE_PATHS]
            }] }]; }, null); })();
        return AvlTokenInterceptor;
    }());

    exports.AUTH_CONFIG = AUTH_CONFIG;
    exports.AvlAuthService = AvlAuthService;
    exports.AvlOidcCodeAuthService = AvlOidcCodeAuthService;
    exports.AvlTokenInterceptor = AvlTokenInterceptor;
    exports.INTERCEPTOR_BASE_PATHS = INTERCEPTOR_BASE_PATHS;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=avl-ng-controls-auth.umd.js.map