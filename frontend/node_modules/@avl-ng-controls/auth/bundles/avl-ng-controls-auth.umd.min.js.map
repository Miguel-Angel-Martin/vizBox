{"version":3,"sources":["ng://@avl-ng-controls/auth/lib/services/storage-names.ts","ng://@avl-ng-controls/auth/lib/variables.ts","ng://@avl-ng-controls/auth/lib/services/avl-auth.service.ts","ng://@avl-ng-controls/auth/lib/services/token-pending.ts","ng://@avl-ng-controls/auth/lib/services/token-storage.ts","ng://@avl-ng-controls/auth/lib/services/avl-oidc-code-auth.service.ts","ng://@avl-ng-controls/auth/lib/services/avl-token.interceptor.ts"],"names":["StorageNames","AUTH_CONFIG","InjectionToken","undefined","INTERCEPTOR_BASE_PATHS","AvlAuthService","this","userSubject","BehaviorSubject","user$","asObservable","errorMessageSubject","errorMessage$","Object","defineProperty","prototype","value","clearErrorMessage","next","TokensPending","waiting","success","TokenStorage","prefix","readUser","roles","JSON","parse","getItem","Roles","username","UserName","name","Name","access_token","AccessToken","access_token_expires","getNumber","AccessTokenExpiresAt","refresh_token","RefreshToken","refresh_token_expires","RefreshTokenExpiresAt","id_token","IdToken","storeUser","user","setItem","rolesStr","stringify","sessionStorage","clearUser","name_1","hasOwnProperty","removeItem","key","parseInt","AvlOidcCodeAuthService","httpBackend","authConfig","router","loc","_this","_super","call","tokensPendingSubject","redirectedFromLogIn","http","HttpClient","tokensPending$","isLoggedIn$","Observable","observer","tokensPendingState","pipe","distinctUntilKeyChanged","skipWhile","tokenPending","map","take","subscribe","currentUser","isAccessTokenValid","storage","tokenPrefix","persistedUserInvalid","persistUser","pkce","handleOidcRedirect","Boolean","__extends","data","Date","now","c","urlParts","path","split","length","first","lastIndexOf","last","urlHash","slice","urlPartSplit","pop","concat","query","parseQueryString","i","queryCode","__spread","nonce","httpOptions","headers","HttpHeaders","code","verifier","updateTokensPending","post","tokenUrl","token","readUserFromToken","toPromise","_a","sent","error_1","message","navigateByUrl","reconstructQueryParamString","replaceUrl","reloadPersistedUserData","queryParams","s","queryParams_1","__values","queryParams_1_1","done","q","encodeURIComponent","state","errorMessage","accessTokenClaims","readClaimsFromToken","accesstoken","accessTokenStoredAt","accessTokenExpiresAt","expiresIn","refreshTokenClaims","refreshtoken","refreshTokenExpiresAt","refreshTokenExpiresIn","hasRequiredRole","AccessTokenStoredAt","preferred_username","idToken","Error","requiredRole","indexOf","refreshTokens","grant_type","refresh-token","refreshUrl","error_2","login","redirectUrl","location","href","generateLoginUrl","logout","logoutConfigSet","logoutUrl","logoutUrlParamIdToken","getValue","url","logoutUrlParamRedirect","console","warn","redirect_b64","CryptoJS.enc","Base64","Utf8","CryptoJS.lib","WordArray","random","toString","bytes","CryptoJS.SHA256","pkce_hash","replace","loginUrl","loginUrlParamRedirect","loginUrlParamChallenge","loginUrlParamNonce","includes","tokenParts","claimsString","b64DecodeUnicode","str","base64","decodeURIComponent","atob","charCodeAt","join","queryString","queryDict","pairs","pairs_1","pairs_1_1","pair","index","substr","push","HttpBackend","Inject","args","Router","Location","__decorate","Injectable","__param","AvlTokenInterceptor","auth","basePaths","enabled","toLowerCase","setAuthHeader","req","header","set","clone","intercept","handle","_b","_c","basePath","startsWith","catchError","err","status","from","switchMap","_","throwError","__decorate$1","Array"],"mappings":"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","sourcesContent":["export enum StorageNames {\r\n  AccessToken = 'access_token',\r\n  AccessTokenExpiresAt = 'access_token_expires_at',\r\n  AccessTokenStoredAt = 'access_token_stored_at',\r\n  RefreshToken = 'refresh_token',\r\n  RefreshTokenExpiresAt = 'refresh_token_expires_at',\r\n  IdToken = 'id_token',\r\n  Roles = 'roles',\r\n  UserName = 'username',\r\n  Name = 'name'\r\n}\r\n","import { InjectionToken } from '@angular/core';\r\n\r\nexport interface AuthConfig { \r\n  tokenUrl: string;\r\n  loginUrl: string;\r\n  refreshUrl?: string;\r\n  loginUrlParamRedirect: string;\r\n  loginUrlParamChallenge: string;\r\n  loginUrlParamNonce: string;\r\n  logoutUrl?: string;\r\n  logoutUrlParamIdToken?: string;\r\n  logoutUrlParamRedirect?: string;\r\n  requiredRole?: string;\r\n  tokenPrefix?: string;\r\n}\r\n\r\nexport const AUTH_CONFIG = new InjectionToken<AuthConfig>(undefined);\r\n\r\nexport const INTERCEPTOR_BASE_PATHS = new InjectionToken<string[]>(undefined);","import { Observable, BehaviorSubject } from 'rxjs';\r\nimport { User } from '../user.model';\r\nexport abstract class AvlAuthService {\r\n  /**\r\n   * User data is held in this property\r\n   */\r\n  protected userSubject = new BehaviorSubject<User>(undefined);\r\n\r\n  /**\r\n   * Current user as Observable\r\n   */\r\n  public user$: Observable<User> = this.userSubject.asObservable();\r\n\r\n  /**\r\n   * String holding error message in case user couldn't authenticate\r\n   */\r\n  protected errorMessageSubject = new BehaviorSubject<string>(undefined);\r\n\r\n  /**\r\n   * Error messsage in case failed authentication as Observable\r\n   */\r\n  public errorMessage$: Observable<string> = this.errorMessageSubject.asObservable();\r\n\r\n  /**\r\n   * Observable tracking authenticated state\r\n   * Resolves to true on successful log in, false otherwise\r\n   */\r\n  public abstract isLoggedIn$: Observable<boolean>;\r\n\r\n  /**\r\n   * Observable tracking if redirected from idb\r\n   * Resolves to true on redirection, false otherwise\r\n   */\r\n  public abstract redirectedFromLogIn: BehaviorSubject<boolean>;\r\n\r\n  /**\r\n   * Login user and redirect after successful authentication.\r\n   * Custom auth services need to provide implementation\r\n   * @param redirectUrl Url to redirect after succesful authentication\r\n   */\r\n  public abstract login(redirectUrl?: string): void;\r\n\r\n  /**\r\n  * If tokens are peristed in local storage, set current user data\r\n  */\r\n  public abstract reloadPersistedUserData(): void;\r\n\r\n  /**\r\n   * Log out user and redirect after.\r\n   * Custom auth services need to provide implementation\r\n   * @param redirectUrl Url to redirect after logging out\r\n   */\r\n  public abstract logout(redirectUrl?: string): void;\r\n\r\n  /**\r\n   * Currently authenticated user data\r\n   */\r\n  public get currentUser(): User {\r\n    return this.userSubject.value;\r\n  }\r\n\r\n  /**\r\n   * Current error message for fail authentication\r\n   * Undefined when user is logged in\r\n   */\r\n  public get errorMessage(): string {\r\n    return this.errorMessageSubject.value;\r\n  }\r\n\r\n  /**\r\n   * Use to clear error message after user is informed\r\n   */\r\n  public clearErrorMessage() {\r\n    this.errorMessageSubject.next(undefined);\r\n  }\r\n\r\n  /**\r\n   * For token based authetication.\r\n   * Provide functionality to refresh tokens\r\n   */\r\n  public refreshTokens?(): Promise<any>;\r\n}\r\n","export class TokensPending {\r\n  success?: boolean;\r\n  waiting?: boolean;\r\n  constructor(waiting?: boolean, success?: boolean) {\r\n    this.waiting = waiting;\r\n    this.success = success;\r\n  }\r\n}\r\n","import { User } from '../user.model';\r\nimport { StorageNames } from './storage-names';\r\n\r\nexport class TokenStorage {\r\n  private prefix = '';\r\n\r\n  constructor(prefix?: string) {\r\n    this.prefix = prefix ?? '';\r\n  }\r\n\r\n  readUser(): User {\r\n    const roles = JSON.parse(this.getItem(StorageNames.Roles)) as string[];\r\n    return {\r\n      username: this.getItem(StorageNames.UserName),\r\n      name: this.getItem(StorageNames.Name),\r\n      access_token: this.getItem(StorageNames.AccessToken),\r\n      access_token_expires: this.getNumber(StorageNames.AccessTokenExpiresAt),\r\n      refresh_token: this.getItem(StorageNames.RefreshToken),\r\n      refresh_token_expires: this.getNumber(StorageNames.RefreshTokenExpiresAt),\r\n      id_token: this.getItem(StorageNames.IdToken),\r\n      roles\r\n    };\r\n  }\r\n\r\n  storeUser(user: User) {\r\n    this.setItem(StorageNames.UserName, user.username);\r\n    this.setItem(StorageNames.Name, user.name);\r\n    this.setItem(StorageNames.AccessToken, user.access_token);\r\n    this.setItem(StorageNames.AccessTokenExpiresAt, `${user.access_token_expires}`);\r\n    this.setItem(StorageNames.RefreshToken, user.refresh_token);\r\n    this.setItem(StorageNames.RefreshTokenExpiresAt, `${user.refresh_token_expires}`);\r\n    this.setItem(StorageNames.IdToken, user.id_token);\r\n\r\n    const rolesStr = JSON.stringify(user.roles);\r\n    sessionStorage.setItem(StorageNames.Roles, `${rolesStr}`);\r\n  }\r\n\r\n  clearUser() {\r\n    for (const name in StorageNames) {\r\n      if (StorageNames.hasOwnProperty(name)) {\r\n        this.removeItem(StorageNames[name]);\r\n      }\r\n    }\r\n  }\r\n\r\n  private getNumber(key: string): number {\r\n    return parseInt(this.getItem(key), 10);\r\n  }\r\n\r\n  getItem(key: string): string {\r\n    return sessionStorage.getItem(this.prefix + key);\r\n  }\r\n\r\n  setItem(key: string, value: string): void {\r\n    sessionStorage.setItem(this.prefix + key, value);\r\n  }\r\n\r\n  removeItem(key: string): void {\r\n    sessionStorage.removeItem(this.prefix + key);\r\n  }\r\n}\r\n","import { Injectable, Inject } from '@angular/core';\r\nimport { Location } from '@angular/common';\r\nimport { HttpBackend, HttpClient, HttpHeaders } from '@angular/common/http';\r\nimport { Observable, BehaviorSubject } from 'rxjs';\r\nimport { Router } from '@angular/router';\r\nimport { map, take, distinctUntilKeyChanged, skipWhile } from 'rxjs/operators';\r\n\r\nimport * as CryptoJS from 'crypto-js';\r\n\r\nimport { User } from '../user.model';\r\nimport { AvlAuthService } from './avl-auth.service';\r\nimport { AUTH_CONFIG, AuthConfig } from '../variables';\r\nimport { TokensPending } from './token-pending';\r\nimport { TokenStorage } from './token-storage';\r\nimport { TokenResponse } from './token-response';\r\nimport { StorageNames } from './storage-names';\r\nimport { TokenClaims } from './token-claims';\r\n\r\n\r\n@Injectable()\r\nexport class AvlOidcCodeAuthService extends AvlAuthService {\r\n  // success will be set after tokens are successfully fetched or not\r\n  private tokensPendingSubject = new BehaviorSubject<TokensPending>(new TokensPending(false));\r\n\r\n  /**\r\n   * When fetching tokens, this observable changes\r\n   * @returns Observable with following context:\r\n   * - waiting - if true, request for new tokens is made, this happens on initial authentication and on refreshTokens\r\n   * - success - true for successful authentication\r\n   */\r\n  public tokensPending$: Observable<TokensPending>;\r\n\r\n  /**\r\n   * Observable tracking authenticated state\r\n   * Resolves to true on successful log in, false otherwise\r\n   */\r\n  public isLoggedIn$: Observable<boolean>;\r\n  \r\n  /**\r\n   * Observable tracking if redirected from idb\r\n   * Resolves to true on redirection, false otherwise\r\n   */\r\n  public redirectedFromLogIn = new BehaviorSubject<boolean>(undefined);\r\n\r\n  private http: HttpClient;\r\n  private storage: TokenStorage;\r\n\r\n  constructor(private httpBackend: HttpBackend, @Inject(AUTH_CONFIG) private authConfig: AuthConfig,\r\n    private router: Router, private loc: Location) {\r\n    super();\r\n\r\n    this.http = new HttpClient(this.httpBackend);\r\n\r\n    this.tokensPending$ = this.tokensPendingSubject.asObservable();\r\n    this.isLoggedIn$ = new Observable<boolean>(observer => {\r\n      const tokensPendingState = this.tokensPendingSubject.value;\r\n      this.tokensPending$.pipe(\r\n        distinctUntilKeyChanged('waiting'),\r\n        skipWhile(tokenPending => tokenPending.waiting !== false),\r\n        map(tokenPending => {\r\n          if (tokenPending.success != null) {\r\n            observer.next(tokenPending.success);\r\n          }\r\n        }), take(1)).subscribe();\r\n      if (tokensPendingState.waiting !== true && tokensPendingState.success !== null) {\r\n        observer.next(this.currentUser != null && this.isAccessTokenValid());\r\n      }\r\n    });\r\n\r\n    this.storage = new TokenStorage(this.authConfig.tokenPrefix);\r\n    const user = this.storage.readUser();\r\n    \r\n    if (this.persistedUserInvalid(user)) {\r\n      this.clearUser();\r\n    } else {\r\n      this.persistUser(user);\r\n    }\r\n\r\n    // if user is not logged in and pkce exists handle redirect from oidc server if possible\r\n    if (this.currentUser == null && this.pkce) {\r\n      this.handleOidcRedirect();\r\n    } else {\r\n      this.redirectedFromLogIn.next(Boolean(this.currentUser));\r\n    }\r\n  } \r\n\r\n  \r\n  private persistedUserInvalid(data: Partial<User>): boolean {\r\n    return (\r\n      data.username == null || data.access_token == null || data.access_token_expires < Date.now()\r\n    );\r\n  }\r\n\r\n  private get pkce(): string | undefined {\r\n    return this.storage.getItem('pkce') || undefined;\r\n  }\r\n  private set pkce(c: string | undefined) {\r\n    if (c) {\r\n      this.storage.setItem('pkce', c);\r\n    } else {\r\n      this.storage.removeItem('pkce');\r\n    }\r\n  }\r\n\r\n  private get nonce(): string | undefined {\r\n    return sessionStorage.getItem('nonce') || undefined;\r\n  }\r\n  private set nonce(c: string | undefined) {\r\n    if (c) {\r\n      this.storage.setItem('nonce', c);\r\n    } else {\r\n      this.storage.removeItem('nonce');\r\n    }\r\n  }\r\n\r\n  private isAccessTokenValid(): boolean {\r\n    return Date.now() < this.currentUser.access_token_expires;\r\n  }\r\n\r\n  private persistUser(user?: User): void {\r\n    if (!user) {\r\n      this.clearUser();\r\n      return;\r\n    }\r\n    this.storage.storeUser(user);\r\n    this.userSubject.next(user);\r\n  }\r\n\r\n  private clearUser(): void {\r\n    this.storage.clearUser();\r\n    this.userSubject.next(undefined);\r\n  }\r\n\r\n  /*\r\n   * Checks if current url is redirect from oidc server and gets access token from the server.\r\n   */\r\n  private async handleOidcRedirect() {\r\n    const pkce = this.pkce;\r\n    this.pkce = undefined;\r\n\r\n    const urlParts = this.loc.path(true).split('?', 2);\r\n    let urlHash: string;\r\n    let first: number;\r\n    let last: number;\r\n    let urlPartSplit: string[];\r\n\r\n    if (urlParts.length === 2) {\r\n      first = urlParts[1].lastIndexOf('#');\r\n      if (first !== -1) {\r\n        last = urlParts[1].lastIndexOf('&');\r\n        urlHash = urlParts[1].slice(first, last);\r\n        urlPartSplit = urlParts[1].split('#', 2);\r\n        urlParts[1] = urlParts[1].split('&').pop();\r\n        urlParts[1] = urlPartSplit[0].concat('&').concat(urlParts[1]);\r\n      }\r\n    }\r\n\r\n    let query = urlParts.length === 2 ? this.parseQueryString(urlParts[1]) : [];\r\n    let queryCode: string;\r\n    for (let i = query.length - 1; i >= 0; i--) {\r\n      if (query[i].key === 'code') {\r\n        queryCode = query[i].value;\r\n        query = [...query.slice(0, i), ...query.slice(i + 1)];\r\n        break;\r\n      }\r\n    }\r\n    if (urlParts.length === 2 && queryCode) {\r\n      const nonce = this.nonce;\r\n      this.nonce = undefined;\r\n\r\n      const httpOptions = {\r\n        headers: new HttpHeaders({\r\n          code: queryCode,\r\n          verifier: pkce,\r\n          nonce: nonce\r\n        })\r\n      };\r\n\r\n      this.updateTokensPending(new TokensPending(true));\r\n      try {\r\n        const user = await this.http\r\n          .post<TokenResponse>(this.authConfig.tokenUrl, {}, httpOptions)\r\n          .pipe(map(token => this.readUserFromToken(token)))\r\n          .toPromise();\r\n        this.persistUser(user);\r\n        this.updateTokensPending(new TokensPending(false, true));\r\n      } catch (error) {\r\n        this.updateTokensPending(new TokensPending(false, false), error.message);\r\n      }\r\n    }\r\n\r\n    if (urlHash) {\r\n      this.router.navigateByUrl(\r\n        `${urlParts[0]}${this.reconstructQueryParamString(query)}${urlHash}`,\r\n        { replaceUrl: true }\r\n      );\r\n      this.redirectedFromLogIn.next(true);\r\n    } else {\r\n      this.router.navigateByUrl(`${urlParts[0]}${this.reconstructQueryParamString(query)}`, {\r\n        replaceUrl: true\r\n      });\r\n      this.redirectedFromLogIn.next(Boolean(this.currentUser));\r\n    }\r\n  }\r\n\r\n  public reloadPersistedUserData() {\r\n    const user = this.storage.readUser();\r\n    \r\n    if (this.persistedUserInvalid(user)) {\r\n      this.clearUser();\r\n    } else {\r\n      this.persistUser(user);\r\n    }\r\n  }\r\n  private reconstructQueryParamString(queryParams: { key: string; value: string }[]): string {\r\n    let s = '?';\r\n    if (queryParams.length === 0) {\r\n      return '';\r\n    }\r\n    for (const q of queryParams) {\r\n      if (s === '?') {\r\n        s += `${encodeURIComponent(q.key)}=${encodeURIComponent(q.value)}`;\r\n      } else {\r\n        s += `&${encodeURIComponent(q.key)}=${encodeURIComponent(q.value)}`;\r\n      }\r\n    }\r\n    return s;\r\n  }\r\n\r\n  private updateTokensPending(\r\n    state: TokensPending,\r\n    errorMessage?: string\r\n  ) {\r\n    // the order here is important\r\n    // errorMessage will be set before isLoggedIn becomes false\r\n    if (state.waiting === false) {\r\n      this.errorMessageSubject.next(errorMessage);\r\n    }\r\n    this.tokensPendingSubject.next(state);\r\n  }\r\n\r\n  private readUserFromToken(token: TokenResponse): User {\r\n    const accessTokenClaims = this.readClaimsFromToken(token.accesstoken);\r\n\r\n    // Calculate actual expiry date for this machine\r\n    const accessTokenStoredAt = Date.now(); // [ms]\r\n    const accessTokenExpiresAt = accessTokenStoredAt + token.expiresIn * 1000;\r\n\r\n    const refreshTokenClaims = this.readClaimsFromToken(token.refreshtoken);\r\n    let refreshTokenExpiresAt = null;\r\n    if (refreshTokenClaims) {\r\n      // If time value is 0 token lasts indefinitely\r\n      const refreshTokenExpiresIn =\r\n        refreshTokenClaims['exp'] !== 0 ? refreshTokenClaims['exp'] - refreshTokenClaims['iat'] : 0;\r\n      const refreshTokenStoredAt = accessTokenStoredAt;\r\n      refreshTokenExpiresAt =\r\n        refreshTokenExpiresIn !== 0 ? refreshTokenStoredAt + refreshTokenExpiresIn * 1000 : 0;\r\n    }\r\n\r\n    const roles = accessTokenClaims?.roles as string[];\r\n    if (roles && this.hasRequiredRole(roles)) {\r\n      this.storage.setItem(StorageNames.AccessTokenStoredAt, `${accessTokenStoredAt}`);\r\n      return {\r\n        username: accessTokenClaims.preferred_username,\r\n        name: accessTokenClaims.name ?? accessTokenClaims.preferred_username,\r\n        access_token: token.accesstoken,\r\n        access_token_expires: accessTokenExpiresAt,\r\n        refresh_token: token.refreshtoken,\r\n        refresh_token_expires: refreshTokenExpiresAt,\r\n        id_token: token.idToken,\r\n        roles: roles\r\n      } as User;\r\n    } else {\r\n      throw new Error(`Role ${this.authConfig.requiredRole} not in claims`);\r\n    }\r\n  }\r\n\r\n  private hasRequiredRole(roles: string[]) {\r\n    return (\r\n      !this.authConfig.requiredRole ||\r\n      (this.authConfig.requiredRole && roles.indexOf(this.authConfig.requiredRole) !== -1)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * If needed, this method can be called to refresh tokens for current user\r\n   * @returns Promise resolved with object containing new tokens\r\n   */\r\n  public async refreshTokens(): Promise<any> {\r\n    const httpOptions = {\r\n      headers: new HttpHeaders({\r\n        grant_type: 'refresh_token',\r\n        'refresh-token': this.storage.getItem(StorageNames.RefreshToken)\r\n      })\r\n    };\r\n\r\n    if (!this.authConfig.refreshUrl) {\r\n      throw new Error('refreshUrl missing in AuthConfig');\r\n    }\r\n    this.updateTokensPending(new TokensPending(true));\r\n\r\n    try {\r\n      const user = await this.http\r\n        .post<TokenResponse>(this.authConfig.refreshUrl, {}, httpOptions)\r\n        .pipe(map(token => this.readUserFromToken(token)))\r\n        .toPromise();\r\n      this.persistUser(user);\r\n      this.updateTokensPending(new TokensPending(false, true));\r\n    } catch (error) {\r\n      this.updateTokensPending(new TokensPending(false, false), error.message);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Login user and redirect after successful authentication.\r\n   * Custom auth services need to provide implementation\r\n   * @param redirectUrl Url to redirect after successful authentication\r\n   */\r\n  login(redirectUrl?: string): void {\r\n    location.href = this.generateLoginUrl(redirectUrl ? redirectUrl : location.href);\r\n  }\r\n\r\n  /**\r\n   * Log out user and redirect after.\r\n   * Custom auth services need to provide implementation\r\n   * @param redirectUrl Url to redirect after logging out\r\n   */\r\n  logout(redirectUrl?: string): void {\r\n    const logoutConfigSet =\r\n      this.authConfig.logoutUrl != null || this.authConfig.logoutUrlParamIdToken != null;\r\n    const user = this.userSubject.getValue();\r\n    this.clearUser();\r\n    if (!logoutConfigSet) {\r\n      console.warn(\r\n        'User signed out locally, but logout request towards OIDC server not initiated since logoutUrl or logoutUrlParamIdToken not set in authConfig.'\r\n      );\r\n      return;\r\n    }\r\n    let url = `${this.authConfig.logoutUrl}?${\r\n      this.authConfig.logoutUrlParamIdToken\r\n    }=${encodeURIComponent(user.id_token)}`;\r\n    if (this.authConfig.logoutUrlParamRedirect) {\r\n      // Avoid any query parameters for the logout redirect url\r\n      redirectUrl = redirectUrl ?? location.href.split('?')[0];\r\n      url = `${url}&${this.authConfig.logoutUrlParamRedirect}=${encodeURIComponent(redirectUrl)}`;\r\n    }\r\n    location.href = url;\r\n  }\r\n\r\n  private generateLoginUrl(redirectUrl: string): string {\r\n    const redirect_b64 = '' + CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(redirectUrl));\r\n\r\n    // Generate a session value.\r\n    const nonce = CryptoJS.lib.WordArray.random(16).toString();\r\n\r\n    // Generate pkce\r\n    const pkce = CryptoJS.lib.WordArray.random(32).toString();\r\n    const bytes = CryptoJS.SHA256(pkce) as CryptoJS.WordArray;\r\n    let pkce_hash = CryptoJS.enc.Base64.stringify(bytes);\r\n\r\n    // KeyCloak requires this - https://tools.ietf.org/html/rfc7636#appendix-A\r\n    pkce_hash = pkce_hash.replace(/=/g, '');\r\n    pkce_hash = pkce_hash.replace(/\\+/g, '-');\r\n    pkce_hash = pkce_hash.replace(/\\//g, '_');\r\n\r\n    this.pkce = pkce;\r\n    this.nonce = nonce;\r\n\r\n    let url = this.authConfig.loginUrl;\r\n    url += '?' + this.authConfig.loginUrlParamRedirect + '=' + encodeURIComponent(redirect_b64);\r\n    url += '&' + this.authConfig.loginUrlParamChallenge + '=' + encodeURIComponent(pkce_hash);\r\n    url += '&' + this.authConfig.loginUrlParamNonce + '=' + encodeURIComponent(nonce);\r\n    return url;\r\n  }\r\n\r\n  private readClaimsFromToken(token: string): TokenClaims | null {\r\n    if (!token.includes('.')) {\r\n      // Token is not a valid JWT token\r\n      return null;\r\n    }\r\n    const tokenParts = token.split('.');\r\n    const claimsString = this.b64DecodeUnicode(tokenParts[1]);\r\n    return JSON.parse(claimsString) as TokenClaims;\r\n  }\r\n\r\n  private b64DecodeUnicode(str: string): string {\r\n    const base64 = str.replace(/\\-/g, '+').replace(/\\_/g, '/');\r\n\r\n    return decodeURIComponent(\r\n      atob(base64)\r\n        .split('')\r\n        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\r\n        .join('')\r\n    );\r\n  }\r\n\r\n  private parseQueryString(queryString: string): { key: string; value: string }[] {\r\n    if (!queryString.length) {\r\n      return [];\r\n    }\r\n    const queryDict = [];\r\n    const pairs = queryString.split('&');\r\n    for (const pair of pairs) {\r\n      const index = pair.indexOf('=');\r\n      let key: string;\r\n      let value: string;\r\n      if (index === -1) {\r\n        key = pair;\r\n        value = undefined;\r\n      } else {\r\n        key = pair.substr(0, index);\r\n        value = pair.substr(index + 1);\r\n      }\r\n      queryDict.push({\r\n        key: decodeURIComponent(key),\r\n        value: decodeURIComponent(value)\r\n      });\r\n    }\r\n    return queryDict;\r\n  }\r\n}\r\n","import { Injectable, Inject } from '@angular/core';\r\nimport {\r\n  HttpRequest,\r\n  HttpHandler,\r\n  HttpEvent,\r\n  HttpInterceptor,\r\n  HttpErrorResponse\r\n} from '@angular/common/http';\r\nimport { Observable, from, throwError } from 'rxjs';\r\nimport { catchError, switchMap } from 'rxjs/operators';\r\n\r\nimport { AvlAuthService } from './avl-auth.service';\r\nimport { INTERCEPTOR_BASE_PATHS } from '../variables';\r\n\r\n@Injectable()\r\nexport class AvlTokenInterceptor implements HttpInterceptor {\r\n  protected enabled = true;\r\n\r\n  constructor(\r\n    public auth: AvlAuthService,\r\n    @Inject(INTERCEPTOR_BASE_PATHS) protected basePaths: string[]\r\n  ) {\r\n    for (const i in this.basePaths) {\r\n      if (this.basePaths.hasOwnProperty(i)) {\r\n        this.basePaths[i] = this.basePaths[i].toLowerCase();\r\n      }\r\n    }\r\n  }\r\n\r\n  private setAuthHeader(req: HttpRequest<any>): HttpRequest<any> {\r\n    const access_token = this.auth.currentUser.access_token;\r\n    const header = `Bearer ${access_token}`;\r\n    const headers = req.headers.set('Authorization', header);\r\n\r\n    return req.clone({ headers });\r\n  }\r\n\r\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\r\n    if (!this.enabled) {\r\n      return next.handle(req);\r\n    }\r\n\r\n    // check if we need to add token into request\r\n    const url = req.url.toLowerCase();\r\n    for (const basePath of this.basePaths) {\r\n      if (url.startsWith(basePath)) {\r\n        if (this.auth.currentUser != null) {\r\n          req = this.setAuthHeader(req);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    return next.handle(req).pipe(\r\n      catchError((err: HttpErrorResponse) => {\r\n        if (err.status === 401) {\r\n          return from(this.auth.refreshTokens()).pipe(\r\n            switchMap(_ => next.handle(this.setAuthHeader(req))),\r\n            catchError(_ => throwError(err))\r\n          );\r\n        }\r\n        return throwError(err);\r\n      })\r\n    );\r\n  }\r\n}\r\n"]}