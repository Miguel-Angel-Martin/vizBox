{"version":3,"sources":["ng://@avl-ng-controls/auth/lib/services/storage-names.ts","ng://@avl-ng-controls/auth/lib/variables.ts","ng://@avl-ng-controls/auth/lib/services/avl-auth.service.ts","ng://@avl-ng-controls/auth/lib/services/token-pending.ts","ng://@avl-ng-controls/auth/lib/services/token-storage.ts","ng://@avl-ng-controls/auth/lib/services/avl-oidc-code-auth.service.ts","ng://@avl-ng-controls/auth/lib/services/avl-token.interceptor.ts"],"names":["StorageNames","AUTH_CONFIG","InjectionToken","undefined","INTERCEPTOR_BASE_PATHS","AvlAuthService","this","userSubject","BehaviorSubject","user$","asObservable","errorMessageSubject","errorMessage$","Object","defineProperty","prototype","value","clearErrorMessage","next","TokensPending","waiting","success","TokenStorage","prefix","readUser","roles","JSON","parse","getItem","Roles","username","UserName","name","Name","access_token","AccessToken","access_token_expires","getNumber","AccessTokenExpiresAt","access_token_stored","AccessTokenStoredAt","refresh_token","RefreshToken","refresh_token_expires","RefreshTokenExpiresAt","id_token","IdToken","storeUser","user","setItem","rolesStr","stringify","sessionStorage","clearUser","name_1","hasOwnProperty","removeItem","key","parseInt","AvlOidcCodeAuthService","httpBackend","authConfig","router","loc","_this","_super","call","tokensPendingSubject","redirectedFromLogIn","http","HttpClient","tokensPending$","isLoggedIn$","Observable","observer","tokensPendingState","pipe","distinctUntilKeyChanged","skipWhile","tokenPending","map","take","subscribe","currentUser","isAccessTokenValid","storage","tokenPrefix","isUserInvalid","persistUser","pkce","handleOidcRedirect","Boolean","__extends","data","Date","now","c","urlParts","path","split","length","first","lastIndexOf","last","urlHash","slice","urlPartSplit","pop","concat","query","parseQueryString","i","queryCode","__spread","nonce","httpOptions","headers","HttpHeaders","code","verifier","updateTokensPending","post","tokenUrl","token","readUserFromToken","toPromise","_a","sent","error_1","message","navigateByUrl","reconstructQueryParamString","replaceUrl","reloadPersistedUserData","queryParams","s","queryParams_1","__values","queryParams_1_1","done","q","encodeURIComponent","state","errorMessage","accessTokenClaims","readClaimsFromToken","accesstoken","accessTokenStoredAt","accessTokenExpiresAt","expiresIn","refreshTokenClaims","refreshtoken","refreshTokenExpiresAt","refreshTokenExpiresIn","preferred_username","idToken","refreshUserIfNeeded","refreshTokens","_b","logout","grant_type","refresh-token","refreshUrl","Error","error_2","login","redirectUrl","location","href","generateLoginUrl","logoutUrl","console","warn","catchError","error","onLogout","redirectIfNeeded","navigateTo","reloadPage","window","reload","navigate","redirect_b64","CryptoJS.enc","Base64","Utf8","CryptoJS.lib","WordArray","random","toString","bytes","CryptoJS.SHA256","pkce_hash","replace","url","loginUrl","loginUrlParamRedirect","loginUrlParamChallenge","loginUrlParamNonce","includes","tokenParts","claimsString","b64DecodeUnicode","str","base64","decodeURIComponent","atob","charCodeAt","join","queryString","queryDict","pairs","pairs_1","pairs_1_1","pair","index","indexOf","substr","push","readUserFromSessionStorage","storeUserToSessionStorage","clearUserFromSessionStorage","HttpBackend","Inject","args","Router","Location","__decorate","Injectable","__param","AvlTokenInterceptor","auth","basePaths","toLowerCase","intercept","req","isUrlInBasePaths","setAuthHeader","handle","err","handleHttpError","status","from","switchMap","_","throwError","request","find","startsWith","header","set","clone","__decorate$1","Array"],"mappings":"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","sourcesContent":["export enum StorageNames {\r\n  AccessToken = 'access_token',\r\n  AccessTokenExpiresAt = 'access_token_expires_at',\r\n  AccessTokenStoredAt = 'access_token_stored_at',\r\n  RefreshToken = 'refresh_token',\r\n  RefreshTokenExpiresAt = 'refresh_token_expires_at',\r\n  IdToken = 'id_token',\r\n  Roles = 'roles',\r\n  UserName = 'username',\r\n  Name = 'name'\r\n}\r\n","import { InjectionToken } from '@angular/core';\r\n\r\nexport interface AuthConfig { \r\n  tokenUrl: string;\r\n  loginUrl: string;\r\n  refreshUrl?: string;\r\n  loginUrlParamRedirect: string;\r\n  loginUrlParamChallenge: string;\r\n  loginUrlParamNonce: string;\r\n  logoutUrl?: string;\r\n  logoutUrlParamIdToken?: string;\r\n  logoutUrlParamRedirect?: string;\r\n  requiredRole?: string;\r\n  tokenPrefix?: string;\r\n}\r\n\r\nexport const AUTH_CONFIG = new InjectionToken<AuthConfig>(undefined);\r\n\r\nexport const INTERCEPTOR_BASE_PATHS = new InjectionToken<string[]>(undefined);","import { Observable, BehaviorSubject } from 'rxjs';\r\nimport { User } from '../user.model';\r\nexport abstract class AvlAuthService {\r\n  /**\r\n   * User data is held in this property\r\n   */\r\n  protected userSubject = new BehaviorSubject<User>(undefined);\r\n\r\n  /**\r\n   * Current user as Observable\r\n   */\r\n  public user$: Observable<User> = this.userSubject.asObservable();\r\n\r\n  /**\r\n   * String holding error message in case user couldn't authenticate\r\n   */\r\n  protected errorMessageSubject = new BehaviorSubject<string>(undefined);\r\n\r\n  /**\r\n   * Error messsage in case failed authentication as Observable\r\n   */\r\n  public errorMessage$: Observable<string> = this.errorMessageSubject.asObservable();\r\n\r\n  /**\r\n   * Observable tracking authenticated state\r\n   * Resolves to true on successful log in, false otherwise\r\n   */\r\n  public abstract isLoggedIn$: Observable<boolean>;\r\n\r\n  /**\r\n   * Observable tracking if redirected from idb\r\n   * Resolves to true on redirection, false otherwise\r\n   */\r\n  public abstract redirectedFromLogIn: BehaviorSubject<boolean>;\r\n\r\n  /**\r\n   * Login user and redirect after successful authentication.\r\n   * Custom auth services need to provide implementation\r\n   * @param redirectUrl Url to redirect after succesful authentication\r\n   */\r\n  public abstract login(redirectUrl?: string): void;\r\n\r\n  /**\r\n  * If tokens are peristed in local storage, set current user data\r\n  */\r\n  public abstract reloadPersistedUserData(): void;\r\n\r\n  /**\r\n   * Log out user and redirect after.\r\n   * Custom auth services need to provide implementation\r\n   * @param redirectUrl Url to redirect after logging out\r\n   */\r\n  public abstract logout(redirectUrl?: string): void;\r\n\r\n  /**\r\n   * Currently authenticated user data\r\n   */\r\n  public get currentUser(): User {\r\n    return this.userSubject.value;\r\n  }\r\n\r\n  /**\r\n   * Current error message for fail authentication\r\n   * Undefined when user is logged in\r\n   */\r\n  public get errorMessage(): string {\r\n    return this.errorMessageSubject.value;\r\n  }\r\n\r\n  /**\r\n   * Use to clear error message after user is informed\r\n   */\r\n  public clearErrorMessage() {\r\n    this.errorMessageSubject.next(undefined);\r\n  }\r\n\r\n  /**\r\n   * For token based authetication.\r\n   * Provide functionality to refresh tokens\r\n   */\r\n  public refreshTokens?(): Promise<any>;\r\n\r\n  /**\r\n   * For token based authetication.\r\n   * Updates user authentication with refresh tokens\r\n   */\r\n   public abstract refreshUserIfNeeded(): void;\r\n\r\n  /**\r\n  * Read user from session storage\r\n  */\r\n   public abstract readUserFromSessionStorage(): User;\r\n\r\n  /**\r\n  * Store user to session storage\r\n  */\r\n   public abstract storeUserToSessionStorage(user: User): void;\r\n   \r\n  /**\r\n  * Clear user from session storage\r\n  */\r\n   public abstract clearUserFromSessionStorage(): void;\r\n}\r\n","export class TokensPending {\r\n  success?: boolean;\r\n  waiting?: boolean;\r\n  constructor(waiting?: boolean, success?: boolean) {\r\n    this.waiting = waiting;\r\n    this.success = success;\r\n  }\r\n}\r\n","import { User } from '../user.model';\r\nimport { StorageNames } from './storage-names';\r\n\r\nexport class TokenStorage {\r\n  private prefix = '';\r\n\r\n  constructor(prefix: string = '') {\r\n    this.prefix = prefix;\r\n  }\r\n\r\n  readUser(): User {\r\n    const roles = JSON.parse(this.getItem(StorageNames.Roles)) as string[];\r\n    return {\r\n      username: this.getItem(StorageNames.UserName),\r\n      name: this.getItem(StorageNames.Name),\r\n      access_token: this.getItem(StorageNames.AccessToken),\r\n      access_token_expires: this.getNumber(StorageNames.AccessTokenExpiresAt),\r\n      access_token_stored: this.getNumber(StorageNames.AccessTokenStoredAt),\r\n      refresh_token: this.getItem(StorageNames.RefreshToken),\r\n      refresh_token_expires: this.getNumber(StorageNames.RefreshTokenExpiresAt),\r\n      id_token: this.getItem(StorageNames.IdToken),\r\n      roles\r\n    };\r\n  }\r\n\r\n  storeUser(user: User) {\r\n    this.setItem(StorageNames.UserName, user.username);\r\n    this.setItem(StorageNames.Name, user.name);\r\n    this.setItem(StorageNames.AccessToken, user.access_token);\r\n    this.setItem(StorageNames.AccessTokenExpiresAt, `${user.access_token_expires}`);\r\n    this.setItem(StorageNames.AccessTokenStoredAt, `${user.access_token_stored}`);\r\n    this.setItem(StorageNames.RefreshToken, user.refresh_token);\r\n    this.setItem(StorageNames.RefreshTokenExpiresAt, `${user.refresh_token_expires}`);\r\n    this.setItem(StorageNames.IdToken, user.id_token);\r\n\r\n    const rolesStr = JSON.stringify(user.roles);\r\n    sessionStorage.setItem(StorageNames.Roles, `${rolesStr}`);\r\n  }\r\n\r\n  clearUser() {\r\n    for (const name in StorageNames) {\r\n      if (StorageNames.hasOwnProperty(name)) {\r\n        this.removeItem(StorageNames[name]);\r\n      }\r\n    }\r\n  }\r\n\r\n  private getNumber(key: string): number {\r\n    return parseInt(this.getItem(key), 10);\r\n  }\r\n\r\n  getItem(key: string): string {\r\n    return sessionStorage.getItem(this.prefix + key);\r\n  }\r\n\r\n  setItem(key: string, value: string): void {\r\n    sessionStorage.setItem(this.prefix + key, value);\r\n  }\r\n\r\n  removeItem(key: string): void {\r\n    sessionStorage.removeItem(this.prefix + key);\r\n  }\r\n}\r\n","import { Injectable, Inject } from '@angular/core';\r\nimport { Location } from '@angular/common';\r\nimport { HttpBackend, HttpClient, HttpHeaders } from '@angular/common/http';\r\nimport { Observable, BehaviorSubject } from 'rxjs';\r\nimport { Router } from '@angular/router';\r\nimport { map, take, distinctUntilKeyChanged, skipWhile, catchError } from 'rxjs/operators';\r\n\r\nimport * as CryptoJS from 'crypto-js';\r\n\r\nimport { User } from '../user.model';\r\nimport { AvlAuthService } from './avl-auth.service';\r\nimport { AUTH_CONFIG, AuthConfig } from '../variables';\r\nimport { TokensPending } from './token-pending';\r\nimport { TokenStorage } from './token-storage';\r\nimport { TokenResponse } from './token-response';\r\nimport { StorageNames } from './storage-names';\r\nimport { TokenClaims } from './token-claims';\r\n\r\nconst LOGOUT_CONFIG_NOT_SET_ERROR =\r\n  'User signed out locally, but logout request towards OIDC server not initiated since logoutUrl is not set in authConfig.';\r\n\r\n@Injectable()\r\nexport class AvlOidcCodeAuthService extends AvlAuthService {\r\n  // success will be set after tokens are successfully fetched or not\r\n  private tokensPendingSubject = new BehaviorSubject<TokensPending>(new TokensPending(false));\r\n\r\n  /**\r\n   * When fetching tokens, this observable changes\r\n   * @returns Observable with following context:\r\n   * - waiting - if true, request for new tokens is made, this happens on initial authentication and on refreshTokens\r\n   * - success - true for successful authentication\r\n   */\r\n  public tokensPending$: Observable<TokensPending>;\r\n\r\n  /**\r\n   * Observable tracking authenticated state\r\n   * Resolves to true on successful log in, false otherwise\r\n   */\r\n  public isLoggedIn$: Observable<boolean>;\r\n\r\n  /**\r\n   * Observable tracking if redirected from idb\r\n   * Resolves to true on redirection, false otherwise\r\n   */\r\n  public redirectedFromLogIn = new BehaviorSubject<boolean>(undefined);\r\n\r\n  private http: HttpClient;\r\n  private storage: TokenStorage;\r\n\r\n  constructor(\r\n    private httpBackend: HttpBackend,\r\n    @Inject(AUTH_CONFIG) private authConfig: AuthConfig,\r\n    private router: Router,\r\n    private loc: Location\r\n  ) {\r\n    super();\r\n\r\n    this.http = new HttpClient(this.httpBackend);\r\n\r\n    this.tokensPending$ = this.tokensPendingSubject.asObservable();\r\n    this.isLoggedIn$ = new Observable<boolean>(observer => {\r\n      const tokensPendingState = this.tokensPendingSubject.value;\r\n      this.tokensPending$\r\n        .pipe(\r\n          distinctUntilKeyChanged('waiting'),\r\n          skipWhile(tokenPending => tokenPending.waiting !== false),\r\n          map(tokenPending => {\r\n            if (tokenPending.success != null) {\r\n              observer.next(tokenPending.success);\r\n            }\r\n          }),\r\n          take(1)\r\n        )\r\n        .subscribe();\r\n      if (tokensPendingState.waiting !== true && tokensPendingState.success !== null) {\r\n        observer.next(this.currentUser != null && this.isAccessTokenValid());\r\n      }\r\n    });\r\n\r\n    this.storage = new TokenStorage(this.authConfig.tokenPrefix);\r\n    const user = this.storage.readUser();\r\n\r\n    if (this.isUserInvalid(user)) {\r\n      this.storage.clearUser();\r\n    } else {\r\n      this.persistUser(user);\r\n    }\r\n\r\n    // if user is not logged in and pkce exists handle redirect from oidc server if possible\r\n    if (this.currentUser == null && this.pkce) {\r\n      this.handleOidcRedirect();\r\n    } else {\r\n      this.redirectedFromLogIn.next(Boolean(this.currentUser));\r\n    }\r\n  }\r\n\r\n  private isUserInvalid(data: Partial<User>): boolean {\r\n    return (\r\n      data.username == null || data.access_token == null || data.access_token_expires < Date.now()\r\n    );\r\n  }\r\n\r\n  private get pkce(): string | undefined {\r\n    return this.storage.getItem('pkce') || undefined;\r\n  }\r\n  private set pkce(c: string | undefined) {\r\n    if (c) {\r\n      this.storage.setItem('pkce', c);\r\n    } else {\r\n      this.storage.removeItem('pkce');\r\n    }\r\n  }\r\n\r\n  private get nonce(): string | undefined {\r\n    return sessionStorage.getItem('nonce') || undefined;\r\n  }\r\n  private set nonce(c: string | undefined) {\r\n    if (c) {\r\n      this.storage.setItem('nonce', c);\r\n    } else {\r\n      this.storage.removeItem('nonce');\r\n    }\r\n  }\r\n\r\n  private isAccessTokenValid(): boolean {\r\n    return Date.now() < this.currentUser.access_token_expires;\r\n  }\r\n\r\n  private persistUser(user?: User): void {\r\n    if (!user) {\r\n      this.clearUser();\r\n      return;\r\n    }\r\n    this.storage.storeUser(user);\r\n    this.userSubject.next(user);\r\n  }\r\n\r\n  private clearUser(): void {\r\n    this.storage.clearUser();\r\n    this.userSubject.next(undefined);\r\n  }\r\n\r\n  /*\r\n   * Checks if current url is redirect from oidc server and gets access token from the server.\r\n   */\r\n  private async handleOidcRedirect() {\r\n    const pkce = this.pkce;\r\n    this.pkce = undefined;\r\n\r\n    const urlParts = this.loc.path(true).split('?', 2);\r\n    let urlHash: string;\r\n    let first: number;\r\n    let last: number;\r\n    let urlPartSplit: string[];\r\n\r\n    if (urlParts.length === 2) {\r\n      first = urlParts[1].lastIndexOf('#');\r\n      if (first !== -1) {\r\n        last = urlParts[1].lastIndexOf('&');\r\n        urlHash = urlParts[1].slice(first, last);\r\n        urlPartSplit = urlParts[1].split('#', 2);\r\n        urlParts[1] = urlParts[1].split('&').pop();\r\n        urlParts[1] = urlPartSplit[0].concat('&').concat(urlParts[1]);\r\n      }\r\n    }\r\n\r\n    let query = urlParts.length === 2 ? this.parseQueryString(urlParts[1]) : [];\r\n    let queryCode: string;\r\n    for (let i = query.length - 1; i >= 0; i--) {\r\n      if (query[i].key === 'code') {\r\n        queryCode = query[i].value;\r\n        query = [...query.slice(0, i), ...query.slice(i + 1)];\r\n        break;\r\n      }\r\n    }\r\n    if (urlParts.length === 2 && queryCode) {\r\n      const nonce = this.nonce;\r\n      this.nonce = undefined;\r\n\r\n      const httpOptions = {\r\n        headers: new HttpHeaders({\r\n          code: queryCode,\r\n          verifier: pkce,\r\n          nonce: nonce\r\n        })\r\n      };\r\n\r\n      this.updateTokensPending(new TokensPending(true));\r\n      try {\r\n        const user = await this.http\r\n          .post<TokenResponse>(this.authConfig.tokenUrl, {}, httpOptions)\r\n          .pipe(map(token => this.readUserFromToken(token)))\r\n          .toPromise();\r\n        this.persistUser(user);\r\n        this.updateTokensPending(new TokensPending(false, true));\r\n      } catch (error) {\r\n        this.updateTokensPending(new TokensPending(false, false), error.message);\r\n      }\r\n    }\r\n\r\n    if (urlHash) {\r\n      this.router.navigateByUrl(\r\n        `${urlParts[0]}${this.reconstructQueryParamString(query)}${urlHash}`,\r\n        { replaceUrl: true }\r\n      );\r\n      this.redirectedFromLogIn.next(true);\r\n    } else {\r\n      this.router.navigateByUrl(`${urlParts[0]}${this.reconstructQueryParamString(query)}`, {\r\n        replaceUrl: true\r\n      });\r\n      this.redirectedFromLogIn.next(Boolean(this.currentUser));\r\n    }\r\n  }\r\n\r\n  public reloadPersistedUserData() {\r\n    const user = this.storage.readUser();\r\n    if (this.currentUser?.access_token === user?.access_token) {\r\n      return;\r\n    }\r\n\r\n    if (this.isUserInvalid(user)) {\r\n      this.clearUser();\r\n    } else {\r\n      this.persistUser(user);\r\n    }\r\n  }\r\n  private reconstructQueryParamString(queryParams: { key: string; value: string }[]): string {\r\n    let s = '?';\r\n    if (queryParams.length === 0) {\r\n      return '';\r\n    }\r\n    for (const q of queryParams) {\r\n      if (s === '?') {\r\n        s += `${encodeURIComponent(q.key)}=${encodeURIComponent(q.value)}`;\r\n      } else {\r\n        s += `&${encodeURIComponent(q.key)}=${encodeURIComponent(q.value)}`;\r\n      }\r\n    }\r\n    return s;\r\n  }\r\n\r\n  private updateTokensPending(state: TokensPending, errorMessage?: string) {\r\n    // the order here is important\r\n    // errorMessage will be set before isLoggedIn becomes false\r\n    if (state.waiting === false) {\r\n      this.errorMessageSubject.next(errorMessage);\r\n    }\r\n    this.tokensPendingSubject.next(state);\r\n  }\r\n\r\n  private readUserFromToken(token: TokenResponse): User {\r\n    const accessTokenClaims = this.readClaimsFromToken(token.accesstoken);\r\n\r\n    // Calculate actual expiry date for this machine\r\n    const accessTokenStoredAt = Date.now(); // [ms]\r\n    const accessTokenExpiresAt = accessTokenStoredAt + token.expiresIn * 1000;\r\n\r\n    const refreshTokenClaims = this.readClaimsFromToken(token.refreshtoken);\r\n    let refreshTokenExpiresAt = null;\r\n    if (refreshTokenClaims) {\r\n      // If time value is 0 token lasts indefinitely\r\n      const refreshTokenExpiresIn =\r\n        refreshTokenClaims['exp'] !== 0 ? refreshTokenClaims['exp'] - refreshTokenClaims['iat'] : 0;\r\n      const refreshTokenStoredAt = accessTokenStoredAt;\r\n      refreshTokenExpiresAt =\r\n        refreshTokenExpiresIn !== 0 ? refreshTokenStoredAt + refreshTokenExpiresIn * 1000 : 0;\r\n    }\r\n\r\n    const roles = accessTokenClaims?.roles;\r\n\r\n    return {\r\n      username: accessTokenClaims.preferred_username,\r\n      name: accessTokenClaims.name ?? accessTokenClaims.preferred_username,\r\n      access_token: token.accesstoken,\r\n      access_token_expires: accessTokenExpiresAt,\r\n      access_token_stored: accessTokenStoredAt,\r\n      refresh_token: token.refreshtoken,\r\n      refresh_token_expires: refreshTokenExpiresAt,\r\n      id_token: token.idToken,\r\n      roles: roles\r\n    } as User;\r\n  }\r\n\r\n  public async refreshUserIfNeeded() {\r\n    const accessTokenExpired = this.currentUser?.access_token_expires < Date.now();\r\n    if (accessTokenExpired) {\r\n      await this.refreshTokens();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If needed, this method can be called to refresh tokens for current user\r\n   * @returns Promise resolved with object containing new tokens\r\n   */\r\n  public async refreshTokens(): Promise<any> {\r\n    const refreshTokenValid = this.currentUser?.refresh_token_expires > Date.now();\r\n    if (!refreshTokenValid) {\r\n      this.logout();\r\n      return;\r\n    }\r\n\r\n    const httpOptions = {\r\n      headers: new HttpHeaders({\r\n        grant_type: 'refresh_token',\r\n        'refresh-token': this.storage.getItem(StorageNames.RefreshToken)\r\n      })\r\n    };\r\n\r\n    if (!this.authConfig.refreshUrl) {\r\n      throw new Error('refreshUrl missing in AuthConfig');\r\n    }\r\n    this.updateTokensPending(new TokensPending(true));\r\n\r\n    try {\r\n      const user = await this.http\r\n        .post<TokenResponse>(this.authConfig.refreshUrl, {}, httpOptions)\r\n        .pipe(map(token => this.readUserFromToken(token)))\r\n        .toPromise();\r\n      this.persistUser(user);\r\n      this.updateTokensPending(new TokensPending(false, true));\r\n    } catch (error) {\r\n      this.updateTokensPending(new TokensPending(false, false), error.message);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Login user and redirect after successful authentication.\r\n   * Custom auth services need to provide implementation\r\n   * @param redirectUrl Url to redirect after successful authentication\r\n   */\r\n  public login(redirectUrl?: string): void {\r\n    location.href = this.generateLoginUrl(redirectUrl ? redirectUrl : location.href);\r\n  }\r\n\r\n  /**\r\n   * Log out user and redirect after.\r\n   * Custom auth services need to provide implementation\r\n   * @param redirectUrl Url to redirect after logging out\r\n   */\r\n  public logout(redirectUrl?: string): void {\r\n    const { logoutUrl } = this.authConfig;\r\n\r\n    if (!logoutUrl) {\r\n      console.warn(LOGOUT_CONFIG_NOT_SET_ERROR);\r\n    }\r\n\r\n    const headers = new HttpHeaders({ 'refresh-token': this.currentUser.refresh_token });\r\n    this.http\r\n      .post(logoutUrl, {}, { headers })\r\n      .pipe(\r\n        catchError(error => {\r\n          this.onLogout(redirectUrl);\r\n          throw error;\r\n        })\r\n      )\r\n      .subscribe(() => this.onLogout(redirectUrl));\r\n  }\r\n\r\n  private onLogout(redirectUrl?: string): void {\r\n    this.clearUser();\r\n    this.redirectIfNeeded(redirectUrl);\r\n  }\r\n\r\n  private redirectIfNeeded(redirectUrl?: string): void {\r\n    if (redirectUrl) {\r\n      this.navigateTo(redirectUrl);\r\n    } else {\r\n      this.reloadPage();\r\n    }\r\n  }\r\n\r\n  private reloadPage(): void {\r\n    window.location.reload();\r\n  }\r\n\r\n  private navigateTo(redirectUrl: string): void {\r\n    this.router.navigate([redirectUrl]);\r\n  }\r\n\r\n  private generateLoginUrl(redirectUrl: string): string {\r\n    const redirect_b64 = '' + CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(redirectUrl));\r\n\r\n    // Generate a session value.\r\n    const nonce = CryptoJS.lib.WordArray.random(16).toString();\r\n\r\n    // Generate pkce\r\n    const pkce = CryptoJS.lib.WordArray.random(32).toString();\r\n    const bytes = CryptoJS.SHA256(pkce) as CryptoJS.WordArray;\r\n    let pkce_hash = CryptoJS.enc.Base64.stringify(bytes);\r\n\r\n    // KeyCloak requires this - https://tools.ietf.org/html/rfc7636#appendix-A\r\n    pkce_hash = pkce_hash.replace(/=/g, '');\r\n    pkce_hash = pkce_hash.replace(/\\+/g, '-');\r\n    pkce_hash = pkce_hash.replace(/\\//g, '_');\r\n\r\n    this.pkce = pkce;\r\n    this.nonce = nonce;\r\n\r\n    let url = this.authConfig.loginUrl;\r\n    url += '?' + this.authConfig.loginUrlParamRedirect + '=' + encodeURIComponent(redirect_b64);\r\n    url += '&' + this.authConfig.loginUrlParamChallenge + '=' + encodeURIComponent(pkce_hash);\r\n    url += '&' + this.authConfig.loginUrlParamNonce + '=' + encodeURIComponent(nonce);\r\n    return url;\r\n  }\r\n\r\n  private readClaimsFromToken(token: string): TokenClaims | null {\r\n    if (!token.includes('.')) {\r\n      // Token is not a valid JWT token\r\n      return null;\r\n    }\r\n    const tokenParts = token.split('.');\r\n    const claimsString = this.b64DecodeUnicode(tokenParts[1]);\r\n    return JSON.parse(claimsString) as TokenClaims;\r\n  }\r\n\r\n  private b64DecodeUnicode(str: string): string {\r\n    const base64 = str.replace(/\\-/g, '+').replace(/\\_/g, '/');\r\n\r\n    return decodeURIComponent(\r\n      atob(base64)\r\n        .split('')\r\n        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\r\n        .join('')\r\n    );\r\n  }\r\n\r\n  private parseQueryString(queryString: string): { key: string; value: string }[] {\r\n    if (!queryString.length) {\r\n      return [];\r\n    }\r\n    const queryDict = [];\r\n    const pairs = queryString.split('&');\r\n    for (const pair of pairs) {\r\n      const index = pair.indexOf('=');\r\n      let key: string;\r\n      let value: string;\r\n      if (index === -1) {\r\n        key = pair;\r\n        value = undefined;\r\n      } else {\r\n        key = pair.substr(0, index);\r\n        value = pair.substr(index + 1);\r\n      }\r\n      queryDict.push({\r\n        key: decodeURIComponent(key),\r\n        value: decodeURIComponent(value)\r\n      });\r\n    }\r\n    return queryDict;\r\n  }\r\n\r\n  public readUserFromSessionStorage(): User {\r\n    return this.storage.readUser();\r\n  }\r\n\r\n  public storeUserToSessionStorage(user: User): void {\r\n    this.storage.storeUser(user);\r\n  }\r\n\r\n  public clearUserFromSessionStorage(): void {\r\n    this.storage.clearUser();\r\n  }\r\n}\r\n","import { Injectable, Inject } from '@angular/core';\r\nimport {\r\n  HttpRequest,\r\n  HttpHandler,\r\n  HttpEvent,\r\n  HttpInterceptor,\r\n  HttpErrorResponse\r\n} from '@angular/common/http';\r\nimport { Observable, from, throwError } from 'rxjs';\r\nimport { catchError, switchMap } from 'rxjs/operators';\r\n\r\nimport { AvlAuthService } from './avl-auth.service';\r\nimport { INTERCEPTOR_BASE_PATHS } from '../variables';\r\n\r\n@Injectable()\r\nexport class AvlTokenInterceptor implements HttpInterceptor {\r\n  constructor(\r\n    public auth: AvlAuthService,\r\n    @Inject(INTERCEPTOR_BASE_PATHS) protected basePaths: string[]\r\n  ) {\r\n    for (const i in this.basePaths) {\r\n      if (this.basePaths.hasOwnProperty(i)) {\r\n        this.basePaths[i] = this.basePaths[i].toLowerCase();\r\n      }\r\n    }\r\n  }\r\n\r\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\r\n    if (!this.isUrlInBasePaths(req)) {\r\n      return next.handle(req);\r\n    }\r\n\r\n    if (this.auth.currentUser) {\r\n      req = this.setAuthHeader(req);\r\n    }\r\n\r\n    return next\r\n      .handle(req)\r\n      .pipe(catchError((err: HttpErrorResponse) => this.handleHttpError(req, next, err)));\r\n  }\r\n\r\n  private handleHttpError(\r\n    req: HttpRequest<any>,\r\n    next: HttpHandler,\r\n    err: HttpErrorResponse\r\n  ): Observable<any> {\r\n    if (err.status === 401) {\r\n      // Unauthorized, tokens expired\r\n      return from(this.auth.refreshTokens()).pipe(\r\n        switchMap(_ => next.handle(this.setAuthHeader(req))),\r\n        catchError(_ => throwError(err))\r\n      );\r\n    }\r\n    return throwError(err);\r\n  }\r\n\r\n  /** Check if request URL is in provided basePaths\r\n   * @param request Http request instance whose URL is checked.\r\n   */\r\n  private isUrlInBasePaths(request: HttpRequest<any>): boolean {\r\n    const url = request.url.toLowerCase();\r\n    const path = this.basePaths.find(path => url.startsWith(path));\r\n    return Boolean(path);\r\n  }\r\n\r\n  /** Sets access token to authorization header of HTTP request\r\n   * @param request HTTP request instance\r\n   * @returns Cloned HTTP with adapted headers\r\n   */\r\n  private setAuthHeader(req: HttpRequest<any>): HttpRequest<any> {\r\n    const access_token = this.auth.currentUser.access_token;\r\n    const header = `Bearer ${access_token}`;\r\n    const headers = req.headers.set('Authorization', header);\r\n\r\n    return req.clone({ headers });\r\n  }\r\n}\r\n"]}