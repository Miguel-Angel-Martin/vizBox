import { InjectionToken, Inject, Injectable } from '@angular/core';
import { BehaviorSubject, Observable, from, throwError } from 'rxjs';
import { Location } from '@angular/common';
import { HttpClient, HttpHeaders, HttpBackend } from '@angular/common/http';
import { Router } from '@angular/router';
import { distinctUntilKeyChanged, skipWhile, map, take, catchError, switchMap } from 'rxjs/operators';
import { enc, lib, SHA256 } from 'crypto-js';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common/http';
import * as ɵngcc2 from '@angular/router';
import * as ɵngcc3 from '@angular/common';
const AUTH_CONFIG = new InjectionToken(undefined);
const INTERCEPTOR_BASE_PATHS = new InjectionToken(undefined);

class AvlAuthService {
    constructor() {
        /**
         * User data is held in this property
         */
        this.userSubject = new BehaviorSubject(undefined);
        /**
         * Current user as Observable
         */
        this.user$ = this.userSubject.asObservable();
        /**
         * String holding error message in case user couldn't authenticate
         */
        this.errorMessageSubject = new BehaviorSubject(undefined);
        /**
         * Error messsage in case failed authentication as Observable
         */
        this.errorMessage$ = this.errorMessageSubject.asObservable();
    }
    /**
     * Currently authenticated user data
     */
    get currentUser() {
        return this.userSubject.value;
    }
    /**
     * Current error message for fail authentication
     * Undefined when user is logged in
     */
    get errorMessage() {
        return this.errorMessageSubject.value;
    }
    /**
     * Use to clear error message after user is informed
     */
    clearErrorMessage() {
        this.errorMessageSubject.next(undefined);
    }
}

class TokensPending {
    constructor(waiting, success) {
        this.waiting = waiting;
        this.success = success;
    }
}

var StorageNames;
(function (StorageNames) {
    StorageNames["AccessToken"] = "access_token";
    StorageNames["AccessTokenExpiresAt"] = "access_token_expires_at";
    StorageNames["AccessTokenStoredAt"] = "access_token_stored_at";
    StorageNames["RefreshToken"] = "refresh_token";
    StorageNames["RefreshTokenExpiresAt"] = "refresh_token_expires_at";
    StorageNames["IdToken"] = "id_token";
    StorageNames["Roles"] = "roles";
    StorageNames["UserName"] = "username";
    StorageNames["Name"] = "name";
})(StorageNames || (StorageNames = {}));

class TokenStorage {
    constructor(prefix = '') {
        this.prefix = '';
        this.prefix = prefix;
    }
    readUser() {
        const roles = JSON.parse(this.getItem(StorageNames.Roles));
        return {
            username: this.getItem(StorageNames.UserName),
            name: this.getItem(StorageNames.Name),
            access_token: this.getItem(StorageNames.AccessToken),
            access_token_expires: this.getNumber(StorageNames.AccessTokenExpiresAt),
            access_token_stored: this.getNumber(StorageNames.AccessTokenStoredAt),
            refresh_token: this.getItem(StorageNames.RefreshToken),
            refresh_token_expires: this.getNumber(StorageNames.RefreshTokenExpiresAt),
            id_token: this.getItem(StorageNames.IdToken),
            roles
        };
    }
    storeUser(user) {
        this.setItem(StorageNames.UserName, user.username);
        this.setItem(StorageNames.Name, user.name);
        this.setItem(StorageNames.AccessToken, user.access_token);
        this.setItem(StorageNames.AccessTokenExpiresAt, `${user.access_token_expires}`);
        this.setItem(StorageNames.AccessTokenStoredAt, `${user.access_token_stored}`);
        this.setItem(StorageNames.RefreshToken, user.refresh_token);
        this.setItem(StorageNames.RefreshTokenExpiresAt, `${user.refresh_token_expires}`);
        this.setItem(StorageNames.IdToken, user.id_token);
        const rolesStr = JSON.stringify(user.roles);
        sessionStorage.setItem(StorageNames.Roles, `${rolesStr}`);
    }
    clearUser() {
        for (const name in StorageNames) {
            if (StorageNames.hasOwnProperty(name)) {
                this.removeItem(StorageNames[name]);
            }
        }
    }
    getNumber(key) {
        return parseInt(this.getItem(key), 10);
    }
    getItem(key) {
        return sessionStorage.getItem(this.prefix + key);
    }
    setItem(key, value) {
        sessionStorage.setItem(this.prefix + key, value);
    }
    removeItem(key) {
        sessionStorage.removeItem(this.prefix + key);
    }
}

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const LOGOUT_CONFIG_NOT_SET_ERROR = 'User signed out locally, but logout request towards OIDC server not initiated since logoutUrl is not set in authConfig.';
let AvlOidcCodeAuthService = class AvlOidcCodeAuthService extends AvlAuthService {
    constructor(httpBackend, authConfig, router, loc) {
        super();
        this.httpBackend = httpBackend;
        this.authConfig = authConfig;
        this.router = router;
        this.loc = loc;
        // success will be set after tokens are successfully fetched or not
        this.tokensPendingSubject = new BehaviorSubject(new TokensPending(false));
        /**
         * Observable tracking if redirected from idb
         * Resolves to true on redirection, false otherwise
         */
        this.redirectedFromLogIn = new BehaviorSubject(undefined);
        this.http = new HttpClient(this.httpBackend);
        this.tokensPending$ = this.tokensPendingSubject.asObservable();
        this.isLoggedIn$ = new Observable(observer => {
            const tokensPendingState = this.tokensPendingSubject.value;
            this.tokensPending$
                .pipe(distinctUntilKeyChanged('waiting'), skipWhile(tokenPending => tokenPending.waiting !== false), map(tokenPending => {
                if (tokenPending.success != null) {
                    observer.next(tokenPending.success);
                }
            }), take(1))
                .subscribe();
            if (tokensPendingState.waiting !== true && tokensPendingState.success !== null) {
                observer.next(this.currentUser != null && this.isAccessTokenValid());
            }
        });
        this.storage = new TokenStorage(this.authConfig.tokenPrefix);
        const user = this.storage.readUser();
        if (this.isUserInvalid(user)) {
            this.storage.clearUser();
        }
        else {
            this.persistUser(user);
        }
        // if user is not logged in and pkce exists handle redirect from oidc server if possible
        if (this.currentUser == null && this.pkce) {
            this.handleOidcRedirect();
        }
        else {
            this.redirectedFromLogIn.next(Boolean(this.currentUser));
        }
    }
    isUserInvalid(data) {
        return (data.username == null || data.access_token == null || data.access_token_expires < Date.now());
    }
    get pkce() {
        return this.storage.getItem('pkce') || undefined;
    }
    set pkce(c) {
        if (c) {
            this.storage.setItem('pkce', c);
        }
        else {
            this.storage.removeItem('pkce');
        }
    }
    get nonce() {
        return sessionStorage.getItem('nonce') || undefined;
    }
    set nonce(c) {
        if (c) {
            this.storage.setItem('nonce', c);
        }
        else {
            this.storage.removeItem('nonce');
        }
    }
    isAccessTokenValid() {
        return Date.now() < this.currentUser.access_token_expires;
    }
    persistUser(user) {
        if (!user) {
            this.clearUser();
            return;
        }
        this.storage.storeUser(user);
        this.userSubject.next(user);
    }
    clearUser() {
        this.storage.clearUser();
        this.userSubject.next(undefined);
    }
    /*
     * Checks if current url is redirect from oidc server and gets access token from the server.
     */
    handleOidcRedirect() {
        return __awaiter(this, void 0, void 0, function* () {
            const pkce = this.pkce;
            this.pkce = undefined;
            const urlParts = this.loc.path(true).split('?', 2);
            let urlHash;
            let first;
            let last;
            let urlPartSplit;
            if (urlParts.length === 2) {
                first = urlParts[1].lastIndexOf('#');
                if (first !== -1) {
                    last = urlParts[1].lastIndexOf('&');
                    urlHash = urlParts[1].slice(first, last);
                    urlPartSplit = urlParts[1].split('#', 2);
                    urlParts[1] = urlParts[1].split('&').pop();
                    urlParts[1] = urlPartSplit[0].concat('&').concat(urlParts[1]);
                }
            }
            let query = urlParts.length === 2 ? this.parseQueryString(urlParts[1]) : [];
            let queryCode;
            for (let i = query.length - 1; i >= 0; i--) {
                if (query[i].key === 'code') {
                    queryCode = query[i].value;
                    query = [...query.slice(0, i), ...query.slice(i + 1)];
                    break;
                }
            }
            if (urlParts.length === 2 && queryCode) {
                const nonce = this.nonce;
                this.nonce = undefined;
                const httpOptions = {
                    headers: new HttpHeaders({
                        code: queryCode,
                        verifier: pkce,
                        nonce: nonce
                    })
                };
                this.updateTokensPending(new TokensPending(true));
                try {
                    const user = yield this.http
                        .post(this.authConfig.tokenUrl, {}, httpOptions)
                        .pipe(map(token => this.readUserFromToken(token)))
                        .toPromise();
                    this.persistUser(user);
                    this.updateTokensPending(new TokensPending(false, true));
                }
                catch (error) {
                    this.updateTokensPending(new TokensPending(false, false), error.message);
                }
            }
            if (urlHash) {
                this.router.navigateByUrl(`${urlParts[0]}${this.reconstructQueryParamString(query)}${urlHash}`, { replaceUrl: true });
                this.redirectedFromLogIn.next(true);
            }
            else {
                this.router.navigateByUrl(`${urlParts[0]}${this.reconstructQueryParamString(query)}`, {
                    replaceUrl: true
                });
                this.redirectedFromLogIn.next(Boolean(this.currentUser));
            }
        });
    }
    reloadPersistedUserData() {
        var _a;
        const user = this.storage.readUser();
        if (((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.access_token) === (user === null || user === void 0 ? void 0 : user.access_token)) {
            return;
        }
        if (this.isUserInvalid(user)) {
            this.clearUser();
        }
        else {
            this.persistUser(user);
        }
    }
    reconstructQueryParamString(queryParams) {
        let s = '?';
        if (queryParams.length === 0) {
            return '';
        }
        for (const q of queryParams) {
            if (s === '?') {
                s += `${encodeURIComponent(q.key)}=${encodeURIComponent(q.value)}`;
            }
            else {
                s += `&${encodeURIComponent(q.key)}=${encodeURIComponent(q.value)}`;
            }
        }
        return s;
    }
    updateTokensPending(state, errorMessage) {
        // the order here is important
        // errorMessage will be set before isLoggedIn becomes false
        if (state.waiting === false) {
            this.errorMessageSubject.next(errorMessage);
        }
        this.tokensPendingSubject.next(state);
    }
    readUserFromToken(token) {
        var _a;
        const accessTokenClaims = this.readClaimsFromToken(token.accesstoken);
        // Calculate actual expiry date for this machine
        const accessTokenStoredAt = Date.now(); // [ms]
        const accessTokenExpiresAt = accessTokenStoredAt + token.expiresIn * 1000;
        const refreshTokenClaims = this.readClaimsFromToken(token.refreshtoken);
        let refreshTokenExpiresAt = null;
        if (refreshTokenClaims) {
            // If time value is 0 token lasts indefinitely
            const refreshTokenExpiresIn = refreshTokenClaims['exp'] !== 0 ? refreshTokenClaims['exp'] - refreshTokenClaims['iat'] : 0;
            const refreshTokenStoredAt = accessTokenStoredAt;
            refreshTokenExpiresAt =
                refreshTokenExpiresIn !== 0 ? refreshTokenStoredAt + refreshTokenExpiresIn * 1000 : 0;
        }
        const roles = accessTokenClaims === null || accessTokenClaims === void 0 ? void 0 : accessTokenClaims.roles;
        return {
            username: accessTokenClaims.preferred_username,
            name: (_a = accessTokenClaims.name) !== null && _a !== void 0 ? _a : accessTokenClaims.preferred_username,
            access_token: token.accesstoken,
            access_token_expires: accessTokenExpiresAt,
            access_token_stored: accessTokenStoredAt,
            refresh_token: token.refreshtoken,
            refresh_token_expires: refreshTokenExpiresAt,
            id_token: token.idToken,
            roles: roles
        };
    }
    refreshUserIfNeeded() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const accessTokenExpired = ((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.access_token_expires) < Date.now();
            if (accessTokenExpired) {
                yield this.refreshTokens();
            }
        });
    }
    /**
     * If needed, this method can be called to refresh tokens for current user
     * @returns Promise resolved with object containing new tokens
     */
    refreshTokens() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const refreshTokenValid = ((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.refresh_token_expires) > Date.now();
            if (!refreshTokenValid) {
                this.logout();
                return;
            }
            const httpOptions = {
                headers: new HttpHeaders({
                    grant_type: 'refresh_token',
                    'refresh-token': this.storage.getItem(StorageNames.RefreshToken)
                })
            };
            if (!this.authConfig.refreshUrl) {
                throw new Error('refreshUrl missing in AuthConfig');
            }
            this.updateTokensPending(new TokensPending(true));
            try {
                const user = yield this.http
                    .post(this.authConfig.refreshUrl, {}, httpOptions)
                    .pipe(map(token => this.readUserFromToken(token)))
                    .toPromise();
                this.persistUser(user);
                this.updateTokensPending(new TokensPending(false, true));
            }
            catch (error) {
                this.updateTokensPending(new TokensPending(false, false), error.message);
                throw error;
            }
        });
    }
    /**
     * Login user and redirect after successful authentication.
     * Custom auth services need to provide implementation
     * @param redirectUrl Url to redirect after successful authentication
     */
    login(redirectUrl) {
        location.href = this.generateLoginUrl(redirectUrl ? redirectUrl : location.href);
    }
    /**
     * Log out user and redirect after.
     * Custom auth services need to provide implementation
     * @param redirectUrl Url to redirect after logging out
     */
    logout(redirectUrl) {
        const { logoutUrl } = this.authConfig;
        if (!logoutUrl) {
            console.warn(LOGOUT_CONFIG_NOT_SET_ERROR);
        }
        const headers = new HttpHeaders({ 'refresh-token': this.currentUser.refresh_token });
        this.http
            .post(logoutUrl, {}, { headers })
            .pipe(catchError(error => {
            this.onLogout(redirectUrl);
            throw error;
        }))
            .subscribe(() => this.onLogout(redirectUrl));
    }
    onLogout(redirectUrl) {
        this.clearUser();
        this.redirectIfNeeded(redirectUrl);
    }
    redirectIfNeeded(redirectUrl) {
        if (redirectUrl) {
            this.navigateTo(redirectUrl);
        }
        else {
            this.reloadPage();
        }
    }
    reloadPage() {
        window.location.reload();
    }
    navigateTo(redirectUrl) {
        this.router.navigate([redirectUrl]);
    }
    generateLoginUrl(redirectUrl) {
        const redirect_b64 = '' + enc.Base64.stringify(enc.Utf8.parse(redirectUrl));
        // Generate a session value.
        const nonce = lib.WordArray.random(16).toString();
        // Generate pkce
        const pkce = lib.WordArray.random(32).toString();
        const bytes = SHA256(pkce);
        let pkce_hash = enc.Base64.stringify(bytes);
        // KeyCloak requires this - https://tools.ietf.org/html/rfc7636#appendix-A
        pkce_hash = pkce_hash.replace(/=/g, '');
        pkce_hash = pkce_hash.replace(/\+/g, '-');
        pkce_hash = pkce_hash.replace(/\//g, '_');
        this.pkce = pkce;
        this.nonce = nonce;
        let url = this.authConfig.loginUrl;
        url += '?' + this.authConfig.loginUrlParamRedirect + '=' + encodeURIComponent(redirect_b64);
        url += '&' + this.authConfig.loginUrlParamChallenge + '=' + encodeURIComponent(pkce_hash);
        url += '&' + this.authConfig.loginUrlParamNonce + '=' + encodeURIComponent(nonce);
        return url;
    }
    readClaimsFromToken(token) {
        if (!token.includes('.')) {
            // Token is not a valid JWT token
            return null;
        }
        const tokenParts = token.split('.');
        const claimsString = this.b64DecodeUnicode(tokenParts[1]);
        return JSON.parse(claimsString);
    }
    b64DecodeUnicode(str) {
        const base64 = str.replace(/\-/g, '+').replace(/\_/g, '/');
        return decodeURIComponent(atob(base64)
            .split('')
            .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
            .join(''));
    }
    parseQueryString(queryString) {
        if (!queryString.length) {
            return [];
        }
        const queryDict = [];
        const pairs = queryString.split('&');
        for (const pair of pairs) {
            const index = pair.indexOf('=');
            let key;
            let value;
            if (index === -1) {
                key = pair;
                value = undefined;
            }
            else {
                key = pair.substr(0, index);
                value = pair.substr(index + 1);
            }
            queryDict.push({
                key: decodeURIComponent(key),
                value: decodeURIComponent(value)
            });
        }
        return queryDict;
    }
    readUserFromSessionStorage() {
        return this.storage.readUser();
    }
    storeUserToSessionStorage(user) {
        this.storage.storeUser(user);
    }
    clearUserFromSessionStorage() {
        this.storage.clearUser();
    }
};
AvlOidcCodeAuthService.ɵfac = function AvlOidcCodeAuthService_Factory(t) { return new (t || AvlOidcCodeAuthService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpBackend), ɵngcc0.ɵɵinject(AUTH_CONFIG), ɵngcc0.ɵɵinject(ɵngcc2.Router), ɵngcc0.ɵɵinject(ɵngcc3.Location)); };
AvlOidcCodeAuthService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AvlOidcCodeAuthService, factory: AvlOidcCodeAuthService.ɵfac });
AvlOidcCodeAuthService.ctorParameters = () => [
    { type: HttpBackend },
    { type: undefined, decorators: [{ type: Inject, args: [AUTH_CONFIG,] }] },
    { type: Router },
    { type: Location }
];
AvlOidcCodeAuthService = __decorate([ __param(1, Inject(AUTH_CONFIG)),
    __metadata("design:paramtypes", [HttpBackend, Object, Router,
        Location])
], AvlOidcCodeAuthService);

var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$1 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
let AvlTokenInterceptor = class AvlTokenInterceptor {
    constructor(auth, basePaths) {
        this.auth = auth;
        this.basePaths = basePaths;
        for (const i in this.basePaths) {
            if (this.basePaths.hasOwnProperty(i)) {
                this.basePaths[i] = this.basePaths[i].toLowerCase();
            }
        }
    }
    intercept(req, next) {
        if (!this.isUrlInBasePaths(req)) {
            return next.handle(req);
        }
        if (this.auth.currentUser) {
            req = this.setAuthHeader(req);
        }
        return next
            .handle(req)
            .pipe(catchError((err) => this.handleHttpError(req, next, err)));
    }
    handleHttpError(req, next, err) {
        if (err.status === 401) {
            // Unauthorized, tokens expired
            return from(this.auth.refreshTokens()).pipe(switchMap(_ => next.handle(this.setAuthHeader(req))), catchError(_ => throwError(err)));
        }
        return throwError(err);
    }
    /** Check if request URL is in provided basePaths
     * @param request Http request instance whose URL is checked.
     */
    isUrlInBasePaths(request) {
        const url = request.url.toLowerCase();
        const path = this.basePaths.find(path => url.startsWith(path));
        return Boolean(path);
    }
    /** Sets access token to authorization header of HTTP request
     * @param request HTTP request instance
     * @returns Cloned HTTP with adapted headers
     */
    setAuthHeader(req) {
        const access_token = this.auth.currentUser.access_token;
        const header = `Bearer ${access_token}`;
        const headers = req.headers.set('Authorization', header);
        return req.clone({ headers });
    }
};
AvlTokenInterceptor.ɵfac = function AvlTokenInterceptor_Factory(t) { return new (t || AvlTokenInterceptor)(ɵngcc0.ɵɵinject(AvlAuthService), ɵngcc0.ɵɵinject(INTERCEPTOR_BASE_PATHS)); };
AvlTokenInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AvlTokenInterceptor, factory: AvlTokenInterceptor.ɵfac });
AvlTokenInterceptor.ctorParameters = () => [
    { type: AvlAuthService },
    { type: Array, decorators: [{ type: Inject, args: [INTERCEPTOR_BASE_PATHS,] }] }
];
AvlTokenInterceptor = __decorate$1([ __param$1(1, Inject(INTERCEPTOR_BASE_PATHS)),
    __metadata$1("design:paramtypes", [AvlAuthService, Array])
], AvlTokenInterceptor);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlOidcCodeAuthService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.HttpBackend }, { type: undefined, decorators: [{
                type: Inject,
                args: [AUTH_CONFIG]
            }] }, { type: ɵngcc2.Router }, { type: ɵngcc3.Location }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlTokenInterceptor, [{
        type: Injectable
    }], function () { return [{ type: AvlAuthService }, { type: Array, decorators: [{
                type: Inject,
                args: [INTERCEPTOR_BASE_PATHS]
            }] }]; }, null); })();

/*
 * Public API Surface of auth
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AUTH_CONFIG, AvlAuthService, AvlOidcCodeAuthService, AvlTokenInterceptor, INTERCEPTOR_BASE_PATHS };

//# sourceMappingURL=avl-ng-controls-auth.js.map