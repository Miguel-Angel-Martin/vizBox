import { InjectionToken, Inject, Injectable } from '@angular/core';
import { BehaviorSubject, Observable, from, throwError } from 'rxjs';
import { Location } from '@angular/common';
import { HttpClient, HttpHeaders, HttpBackend } from '@angular/common/http';
import { Router } from '@angular/router';
import { distinctUntilKeyChanged, skipWhile, map, take, catchError, switchMap } from 'rxjs/operators';
import { enc, lib, SHA256 } from 'crypto-js';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common/http';
import * as ɵngcc2 from '@angular/router';
import * as ɵngcc3 from '@angular/common';
var AUTH_CONFIG = new InjectionToken(undefined);
var INTERCEPTOR_BASE_PATHS = new InjectionToken(undefined);

var AvlAuthService = /** @class */ (function () {
    function AvlAuthService() {
        /**
         * User data is held in this property
         */
        this.userSubject = new BehaviorSubject(undefined);
        /**
         * Current user as Observable
         */
        this.user$ = this.userSubject.asObservable();
        /**
         * String holding error message in case user couldn't authenticate
         */
        this.errorMessageSubject = new BehaviorSubject(undefined);
        /**
         * Error messsage in case failed authentication as Observable
         */
        this.errorMessage$ = this.errorMessageSubject.asObservable();
    }
    Object.defineProperty(AvlAuthService.prototype, "currentUser", {
        /**
         * Currently authenticated user data
         */
        get: function () {
            return this.userSubject.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvlAuthService.prototype, "errorMessage", {
        /**
         * Current error message for fail authentication
         * Undefined when user is logged in
         */
        get: function () {
            return this.errorMessageSubject.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Use to clear error message after user is informed
     */
    AvlAuthService.prototype.clearErrorMessage = function () {
        this.errorMessageSubject.next(undefined);
    };
    return AvlAuthService;
}());

var TokensPending = /** @class */ (function () {
    function TokensPending(waiting, success) {
        this.waiting = waiting;
        this.success = success;
    }
    return TokensPending;
}());

var StorageNames;
(function (StorageNames) {
    StorageNames["AccessToken"] = "access_token";
    StorageNames["AccessTokenExpiresAt"] = "access_token_expires_at";
    StorageNames["AccessTokenStoredAt"] = "access_token_stored_at";
    StorageNames["RefreshToken"] = "refresh_token";
    StorageNames["RefreshTokenExpiresAt"] = "refresh_token_expires_at";
    StorageNames["IdToken"] = "id_token";
    StorageNames["Roles"] = "roles";
    StorageNames["UserName"] = "username";
    StorageNames["Name"] = "name";
})(StorageNames || (StorageNames = {}));

var TokenStorage = /** @class */ (function () {
    function TokenStorage(prefix) {
        if (prefix === void 0) { prefix = ''; }
        this.prefix = '';
        this.prefix = prefix;
    }
    TokenStorage.prototype.readUser = function () {
        var roles = JSON.parse(this.getItem(StorageNames.Roles));
        return {
            username: this.getItem(StorageNames.UserName),
            name: this.getItem(StorageNames.Name),
            access_token: this.getItem(StorageNames.AccessToken),
            access_token_expires: this.getNumber(StorageNames.AccessTokenExpiresAt),
            access_token_stored: this.getNumber(StorageNames.AccessTokenStoredAt),
            refresh_token: this.getItem(StorageNames.RefreshToken),
            refresh_token_expires: this.getNumber(StorageNames.RefreshTokenExpiresAt),
            id_token: this.getItem(StorageNames.IdToken),
            roles: roles
        };
    };
    TokenStorage.prototype.storeUser = function (user) {
        this.setItem(StorageNames.UserName, user.username);
        this.setItem(StorageNames.Name, user.name);
        this.setItem(StorageNames.AccessToken, user.access_token);
        this.setItem(StorageNames.AccessTokenExpiresAt, "" + user.access_token_expires);
        this.setItem(StorageNames.AccessTokenStoredAt, "" + user.access_token_stored);
        this.setItem(StorageNames.RefreshToken, user.refresh_token);
        this.setItem(StorageNames.RefreshTokenExpiresAt, "" + user.refresh_token_expires);
        this.setItem(StorageNames.IdToken, user.id_token);
        var rolesStr = JSON.stringify(user.roles);
        sessionStorage.setItem(StorageNames.Roles, "" + rolesStr);
    };
    TokenStorage.prototype.clearUser = function () {
        for (var name_1 in StorageNames) {
            if (StorageNames.hasOwnProperty(name_1)) {
                this.removeItem(StorageNames[name_1]);
            }
        }
    };
    TokenStorage.prototype.getNumber = function (key) {
        return parseInt(this.getItem(key), 10);
    };
    TokenStorage.prototype.getItem = function (key) {
        return sessionStorage.getItem(this.prefix + key);
    };
    TokenStorage.prototype.setItem = function (key, value) {
        sessionStorage.setItem(this.prefix + key, value);
    };
    TokenStorage.prototype.removeItem = function (key) {
        sessionStorage.removeItem(this.prefix + key);
    };
    return TokenStorage;
}());

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var LOGOUT_CONFIG_NOT_SET_ERROR = 'User signed out locally, but logout request towards OIDC server not initiated since logoutUrl is not set in authConfig.';
var AvlOidcCodeAuthService = /** @class */ (function (_super) {
    __extends(AvlOidcCodeAuthService, _super);
    function AvlOidcCodeAuthService(httpBackend, authConfig, router, loc) {
        var _this = _super.call(this) || this;
        _this.httpBackend = httpBackend;
        _this.authConfig = authConfig;
        _this.router = router;
        _this.loc = loc;
        // success will be set after tokens are successfully fetched or not
        _this.tokensPendingSubject = new BehaviorSubject(new TokensPending(false));
        /**
         * Observable tracking if redirected from idb
         * Resolves to true on redirection, false otherwise
         */
        _this.redirectedFromLogIn = new BehaviorSubject(undefined);
        _this.http = new HttpClient(_this.httpBackend);
        _this.tokensPending$ = _this.tokensPendingSubject.asObservable();
        _this.isLoggedIn$ = new Observable(function (observer) {
            var tokensPendingState = _this.tokensPendingSubject.value;
            _this.tokensPending$
                .pipe(distinctUntilKeyChanged('waiting'), skipWhile(function (tokenPending) { return tokenPending.waiting !== false; }), map(function (tokenPending) {
                if (tokenPending.success != null) {
                    observer.next(tokenPending.success);
                }
            }), take(1))
                .subscribe();
            if (tokensPendingState.waiting !== true && tokensPendingState.success !== null) {
                observer.next(_this.currentUser != null && _this.isAccessTokenValid());
            }
        });
        _this.storage = new TokenStorage(_this.authConfig.tokenPrefix);
        var user = _this.storage.readUser();
        if (_this.isUserInvalid(user)) {
            _this.storage.clearUser();
        }
        else {
            _this.persistUser(user);
        }
        // if user is not logged in and pkce exists handle redirect from oidc server if possible
        if (_this.currentUser == null && _this.pkce) {
            _this.handleOidcRedirect();
        }
        else {
            _this.redirectedFromLogIn.next(Boolean(_this.currentUser));
        }
        return _this;
    }
    AvlOidcCodeAuthService.prototype.isUserInvalid = function (data) {
        return (data.username == null || data.access_token == null || data.access_token_expires < Date.now());
    };
    Object.defineProperty(AvlOidcCodeAuthService.prototype, "pkce", {
        get: function () {
            return this.storage.getItem('pkce') || undefined;
        },
        set: function (c) {
            if (c) {
                this.storage.setItem('pkce', c);
            }
            else {
                this.storage.removeItem('pkce');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvlOidcCodeAuthService.prototype, "nonce", {
        get: function () {
            return sessionStorage.getItem('nonce') || undefined;
        },
        set: function (c) {
            if (c) {
                this.storage.setItem('nonce', c);
            }
            else {
                this.storage.removeItem('nonce');
            }
        },
        enumerable: true,
        configurable: true
    });
    AvlOidcCodeAuthService.prototype.isAccessTokenValid = function () {
        return Date.now() < this.currentUser.access_token_expires;
    };
    AvlOidcCodeAuthService.prototype.persistUser = function (user) {
        if (!user) {
            this.clearUser();
            return;
        }
        this.storage.storeUser(user);
        this.userSubject.next(user);
    };
    AvlOidcCodeAuthService.prototype.clearUser = function () {
        this.storage.clearUser();
        this.userSubject.next(undefined);
    };
    /*
     * Checks if current url is redirect from oidc server and gets access token from the server.
     */
    AvlOidcCodeAuthService.prototype.handleOidcRedirect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var pkce, urlParts, urlHash, first, last, urlPartSplit, query, queryCode, i, nonce, httpOptions, user, error_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        pkce = this.pkce;
                        this.pkce = undefined;
                        urlParts = this.loc.path(true).split('?', 2);
                        if (urlParts.length === 2) {
                            first = urlParts[1].lastIndexOf('#');
                            if (first !== -1) {
                                last = urlParts[1].lastIndexOf('&');
                                urlHash = urlParts[1].slice(first, last);
                                urlPartSplit = urlParts[1].split('#', 2);
                                urlParts[1] = urlParts[1].split('&').pop();
                                urlParts[1] = urlPartSplit[0].concat('&').concat(urlParts[1]);
                            }
                        }
                        query = urlParts.length === 2 ? this.parseQueryString(urlParts[1]) : [];
                        for (i = query.length - 1; i >= 0; i--) {
                            if (query[i].key === 'code') {
                                queryCode = query[i].value;
                                query = __spread(query.slice(0, i), query.slice(i + 1));
                                break;
                            }
                        }
                        if (!(urlParts.length === 2 && queryCode)) return [3 /*break*/, 4];
                        nonce = this.nonce;
                        this.nonce = undefined;
                        httpOptions = {
                            headers: new HttpHeaders({
                                code: queryCode,
                                verifier: pkce,
                                nonce: nonce
                            })
                        };
                        this.updateTokensPending(new TokensPending(true));
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.http
                                .post(this.authConfig.tokenUrl, {}, httpOptions)
                                .pipe(map(function (token) { return _this.readUserFromToken(token); }))
                                .toPromise()];
                    case 2:
                        user = _a.sent();
                        this.persistUser(user);
                        this.updateTokensPending(new TokensPending(false, true));
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        this.updateTokensPending(new TokensPending(false, false), error_1.message);
                        return [3 /*break*/, 4];
                    case 4:
                        if (urlHash) {
                            this.router.navigateByUrl("" + urlParts[0] + this.reconstructQueryParamString(query) + urlHash, { replaceUrl: true });
                            this.redirectedFromLogIn.next(true);
                        }
                        else {
                            this.router.navigateByUrl("" + urlParts[0] + this.reconstructQueryParamString(query), {
                                replaceUrl: true
                            });
                            this.redirectedFromLogIn.next(Boolean(this.currentUser));
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    AvlOidcCodeAuthService.prototype.reloadPersistedUserData = function () {
        var _a;
        var user = this.storage.readUser();
        if (((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.access_token) === (user === null || user === void 0 ? void 0 : user.access_token)) {
            return;
        }
        if (this.isUserInvalid(user)) {
            this.clearUser();
        }
        else {
            this.persistUser(user);
        }
    };
    AvlOidcCodeAuthService.prototype.reconstructQueryParamString = function (queryParams) {
        var e_1, _a;
        var s = '?';
        if (queryParams.length === 0) {
            return '';
        }
        try {
            for (var queryParams_1 = __values(queryParams), queryParams_1_1 = queryParams_1.next(); !queryParams_1_1.done; queryParams_1_1 = queryParams_1.next()) {
                var q = queryParams_1_1.value;
                if (s === '?') {
                    s += encodeURIComponent(q.key) + "=" + encodeURIComponent(q.value);
                }
                else {
                    s += "&" + encodeURIComponent(q.key) + "=" + encodeURIComponent(q.value);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (queryParams_1_1 && !queryParams_1_1.done && (_a = queryParams_1.return)) _a.call(queryParams_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return s;
    };
    AvlOidcCodeAuthService.prototype.updateTokensPending = function (state, errorMessage) {
        // the order here is important
        // errorMessage will be set before isLoggedIn becomes false
        if (state.waiting === false) {
            this.errorMessageSubject.next(errorMessage);
        }
        this.tokensPendingSubject.next(state);
    };
    AvlOidcCodeAuthService.prototype.readUserFromToken = function (token) {
        var _a;
        var accessTokenClaims = this.readClaimsFromToken(token.accesstoken);
        // Calculate actual expiry date for this machine
        var accessTokenStoredAt = Date.now(); // [ms]
        var accessTokenExpiresAt = accessTokenStoredAt + token.expiresIn * 1000;
        var refreshTokenClaims = this.readClaimsFromToken(token.refreshtoken);
        var refreshTokenExpiresAt = null;
        if (refreshTokenClaims) {
            // If time value is 0 token lasts indefinitely
            var refreshTokenExpiresIn = refreshTokenClaims['exp'] !== 0 ? refreshTokenClaims['exp'] - refreshTokenClaims['iat'] : 0;
            var refreshTokenStoredAt = accessTokenStoredAt;
            refreshTokenExpiresAt =
                refreshTokenExpiresIn !== 0 ? refreshTokenStoredAt + refreshTokenExpiresIn * 1000 : 0;
        }
        var roles = accessTokenClaims === null || accessTokenClaims === void 0 ? void 0 : accessTokenClaims.roles;
        return {
            username: accessTokenClaims.preferred_username,
            name: (_a = accessTokenClaims.name) !== null && _a !== void 0 ? _a : accessTokenClaims.preferred_username,
            access_token: token.accesstoken,
            access_token_expires: accessTokenExpiresAt,
            access_token_stored: accessTokenStoredAt,
            refresh_token: token.refreshtoken,
            refresh_token_expires: refreshTokenExpiresAt,
            id_token: token.idToken,
            roles: roles
        };
    };
    AvlOidcCodeAuthService.prototype.refreshUserIfNeeded = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var accessTokenExpired;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        accessTokenExpired = ((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.access_token_expires) < Date.now();
                        if (!accessTokenExpired) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.refreshTokens()];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * If needed, this method can be called to refresh tokens for current user
     * @returns Promise resolved with object containing new tokens
     */
    AvlOidcCodeAuthService.prototype.refreshTokens = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var refreshTokenValid, httpOptions, user, error_2;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        refreshTokenValid = ((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.refresh_token_expires) > Date.now();
                        if (!refreshTokenValid) {
                            this.logout();
                            return [2 /*return*/];
                        }
                        httpOptions = {
                            headers: new HttpHeaders({
                                grant_type: 'refresh_token',
                                'refresh-token': this.storage.getItem(StorageNames.RefreshToken)
                            })
                        };
                        if (!this.authConfig.refreshUrl) {
                            throw new Error('refreshUrl missing in AuthConfig');
                        }
                        this.updateTokensPending(new TokensPending(true));
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.http
                                .post(this.authConfig.refreshUrl, {}, httpOptions)
                                .pipe(map(function (token) { return _this.readUserFromToken(token); }))
                                .toPromise()];
                    case 2:
                        user = _b.sent();
                        this.persistUser(user);
                        this.updateTokensPending(new TokensPending(false, true));
                        return [3 /*break*/, 4];
                    case 3:
                        error_2 = _b.sent();
                        this.updateTokensPending(new TokensPending(false, false), error_2.message);
                        throw error_2;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Login user and redirect after successful authentication.
     * Custom auth services need to provide implementation
     * @param redirectUrl Url to redirect after successful authentication
     */
    AvlOidcCodeAuthService.prototype.login = function (redirectUrl) {
        location.href = this.generateLoginUrl(redirectUrl ? redirectUrl : location.href);
    };
    /**
     * Log out user and redirect after.
     * Custom auth services need to provide implementation
     * @param redirectUrl Url to redirect after logging out
     */
    AvlOidcCodeAuthService.prototype.logout = function (redirectUrl) {
        var _this = this;
        var logoutUrl = this.authConfig.logoutUrl;
        if (!logoutUrl) {
            console.warn(LOGOUT_CONFIG_NOT_SET_ERROR);
        }
        var headers = new HttpHeaders({ 'refresh-token': this.currentUser.refresh_token });
        this.http
            .post(logoutUrl, {}, { headers: headers })
            .pipe(catchError(function (error) {
            _this.onLogout(redirectUrl);
            throw error;
        }))
            .subscribe(function () { return _this.onLogout(redirectUrl); });
    };
    AvlOidcCodeAuthService.prototype.onLogout = function (redirectUrl) {
        this.clearUser();
        this.redirectIfNeeded(redirectUrl);
    };
    AvlOidcCodeAuthService.prototype.redirectIfNeeded = function (redirectUrl) {
        if (redirectUrl) {
            this.navigateTo(redirectUrl);
        }
        else {
            this.reloadPage();
        }
    };
    AvlOidcCodeAuthService.prototype.reloadPage = function () {
        window.location.reload();
    };
    AvlOidcCodeAuthService.prototype.navigateTo = function (redirectUrl) {
        this.router.navigate([redirectUrl]);
    };
    AvlOidcCodeAuthService.prototype.generateLoginUrl = function (redirectUrl) {
        var redirect_b64 = '' + enc.Base64.stringify(enc.Utf8.parse(redirectUrl));
        // Generate a session value.
        var nonce = lib.WordArray.random(16).toString();
        // Generate pkce
        var pkce = lib.WordArray.random(32).toString();
        var bytes = SHA256(pkce);
        var pkce_hash = enc.Base64.stringify(bytes);
        // KeyCloak requires this - https://tools.ietf.org/html/rfc7636#appendix-A
        pkce_hash = pkce_hash.replace(/=/g, '');
        pkce_hash = pkce_hash.replace(/\+/g, '-');
        pkce_hash = pkce_hash.replace(/\//g, '_');
        this.pkce = pkce;
        this.nonce = nonce;
        var url = this.authConfig.loginUrl;
        url += '?' + this.authConfig.loginUrlParamRedirect + '=' + encodeURIComponent(redirect_b64);
        url += '&' + this.authConfig.loginUrlParamChallenge + '=' + encodeURIComponent(pkce_hash);
        url += '&' + this.authConfig.loginUrlParamNonce + '=' + encodeURIComponent(nonce);
        return url;
    };
    AvlOidcCodeAuthService.prototype.readClaimsFromToken = function (token) {
        if (!token.includes('.')) {
            // Token is not a valid JWT token
            return null;
        }
        var tokenParts = token.split('.');
        var claimsString = this.b64DecodeUnicode(tokenParts[1]);
        return JSON.parse(claimsString);
    };
    AvlOidcCodeAuthService.prototype.b64DecodeUnicode = function (str) {
        var base64 = str.replace(/\-/g, '+').replace(/\_/g, '/');
        return decodeURIComponent(atob(base64)
            .split('')
            .map(function (c) { return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2); })
            .join(''));
    };
    AvlOidcCodeAuthService.prototype.parseQueryString = function (queryString) {
        var e_2, _a;
        if (!queryString.length) {
            return [];
        }
        var queryDict = [];
        var pairs = queryString.split('&');
        try {
            for (var pairs_1 = __values(pairs), pairs_1_1 = pairs_1.next(); !pairs_1_1.done; pairs_1_1 = pairs_1.next()) {
                var pair = pairs_1_1.value;
                var index = pair.indexOf('=');
                var key = void 0;
                var value = void 0;
                if (index === -1) {
                    key = pair;
                    value = undefined;
                }
                else {
                    key = pair.substr(0, index);
                    value = pair.substr(index + 1);
                }
                queryDict.push({
                    key: decodeURIComponent(key),
                    value: decodeURIComponent(value)
                });
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (pairs_1_1 && !pairs_1_1.done && (_a = pairs_1.return)) _a.call(pairs_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return queryDict;
    };
    AvlOidcCodeAuthService.prototype.readUserFromSessionStorage = function () {
        return this.storage.readUser();
    };
    AvlOidcCodeAuthService.prototype.storeUserToSessionStorage = function (user) {
        this.storage.storeUser(user);
    };
    AvlOidcCodeAuthService.prototype.clearUserFromSessionStorage = function () {
        this.storage.clearUser();
    };
    AvlOidcCodeAuthService.ctorParameters = function () { return [
        { type: HttpBackend },
        { type: undefined, decorators: [{ type: Inject, args: [AUTH_CONFIG,] }] },
        { type: Router },
        { type: Location }
    ]; };
    AvlOidcCodeAuthService = __decorate([ __param(1, Inject(AUTH_CONFIG)),
        __metadata("design:paramtypes", [HttpBackend, Object, Router,
            Location])
    ], AvlOidcCodeAuthService);
AvlOidcCodeAuthService.ɵfac = function AvlOidcCodeAuthService_Factory(t) { return new (t || AvlOidcCodeAuthService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpBackend), ɵngcc0.ɵɵinject(AUTH_CONFIG), ɵngcc0.ɵɵinject(ɵngcc2.Router), ɵngcc0.ɵɵinject(ɵngcc3.Location)); };
AvlOidcCodeAuthService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AvlOidcCodeAuthService, factory: function (t) { return AvlOidcCodeAuthService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlOidcCodeAuthService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.HttpBackend }, { type: undefined, decorators: [{
                type: Inject,
                args: [AUTH_CONFIG]
            }] }, { type: ɵngcc2.Router }, { type: ɵngcc3.Location }]; }, null); })();
    return AvlOidcCodeAuthService;
}(AvlAuthService));

var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$1 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var AvlTokenInterceptor = /** @class */ (function () {
    function AvlTokenInterceptor(auth, basePaths) {
        this.auth = auth;
        this.basePaths = basePaths;
        for (var i in this.basePaths) {
            if (this.basePaths.hasOwnProperty(i)) {
                this.basePaths[i] = this.basePaths[i].toLowerCase();
            }
        }
    }
    AvlTokenInterceptor.prototype.intercept = function (req, next) {
        var _this = this;
        if (!this.isUrlInBasePaths(req)) {
            return next.handle(req);
        }
        if (this.auth.currentUser) {
            req = this.setAuthHeader(req);
        }
        return next
            .handle(req)
            .pipe(catchError(function (err) { return _this.handleHttpError(req, next, err); }));
    };
    AvlTokenInterceptor.prototype.handleHttpError = function (req, next, err) {
        var _this = this;
        if (err.status === 401) {
            // Unauthorized, tokens expired
            return from(this.auth.refreshTokens()).pipe(switchMap(function (_) { return next.handle(_this.setAuthHeader(req)); }), catchError(function (_) { return throwError(err); }));
        }
        return throwError(err);
    };
    /** Check if request URL is in provided basePaths
     * @param request Http request instance whose URL is checked.
     */
    AvlTokenInterceptor.prototype.isUrlInBasePaths = function (request) {
        var url = request.url.toLowerCase();
        var path = this.basePaths.find(function (path) { return url.startsWith(path); });
        return Boolean(path);
    };
    /** Sets access token to authorization header of HTTP request
     * @param request HTTP request instance
     * @returns Cloned HTTP with adapted headers
     */
    AvlTokenInterceptor.prototype.setAuthHeader = function (req) {
        var access_token = this.auth.currentUser.access_token;
        var header = "Bearer " + access_token;
        var headers = req.headers.set('Authorization', header);
        return req.clone({ headers: headers });
    };
    AvlTokenInterceptor.ctorParameters = function () { return [
        { type: AvlAuthService },
        { type: Array, decorators: [{ type: Inject, args: [INTERCEPTOR_BASE_PATHS,] }] }
    ]; };
    AvlTokenInterceptor = __decorate$1([ __param$1(1, Inject(INTERCEPTOR_BASE_PATHS)),
        __metadata$1("design:paramtypes", [AvlAuthService, Array])
    ], AvlTokenInterceptor);
AvlTokenInterceptor.ɵfac = function AvlTokenInterceptor_Factory(t) { return new (t || AvlTokenInterceptor)(ɵngcc0.ɵɵinject(AvlAuthService), ɵngcc0.ɵɵinject(INTERCEPTOR_BASE_PATHS)); };
AvlTokenInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AvlTokenInterceptor, factory: function (t) { return AvlTokenInterceptor.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlTokenInterceptor, [{
        type: Injectable
    }], function () { return [{ type: AvlAuthService }, { type: Array, decorators: [{
                type: Inject,
                args: [INTERCEPTOR_BASE_PATHS]
            }] }]; }, null); })();
    return AvlTokenInterceptor;
}());

/*
 * Public API Surface of auth
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AUTH_CONFIG, AvlAuthService, AvlOidcCodeAuthService, AvlTokenInterceptor, INTERCEPTOR_BASE_PATHS };

//# sourceMappingURL=avl-ng-controls-auth.js.map