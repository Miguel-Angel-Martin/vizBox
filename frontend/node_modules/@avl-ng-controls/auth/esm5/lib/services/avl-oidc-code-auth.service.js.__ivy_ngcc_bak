var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
import { Injectable, Inject } from '@angular/core';
import { Location } from '@angular/common';
import { HttpBackend, HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, BehaviorSubject } from 'rxjs';
import { Router } from '@angular/router';
import { map, take, distinctUntilKeyChanged, skipWhile, catchError } from 'rxjs/operators';
import * as CryptoJS from 'crypto-js';
import { AvlAuthService } from './avl-auth.service';
import { AUTH_CONFIG } from '../variables';
import { TokensPending } from './token-pending';
import { TokenStorage } from './token-storage';
import { StorageNames } from './storage-names';
var LOGOUT_CONFIG_NOT_SET_ERROR = 'User signed out locally, but logout request towards OIDC server not initiated since logoutUrl is not set in authConfig.';
var AvlOidcCodeAuthService = /** @class */ (function (_super) {
    __extends(AvlOidcCodeAuthService, _super);
    function AvlOidcCodeAuthService(httpBackend, authConfig, router, loc) {
        var _this = _super.call(this) || this;
        _this.httpBackend = httpBackend;
        _this.authConfig = authConfig;
        _this.router = router;
        _this.loc = loc;
        // success will be set after tokens are successfully fetched or not
        _this.tokensPendingSubject = new BehaviorSubject(new TokensPending(false));
        /**
         * Observable tracking if redirected from idb
         * Resolves to true on redirection, false otherwise
         */
        _this.redirectedFromLogIn = new BehaviorSubject(undefined);
        _this.http = new HttpClient(_this.httpBackend);
        _this.tokensPending$ = _this.tokensPendingSubject.asObservable();
        _this.isLoggedIn$ = new Observable(function (observer) {
            var tokensPendingState = _this.tokensPendingSubject.value;
            _this.tokensPending$
                .pipe(distinctUntilKeyChanged('waiting'), skipWhile(function (tokenPending) { return tokenPending.waiting !== false; }), map(function (tokenPending) {
                if (tokenPending.success != null) {
                    observer.next(tokenPending.success);
                }
            }), take(1))
                .subscribe();
            if (tokensPendingState.waiting !== true && tokensPendingState.success !== null) {
                observer.next(_this.currentUser != null && _this.isAccessTokenValid());
            }
        });
        _this.storage = new TokenStorage(_this.authConfig.tokenPrefix);
        var user = _this.storage.readUser();
        if (_this.isUserInvalid(user)) {
            _this.storage.clearUser();
        }
        else {
            _this.persistUser(user);
        }
        // if user is not logged in and pkce exists handle redirect from oidc server if possible
        if (_this.currentUser == null && _this.pkce) {
            _this.handleOidcRedirect();
        }
        else {
            _this.redirectedFromLogIn.next(Boolean(_this.currentUser));
        }
        return _this;
    }
    AvlOidcCodeAuthService.prototype.isUserInvalid = function (data) {
        return (data.username == null || data.access_token == null || data.access_token_expires < Date.now());
    };
    Object.defineProperty(AvlOidcCodeAuthService.prototype, "pkce", {
        get: function () {
            return this.storage.getItem('pkce') || undefined;
        },
        set: function (c) {
            if (c) {
                this.storage.setItem('pkce', c);
            }
            else {
                this.storage.removeItem('pkce');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvlOidcCodeAuthService.prototype, "nonce", {
        get: function () {
            return sessionStorage.getItem('nonce') || undefined;
        },
        set: function (c) {
            if (c) {
                this.storage.setItem('nonce', c);
            }
            else {
                this.storage.removeItem('nonce');
            }
        },
        enumerable: true,
        configurable: true
    });
    AvlOidcCodeAuthService.prototype.isAccessTokenValid = function () {
        return Date.now() < this.currentUser.access_token_expires;
    };
    AvlOidcCodeAuthService.prototype.persistUser = function (user) {
        if (!user) {
            this.clearUser();
            return;
        }
        this.storage.storeUser(user);
        this.userSubject.next(user);
    };
    AvlOidcCodeAuthService.prototype.clearUser = function () {
        this.storage.clearUser();
        this.userSubject.next(undefined);
    };
    /*
     * Checks if current url is redirect from oidc server and gets access token from the server.
     */
    AvlOidcCodeAuthService.prototype.handleOidcRedirect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var pkce, urlParts, urlHash, first, last, urlPartSplit, query, queryCode, i, nonce, httpOptions, user, error_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        pkce = this.pkce;
                        this.pkce = undefined;
                        urlParts = this.loc.path(true).split('?', 2);
                        if (urlParts.length === 2) {
                            first = urlParts[1].lastIndexOf('#');
                            if (first !== -1) {
                                last = urlParts[1].lastIndexOf('&');
                                urlHash = urlParts[1].slice(first, last);
                                urlPartSplit = urlParts[1].split('#', 2);
                                urlParts[1] = urlParts[1].split('&').pop();
                                urlParts[1] = urlPartSplit[0].concat('&').concat(urlParts[1]);
                            }
                        }
                        query = urlParts.length === 2 ? this.parseQueryString(urlParts[1]) : [];
                        for (i = query.length - 1; i >= 0; i--) {
                            if (query[i].key === 'code') {
                                queryCode = query[i].value;
                                query = __spread(query.slice(0, i), query.slice(i + 1));
                                break;
                            }
                        }
                        if (!(urlParts.length === 2 && queryCode)) return [3 /*break*/, 4];
                        nonce = this.nonce;
                        this.nonce = undefined;
                        httpOptions = {
                            headers: new HttpHeaders({
                                code: queryCode,
                                verifier: pkce,
                                nonce: nonce
                            })
                        };
                        this.updateTokensPending(new TokensPending(true));
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.http
                                .post(this.authConfig.tokenUrl, {}, httpOptions)
                                .pipe(map(function (token) { return _this.readUserFromToken(token); }))
                                .toPromise()];
                    case 2:
                        user = _a.sent();
                        this.persistUser(user);
                        this.updateTokensPending(new TokensPending(false, true));
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        this.updateTokensPending(new TokensPending(false, false), error_1.message);
                        return [3 /*break*/, 4];
                    case 4:
                        if (urlHash) {
                            this.router.navigateByUrl("" + urlParts[0] + this.reconstructQueryParamString(query) + urlHash, { replaceUrl: true });
                            this.redirectedFromLogIn.next(true);
                        }
                        else {
                            this.router.navigateByUrl("" + urlParts[0] + this.reconstructQueryParamString(query), {
                                replaceUrl: true
                            });
                            this.redirectedFromLogIn.next(Boolean(this.currentUser));
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    AvlOidcCodeAuthService.prototype.reloadPersistedUserData = function () {
        var _a;
        var user = this.storage.readUser();
        if (((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.access_token) === (user === null || user === void 0 ? void 0 : user.access_token)) {
            return;
        }
        if (this.isUserInvalid(user)) {
            this.clearUser();
        }
        else {
            this.persistUser(user);
        }
    };
    AvlOidcCodeAuthService.prototype.reconstructQueryParamString = function (queryParams) {
        var e_1, _a;
        var s = '?';
        if (queryParams.length === 0) {
            return '';
        }
        try {
            for (var queryParams_1 = __values(queryParams), queryParams_1_1 = queryParams_1.next(); !queryParams_1_1.done; queryParams_1_1 = queryParams_1.next()) {
                var q = queryParams_1_1.value;
                if (s === '?') {
                    s += encodeURIComponent(q.key) + "=" + encodeURIComponent(q.value);
                }
                else {
                    s += "&" + encodeURIComponent(q.key) + "=" + encodeURIComponent(q.value);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (queryParams_1_1 && !queryParams_1_1.done && (_a = queryParams_1.return)) _a.call(queryParams_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return s;
    };
    AvlOidcCodeAuthService.prototype.updateTokensPending = function (state, errorMessage) {
        // the order here is important
        // errorMessage will be set before isLoggedIn becomes false
        if (state.waiting === false) {
            this.errorMessageSubject.next(errorMessage);
        }
        this.tokensPendingSubject.next(state);
    };
    AvlOidcCodeAuthService.prototype.readUserFromToken = function (token) {
        var _a;
        var accessTokenClaims = this.readClaimsFromToken(token.accesstoken);
        // Calculate actual expiry date for this machine
        var accessTokenStoredAt = Date.now(); // [ms]
        var accessTokenExpiresAt = accessTokenStoredAt + token.expiresIn * 1000;
        var refreshTokenClaims = this.readClaimsFromToken(token.refreshtoken);
        var refreshTokenExpiresAt = null;
        if (refreshTokenClaims) {
            // If time value is 0 token lasts indefinitely
            var refreshTokenExpiresIn = refreshTokenClaims['exp'] !== 0 ? refreshTokenClaims['exp'] - refreshTokenClaims['iat'] : 0;
            var refreshTokenStoredAt = accessTokenStoredAt;
            refreshTokenExpiresAt =
                refreshTokenExpiresIn !== 0 ? refreshTokenStoredAt + refreshTokenExpiresIn * 1000 : 0;
        }
        var roles = accessTokenClaims === null || accessTokenClaims === void 0 ? void 0 : accessTokenClaims.roles;
        return {
            username: accessTokenClaims.preferred_username,
            name: (_a = accessTokenClaims.name) !== null && _a !== void 0 ? _a : accessTokenClaims.preferred_username,
            access_token: token.accesstoken,
            access_token_expires: accessTokenExpiresAt,
            access_token_stored: accessTokenStoredAt,
            refresh_token: token.refreshtoken,
            refresh_token_expires: refreshTokenExpiresAt,
            id_token: token.idToken,
            roles: roles
        };
    };
    AvlOidcCodeAuthService.prototype.refreshUserIfNeeded = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var accessTokenExpired;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        accessTokenExpired = ((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.access_token_expires) < Date.now();
                        if (!accessTokenExpired) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.refreshTokens()];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * If needed, this method can be called to refresh tokens for current user
     * @returns Promise resolved with object containing new tokens
     */
    AvlOidcCodeAuthService.prototype.refreshTokens = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var refreshTokenValid, httpOptions, user, error_2;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        refreshTokenValid = ((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.refresh_token_expires) > Date.now();
                        if (!refreshTokenValid) {
                            this.logout();
                            return [2 /*return*/];
                        }
                        httpOptions = {
                            headers: new HttpHeaders({
                                grant_type: 'refresh_token',
                                'refresh-token': this.storage.getItem(StorageNames.RefreshToken)
                            })
                        };
                        if (!this.authConfig.refreshUrl) {
                            throw new Error('refreshUrl missing in AuthConfig');
                        }
                        this.updateTokensPending(new TokensPending(true));
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.http
                                .post(this.authConfig.refreshUrl, {}, httpOptions)
                                .pipe(map(function (token) { return _this.readUserFromToken(token); }))
                                .toPromise()];
                    case 2:
                        user = _b.sent();
                        this.persistUser(user);
                        this.updateTokensPending(new TokensPending(false, true));
                        return [3 /*break*/, 4];
                    case 3:
                        error_2 = _b.sent();
                        this.updateTokensPending(new TokensPending(false, false), error_2.message);
                        throw error_2;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Login user and redirect after successful authentication.
     * Custom auth services need to provide implementation
     * @param redirectUrl Url to redirect after successful authentication
     */
    AvlOidcCodeAuthService.prototype.login = function (redirectUrl) {
        location.href = this.generateLoginUrl(redirectUrl ? redirectUrl : location.href);
    };
    /**
     * Log out user and redirect after.
     * Custom auth services need to provide implementation
     * @param redirectUrl Url to redirect after logging out
     */
    AvlOidcCodeAuthService.prototype.logout = function (redirectUrl) {
        var _this = this;
        var logoutUrl = this.authConfig.logoutUrl;
        if (!logoutUrl) {
            console.warn(LOGOUT_CONFIG_NOT_SET_ERROR);
        }
        var headers = new HttpHeaders({ 'refresh-token': this.currentUser.refresh_token });
        this.http
            .post(logoutUrl, {}, { headers: headers })
            .pipe(catchError(function (error) {
            _this.onLogout(redirectUrl);
            throw error;
        }))
            .subscribe(function () { return _this.onLogout(redirectUrl); });
    };
    AvlOidcCodeAuthService.prototype.onLogout = function (redirectUrl) {
        this.clearUser();
        this.redirectIfNeeded(redirectUrl);
    };
    AvlOidcCodeAuthService.prototype.redirectIfNeeded = function (redirectUrl) {
        if (redirectUrl) {
            this.navigateTo(redirectUrl);
        }
        else {
            this.reloadPage();
        }
    };
    AvlOidcCodeAuthService.prototype.reloadPage = function () {
        window.location.reload();
    };
    AvlOidcCodeAuthService.prototype.navigateTo = function (redirectUrl) {
        this.router.navigate([redirectUrl]);
    };
    AvlOidcCodeAuthService.prototype.generateLoginUrl = function (redirectUrl) {
        var redirect_b64 = '' + CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(redirectUrl));
        // Generate a session value.
        var nonce = CryptoJS.lib.WordArray.random(16).toString();
        // Generate pkce
        var pkce = CryptoJS.lib.WordArray.random(32).toString();
        var bytes = CryptoJS.SHA256(pkce);
        var pkce_hash = CryptoJS.enc.Base64.stringify(bytes);
        // KeyCloak requires this - https://tools.ietf.org/html/rfc7636#appendix-A
        pkce_hash = pkce_hash.replace(/=/g, '');
        pkce_hash = pkce_hash.replace(/\+/g, '-');
        pkce_hash = pkce_hash.replace(/\//g, '_');
        this.pkce = pkce;
        this.nonce = nonce;
        var url = this.authConfig.loginUrl;
        url += '?' + this.authConfig.loginUrlParamRedirect + '=' + encodeURIComponent(redirect_b64);
        url += '&' + this.authConfig.loginUrlParamChallenge + '=' + encodeURIComponent(pkce_hash);
        url += '&' + this.authConfig.loginUrlParamNonce + '=' + encodeURIComponent(nonce);
        return url;
    };
    AvlOidcCodeAuthService.prototype.readClaimsFromToken = function (token) {
        if (!token.includes('.')) {
            // Token is not a valid JWT token
            return null;
        }
        var tokenParts = token.split('.');
        var claimsString = this.b64DecodeUnicode(tokenParts[1]);
        return JSON.parse(claimsString);
    };
    AvlOidcCodeAuthService.prototype.b64DecodeUnicode = function (str) {
        var base64 = str.replace(/\-/g, '+').replace(/\_/g, '/');
        return decodeURIComponent(atob(base64)
            .split('')
            .map(function (c) { return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2); })
            .join(''));
    };
    AvlOidcCodeAuthService.prototype.parseQueryString = function (queryString) {
        var e_2, _a;
        if (!queryString.length) {
            return [];
        }
        var queryDict = [];
        var pairs = queryString.split('&');
        try {
            for (var pairs_1 = __values(pairs), pairs_1_1 = pairs_1.next(); !pairs_1_1.done; pairs_1_1 = pairs_1.next()) {
                var pair = pairs_1_1.value;
                var index = pair.indexOf('=');
                var key = void 0;
                var value = void 0;
                if (index === -1) {
                    key = pair;
                    value = undefined;
                }
                else {
                    key = pair.substr(0, index);
                    value = pair.substr(index + 1);
                }
                queryDict.push({
                    key: decodeURIComponent(key),
                    value: decodeURIComponent(value)
                });
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (pairs_1_1 && !pairs_1_1.done && (_a = pairs_1.return)) _a.call(pairs_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return queryDict;
    };
    AvlOidcCodeAuthService.prototype.readUserFromSessionStorage = function () {
        return this.storage.readUser();
    };
    AvlOidcCodeAuthService.prototype.storeUserToSessionStorage = function (user) {
        this.storage.storeUser(user);
    };
    AvlOidcCodeAuthService.prototype.clearUserFromSessionStorage = function () {
        this.storage.clearUser();
    };
    AvlOidcCodeAuthService.ctorParameters = function () { return [
        { type: HttpBackend },
        { type: undefined, decorators: [{ type: Inject, args: [AUTH_CONFIG,] }] },
        { type: Router },
        { type: Location }
    ]; };
    AvlOidcCodeAuthService = __decorate([
        Injectable(),
        __param(1, Inject(AUTH_CONFIG)),
        __metadata("design:paramtypes", [HttpBackend, Object, Router,
            Location])
    ], AvlOidcCodeAuthService);
    return AvlOidcCodeAuthService;
}(AvlAuthService));
export { AvlOidcCodeAuthService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZsLW9pZGMtY29kZS1hdXRoLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYXZsLW5nLWNvbnRyb2xzL2F1dGgvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvYXZsLW9pZGMtY29kZS1hdXRoLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDNUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbkQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUUzRixPQUFPLEtBQUssUUFBUSxNQUFNLFdBQVcsQ0FBQztBQUd0QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDcEQsT0FBTyxFQUFFLFdBQVcsRUFBYyxNQUFNLGNBQWMsQ0FBQztBQUN2RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDaEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRS9DLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUcvQyxJQUFNLDJCQUEyQixHQUMvQix5SEFBeUgsQ0FBQztBQUc1SDtJQUE0Qyww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QlIsV0FBQSxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUE7eUNBREMsV0FBVyxVQUVoQixNQUFNO1lBQ1QsUUFBUTtPQS9CWixzQkFBc0IsQ0F5YmxDO0lBQUQsNkJBQUM7Q0FBQSxBQXpiRCxDQUE0QyxjQUFjLEdBeWJ6RDtTQXpiWSxzQkFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTG9jYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBIdHRwQmFja2VuZCwgSHR0cENsaWVudCwgSHR0cEhlYWRlcnMgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBtYXAsIHRha2UsIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLCBza2lwV2hpbGUsIGNhdGNoRXJyb3IgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgKiBhcyBDcnlwdG9KUyBmcm9tICdjcnlwdG8tanMnO1xyXG5cclxuaW1wb3J0IHsgVXNlciB9IGZyb20gJy4uL3VzZXIubW9kZWwnO1xyXG5pbXBvcnQgeyBBdmxBdXRoU2VydmljZSB9IGZyb20gJy4vYXZsLWF1dGguc2VydmljZSc7XHJcbmltcG9ydCB7IEFVVEhfQ09ORklHLCBBdXRoQ29uZmlnIH0gZnJvbSAnLi4vdmFyaWFibGVzJztcclxuaW1wb3J0IHsgVG9rZW5zUGVuZGluZyB9IGZyb20gJy4vdG9rZW4tcGVuZGluZyc7XHJcbmltcG9ydCB7IFRva2VuU3RvcmFnZSB9IGZyb20gJy4vdG9rZW4tc3RvcmFnZSc7XHJcbmltcG9ydCB7IFRva2VuUmVzcG9uc2UgfSBmcm9tICcuL3Rva2VuLXJlc3BvbnNlJztcclxuaW1wb3J0IHsgU3RvcmFnZU5hbWVzIH0gZnJvbSAnLi9zdG9yYWdlLW5hbWVzJztcclxuaW1wb3J0IHsgVG9rZW5DbGFpbXMgfSBmcm9tICcuL3Rva2VuLWNsYWltcyc7XHJcblxyXG5jb25zdCBMT0dPVVRfQ09ORklHX05PVF9TRVRfRVJST1IgPVxyXG4gICdVc2VyIHNpZ25lZCBvdXQgbG9jYWxseSwgYnV0IGxvZ291dCByZXF1ZXN0IHRvd2FyZHMgT0lEQyBzZXJ2ZXIgbm90IGluaXRpYXRlZCBzaW5jZSBsb2dvdXRVcmwgaXMgbm90IHNldCBpbiBhdXRoQ29uZmlnLic7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBBdmxPaWRjQ29kZUF1dGhTZXJ2aWNlIGV4dGVuZHMgQXZsQXV0aFNlcnZpY2Uge1xyXG4gIC8vIHN1Y2Nlc3Mgd2lsbCBiZSBzZXQgYWZ0ZXIgdG9rZW5zIGFyZSBzdWNjZXNzZnVsbHkgZmV0Y2hlZCBvciBub3RcclxuICBwcml2YXRlIHRva2Vuc1BlbmRpbmdTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxUb2tlbnNQZW5kaW5nPihuZXcgVG9rZW5zUGVuZGluZyhmYWxzZSkpO1xyXG5cclxuICAvKipcclxuICAgKiBXaGVuIGZldGNoaW5nIHRva2VucywgdGhpcyBvYnNlcnZhYmxlIGNoYW5nZXNcclxuICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlIHdpdGggZm9sbG93aW5nIGNvbnRleHQ6XHJcbiAgICogLSB3YWl0aW5nIC0gaWYgdHJ1ZSwgcmVxdWVzdCBmb3IgbmV3IHRva2VucyBpcyBtYWRlLCB0aGlzIGhhcHBlbnMgb24gaW5pdGlhbCBhdXRoZW50aWNhdGlvbiBhbmQgb24gcmVmcmVzaFRva2Vuc1xyXG4gICAqIC0gc3VjY2VzcyAtIHRydWUgZm9yIHN1Y2Nlc3NmdWwgYXV0aGVudGljYXRpb25cclxuICAgKi9cclxuICBwdWJsaWMgdG9rZW5zUGVuZGluZyQ6IE9ic2VydmFibGU8VG9rZW5zUGVuZGluZz47XHJcblxyXG4gIC8qKlxyXG4gICAqIE9ic2VydmFibGUgdHJhY2tpbmcgYXV0aGVudGljYXRlZCBzdGF0ZVxyXG4gICAqIFJlc29sdmVzIHRvIHRydWUgb24gc3VjY2Vzc2Z1bCBsb2cgaW4sIGZhbHNlIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBpc0xvZ2dlZEluJDogT2JzZXJ2YWJsZTxib29sZWFuPjtcclxuXHJcbiAgLyoqXHJcbiAgICogT2JzZXJ2YWJsZSB0cmFja2luZyBpZiByZWRpcmVjdGVkIGZyb20gaWRiXHJcbiAgICogUmVzb2x2ZXMgdG8gdHJ1ZSBvbiByZWRpcmVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgcHVibGljIHJlZGlyZWN0ZWRGcm9tTG9nSW4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KHVuZGVmaW5lZCk7XHJcblxyXG4gIHByaXZhdGUgaHR0cDogSHR0cENsaWVudDtcclxuICBwcml2YXRlIHN0b3JhZ2U6IFRva2VuU3RvcmFnZTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIGh0dHBCYWNrZW5kOiBIdHRwQmFja2VuZCxcclxuICAgIEBJbmplY3QoQVVUSF9DT05GSUcpIHByaXZhdGUgYXV0aENvbmZpZzogQXV0aENvbmZpZyxcclxuICAgIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIsXHJcbiAgICBwcml2YXRlIGxvYzogTG9jYXRpb25cclxuICApIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5odHRwID0gbmV3IEh0dHBDbGllbnQodGhpcy5odHRwQmFja2VuZCk7XHJcblxyXG4gICAgdGhpcy50b2tlbnNQZW5kaW5nJCA9IHRoaXMudG9rZW5zUGVuZGluZ1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XHJcbiAgICB0aGlzLmlzTG9nZ2VkSW4kID0gbmV3IE9ic2VydmFibGU8Ym9vbGVhbj4ob2JzZXJ2ZXIgPT4ge1xyXG4gICAgICBjb25zdCB0b2tlbnNQZW5kaW5nU3RhdGUgPSB0aGlzLnRva2Vuc1BlbmRpbmdTdWJqZWN0LnZhbHVlO1xyXG4gICAgICB0aGlzLnRva2Vuc1BlbmRpbmckXHJcbiAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCgnd2FpdGluZycpLFxyXG4gICAgICAgICAgc2tpcFdoaWxlKHRva2VuUGVuZGluZyA9PiB0b2tlblBlbmRpbmcud2FpdGluZyAhPT0gZmFsc2UpLFxyXG4gICAgICAgICAgbWFwKHRva2VuUGVuZGluZyA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0b2tlblBlbmRpbmcuc3VjY2VzcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh0b2tlblBlbmRpbmcuc3VjY2Vzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgdGFrZSgxKVxyXG4gICAgICAgIClcclxuICAgICAgICAuc3Vic2NyaWJlKCk7XHJcbiAgICAgIGlmICh0b2tlbnNQZW5kaW5nU3RhdGUud2FpdGluZyAhPT0gdHJ1ZSAmJiB0b2tlbnNQZW5kaW5nU3RhdGUuc3VjY2VzcyAhPT0gbnVsbCkge1xyXG4gICAgICAgIG9ic2VydmVyLm5leHQodGhpcy5jdXJyZW50VXNlciAhPSBudWxsICYmIHRoaXMuaXNBY2Nlc3NUb2tlblZhbGlkKCkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgVG9rZW5TdG9yYWdlKHRoaXMuYXV0aENvbmZpZy50b2tlblByZWZpeCk7XHJcbiAgICBjb25zdCB1c2VyID0gdGhpcy5zdG9yYWdlLnJlYWRVc2VyKCk7XHJcblxyXG4gICAgaWYgKHRoaXMuaXNVc2VySW52YWxpZCh1c2VyKSkge1xyXG4gICAgICB0aGlzLnN0b3JhZ2UuY2xlYXJVc2VyKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnBlcnNpc3RVc2VyKHVzZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHVzZXIgaXMgbm90IGxvZ2dlZCBpbiBhbmQgcGtjZSBleGlzdHMgaGFuZGxlIHJlZGlyZWN0IGZyb20gb2lkYyBzZXJ2ZXIgaWYgcG9zc2libGVcclxuICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyID09IG51bGwgJiYgdGhpcy5wa2NlKSB7XHJcbiAgICAgIHRoaXMuaGFuZGxlT2lkY1JlZGlyZWN0KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnJlZGlyZWN0ZWRGcm9tTG9nSW4ubmV4dChCb29sZWFuKHRoaXMuY3VycmVudFVzZXIpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgaXNVc2VySW52YWxpZChkYXRhOiBQYXJ0aWFsPFVzZXI+KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBkYXRhLnVzZXJuYW1lID09IG51bGwgfHwgZGF0YS5hY2Nlc3NfdG9rZW4gPT0gbnVsbCB8fCBkYXRhLmFjY2Vzc190b2tlbl9leHBpcmVzIDwgRGF0ZS5ub3coKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0IHBrY2UoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSgncGtjZScpIHx8IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgcHJpdmF0ZSBzZXQgcGtjZShjOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcclxuICAgIGlmIChjKSB7XHJcbiAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKCdwa2NlJywgYyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbSgncGtjZScpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXQgbm9uY2UoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdub25jZScpIHx8IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgcHJpdmF0ZSBzZXQgbm9uY2UoYzogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAoYykge1xyXG4gICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSgnbm9uY2UnLCBjKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKCdub25jZScpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBpc0FjY2Vzc1Rva2VuVmFsaWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gRGF0ZS5ub3coKSA8IHRoaXMuY3VycmVudFVzZXIuYWNjZXNzX3Rva2VuX2V4cGlyZXM7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHBlcnNpc3RVc2VyKHVzZXI/OiBVc2VyKTogdm9pZCB7XHJcbiAgICBpZiAoIXVzZXIpIHtcclxuICAgICAgdGhpcy5jbGVhclVzZXIoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zdG9yYWdlLnN0b3JlVXNlcih1c2VyKTtcclxuICAgIHRoaXMudXNlclN1YmplY3QubmV4dCh1c2VyKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2xlYXJVc2VyKCk6IHZvaWQge1xyXG4gICAgdGhpcy5zdG9yYWdlLmNsZWFyVXNlcigpO1xyXG4gICAgdGhpcy51c2VyU3ViamVjdC5uZXh0KHVuZGVmaW5lZCk7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIENoZWNrcyBpZiBjdXJyZW50IHVybCBpcyByZWRpcmVjdCBmcm9tIG9pZGMgc2VydmVyIGFuZCBnZXRzIGFjY2VzcyB0b2tlbiBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVPaWRjUmVkaXJlY3QoKSB7XHJcbiAgICBjb25zdCBwa2NlID0gdGhpcy5wa2NlO1xyXG4gICAgdGhpcy5wa2NlID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGNvbnN0IHVybFBhcnRzID0gdGhpcy5sb2MucGF0aCh0cnVlKS5zcGxpdCgnPycsIDIpO1xyXG4gICAgbGV0IHVybEhhc2g6IHN0cmluZztcclxuICAgIGxldCBmaXJzdDogbnVtYmVyO1xyXG4gICAgbGV0IGxhc3Q6IG51bWJlcjtcclxuICAgIGxldCB1cmxQYXJ0U3BsaXQ6IHN0cmluZ1tdO1xyXG5cclxuICAgIGlmICh1cmxQYXJ0cy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgZmlyc3QgPSB1cmxQYXJ0c1sxXS5sYXN0SW5kZXhPZignIycpO1xyXG4gICAgICBpZiAoZmlyc3QgIT09IC0xKSB7XHJcbiAgICAgICAgbGFzdCA9IHVybFBhcnRzWzFdLmxhc3RJbmRleE9mKCcmJyk7XHJcbiAgICAgICAgdXJsSGFzaCA9IHVybFBhcnRzWzFdLnNsaWNlKGZpcnN0LCBsYXN0KTtcclxuICAgICAgICB1cmxQYXJ0U3BsaXQgPSB1cmxQYXJ0c1sxXS5zcGxpdCgnIycsIDIpO1xyXG4gICAgICAgIHVybFBhcnRzWzFdID0gdXJsUGFydHNbMV0uc3BsaXQoJyYnKS5wb3AoKTtcclxuICAgICAgICB1cmxQYXJ0c1sxXSA9IHVybFBhcnRTcGxpdFswXS5jb25jYXQoJyYnKS5jb25jYXQodXJsUGFydHNbMV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHF1ZXJ5ID0gdXJsUGFydHMubGVuZ3RoID09PSAyID8gdGhpcy5wYXJzZVF1ZXJ5U3RyaW5nKHVybFBhcnRzWzFdKSA6IFtdO1xyXG4gICAgbGV0IHF1ZXJ5Q29kZTogc3RyaW5nO1xyXG4gICAgZm9yIChsZXQgaSA9IHF1ZXJ5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGlmIChxdWVyeVtpXS5rZXkgPT09ICdjb2RlJykge1xyXG4gICAgICAgIHF1ZXJ5Q29kZSA9IHF1ZXJ5W2ldLnZhbHVlO1xyXG4gICAgICAgIHF1ZXJ5ID0gWy4uLnF1ZXJ5LnNsaWNlKDAsIGkpLCAuLi5xdWVyeS5zbGljZShpICsgMSldO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodXJsUGFydHMubGVuZ3RoID09PSAyICYmIHF1ZXJ5Q29kZSkge1xyXG4gICAgICBjb25zdCBub25jZSA9IHRoaXMubm9uY2U7XHJcbiAgICAgIHRoaXMubm9uY2UgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICBjb25zdCBodHRwT3B0aW9ucyA9IHtcclxuICAgICAgICBoZWFkZXJzOiBuZXcgSHR0cEhlYWRlcnMoe1xyXG4gICAgICAgICAgY29kZTogcXVlcnlDb2RlLFxyXG4gICAgICAgICAgdmVyaWZpZXI6IHBrY2UsXHJcbiAgICAgICAgICBub25jZTogbm9uY2VcclxuICAgICAgICB9KVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy51cGRhdGVUb2tlbnNQZW5kaW5nKG5ldyBUb2tlbnNQZW5kaW5nKHRydWUpKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5odHRwXHJcbiAgICAgICAgICAucG9zdDxUb2tlblJlc3BvbnNlPih0aGlzLmF1dGhDb25maWcudG9rZW5VcmwsIHt9LCBodHRwT3B0aW9ucylcclxuICAgICAgICAgIC5waXBlKG1hcCh0b2tlbiA9PiB0aGlzLnJlYWRVc2VyRnJvbVRva2VuKHRva2VuKSkpXHJcbiAgICAgICAgICAudG9Qcm9taXNlKCk7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0VXNlcih1c2VyKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRva2Vuc1BlbmRpbmcobmV3IFRva2Vuc1BlbmRpbmcoZmFsc2UsIHRydWUpKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRva2Vuc1BlbmRpbmcobmV3IFRva2Vuc1BlbmRpbmcoZmFsc2UsIGZhbHNlKSwgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodXJsSGFzaCkge1xyXG4gICAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZUJ5VXJsKFxyXG4gICAgICAgIGAke3VybFBhcnRzWzBdfSR7dGhpcy5yZWNvbnN0cnVjdFF1ZXJ5UGFyYW1TdHJpbmcocXVlcnkpfSR7dXJsSGFzaH1gLFxyXG4gICAgICAgIHsgcmVwbGFjZVVybDogdHJ1ZSB9XHJcbiAgICAgICk7XHJcbiAgICAgIHRoaXMucmVkaXJlY3RlZEZyb21Mb2dJbi5uZXh0KHRydWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybChgJHt1cmxQYXJ0c1swXX0ke3RoaXMucmVjb25zdHJ1Y3RRdWVyeVBhcmFtU3RyaW5nKHF1ZXJ5KX1gLCB7XHJcbiAgICAgICAgcmVwbGFjZVVybDogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5yZWRpcmVjdGVkRnJvbUxvZ0luLm5leHQoQm9vbGVhbih0aGlzLmN1cnJlbnRVc2VyKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgcmVsb2FkUGVyc2lzdGVkVXNlckRhdGEoKSB7XHJcbiAgICBjb25zdCB1c2VyID0gdGhpcy5zdG9yYWdlLnJlYWRVc2VyKCk7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50VXNlcj8uYWNjZXNzX3Rva2VuID09PSB1c2VyPy5hY2Nlc3NfdG9rZW4pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmlzVXNlckludmFsaWQodXNlcikpIHtcclxuICAgICAgdGhpcy5jbGVhclVzZXIoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucGVyc2lzdFVzZXIodXNlcik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHByaXZhdGUgcmVjb25zdHJ1Y3RRdWVyeVBhcmFtU3RyaW5nKHF1ZXJ5UGFyYW1zOiB7IGtleTogc3RyaW5nOyB2YWx1ZTogc3RyaW5nIH1bXSk6IHN0cmluZyB7XHJcbiAgICBsZXQgcyA9ICc/JztcclxuICAgIGlmIChxdWVyeVBhcmFtcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBxIG9mIHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICAgIGlmIChzID09PSAnPycpIHtcclxuICAgICAgICBzICs9IGAke2VuY29kZVVSSUNvbXBvbmVudChxLmtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHEudmFsdWUpfWA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcyArPSBgJiR7ZW5jb2RlVVJJQ29tcG9uZW50KHEua2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQocS52YWx1ZSl9YDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHM7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZVRva2Vuc1BlbmRpbmcoc3RhdGU6IFRva2Vuc1BlbmRpbmcsIGVycm9yTWVzc2FnZT86IHN0cmluZykge1xyXG4gICAgLy8gdGhlIG9yZGVyIGhlcmUgaXMgaW1wb3J0YW50XHJcbiAgICAvLyBlcnJvck1lc3NhZ2Ugd2lsbCBiZSBzZXQgYmVmb3JlIGlzTG9nZ2VkSW4gYmVjb21lcyBmYWxzZVxyXG4gICAgaWYgKHN0YXRlLndhaXRpbmcgPT09IGZhbHNlKSB7XHJcbiAgICAgIHRoaXMuZXJyb3JNZXNzYWdlU3ViamVjdC5uZXh0KGVycm9yTWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnRva2Vuc1BlbmRpbmdTdWJqZWN0Lm5leHQoc3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZWFkVXNlckZyb21Ub2tlbih0b2tlbjogVG9rZW5SZXNwb25zZSk6IFVzZXIge1xyXG4gICAgY29uc3QgYWNjZXNzVG9rZW5DbGFpbXMgPSB0aGlzLnJlYWRDbGFpbXNGcm9tVG9rZW4odG9rZW4uYWNjZXNzdG9rZW4pO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBhY3R1YWwgZXhwaXJ5IGRhdGUgZm9yIHRoaXMgbWFjaGluZVxyXG4gICAgY29uc3QgYWNjZXNzVG9rZW5TdG9yZWRBdCA9IERhdGUubm93KCk7IC8vIFttc11cclxuICAgIGNvbnN0IGFjY2Vzc1Rva2VuRXhwaXJlc0F0ID0gYWNjZXNzVG9rZW5TdG9yZWRBdCArIHRva2VuLmV4cGlyZXNJbiAqIDEwMDA7XHJcblxyXG4gICAgY29uc3QgcmVmcmVzaFRva2VuQ2xhaW1zID0gdGhpcy5yZWFkQ2xhaW1zRnJvbVRva2VuKHRva2VuLnJlZnJlc2h0b2tlbik7XHJcbiAgICBsZXQgcmVmcmVzaFRva2VuRXhwaXJlc0F0ID0gbnVsbDtcclxuICAgIGlmIChyZWZyZXNoVG9rZW5DbGFpbXMpIHtcclxuICAgICAgLy8gSWYgdGltZSB2YWx1ZSBpcyAwIHRva2VuIGxhc3RzIGluZGVmaW5pdGVseVxyXG4gICAgICBjb25zdCByZWZyZXNoVG9rZW5FeHBpcmVzSW4gPVxyXG4gICAgICAgIHJlZnJlc2hUb2tlbkNsYWltc1snZXhwJ10gIT09IDAgPyByZWZyZXNoVG9rZW5DbGFpbXNbJ2V4cCddIC0gcmVmcmVzaFRva2VuQ2xhaW1zWydpYXQnXSA6IDA7XHJcbiAgICAgIGNvbnN0IHJlZnJlc2hUb2tlblN0b3JlZEF0ID0gYWNjZXNzVG9rZW5TdG9yZWRBdDtcclxuICAgICAgcmVmcmVzaFRva2VuRXhwaXJlc0F0ID1cclxuICAgICAgICByZWZyZXNoVG9rZW5FeHBpcmVzSW4gIT09IDAgPyByZWZyZXNoVG9rZW5TdG9yZWRBdCArIHJlZnJlc2hUb2tlbkV4cGlyZXNJbiAqIDEwMDAgOiAwO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJvbGVzID0gYWNjZXNzVG9rZW5DbGFpbXM/LnJvbGVzO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHVzZXJuYW1lOiBhY2Nlc3NUb2tlbkNsYWltcy5wcmVmZXJyZWRfdXNlcm5hbWUsXHJcbiAgICAgIG5hbWU6IGFjY2Vzc1Rva2VuQ2xhaW1zLm5hbWUgPz8gYWNjZXNzVG9rZW5DbGFpbXMucHJlZmVycmVkX3VzZXJuYW1lLFxyXG4gICAgICBhY2Nlc3NfdG9rZW46IHRva2VuLmFjY2Vzc3Rva2VuLFxyXG4gICAgICBhY2Nlc3NfdG9rZW5fZXhwaXJlczogYWNjZXNzVG9rZW5FeHBpcmVzQXQsXHJcbiAgICAgIGFjY2Vzc190b2tlbl9zdG9yZWQ6IGFjY2Vzc1Rva2VuU3RvcmVkQXQsXHJcbiAgICAgIHJlZnJlc2hfdG9rZW46IHRva2VuLnJlZnJlc2h0b2tlbixcclxuICAgICAgcmVmcmVzaF90b2tlbl9leHBpcmVzOiByZWZyZXNoVG9rZW5FeHBpcmVzQXQsXHJcbiAgICAgIGlkX3Rva2VuOiB0b2tlbi5pZFRva2VuLFxyXG4gICAgICByb2xlczogcm9sZXNcclxuICAgIH0gYXMgVXNlcjtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyByZWZyZXNoVXNlcklmTmVlZGVkKCkge1xyXG4gICAgY29uc3QgYWNjZXNzVG9rZW5FeHBpcmVkID0gdGhpcy5jdXJyZW50VXNlcj8uYWNjZXNzX3Rva2VuX2V4cGlyZXMgPCBEYXRlLm5vdygpO1xyXG4gICAgaWYgKGFjY2Vzc1Rva2VuRXhwaXJlZCkge1xyXG4gICAgICBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlbnMoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIElmIG5lZWRlZCwgdGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byByZWZyZXNoIHRva2VucyBmb3IgY3VycmVudCB1c2VyXHJcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZlZCB3aXRoIG9iamVjdCBjb250YWluaW5nIG5ldyB0b2tlbnNcclxuICAgKi9cclxuICBwdWJsaWMgYXN5bmMgcmVmcmVzaFRva2VucygpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgY29uc3QgcmVmcmVzaFRva2VuVmFsaWQgPSB0aGlzLmN1cnJlbnRVc2VyPy5yZWZyZXNoX3Rva2VuX2V4cGlyZXMgPiBEYXRlLm5vdygpO1xyXG4gICAgaWYgKCFyZWZyZXNoVG9rZW5WYWxpZCkge1xyXG4gICAgICB0aGlzLmxvZ291dCgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaHR0cE9wdGlvbnMgPSB7XHJcbiAgICAgIGhlYWRlcnM6IG5ldyBIdHRwSGVhZGVycyh7XHJcbiAgICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxyXG4gICAgICAgICdyZWZyZXNoLXRva2VuJzogdGhpcy5zdG9yYWdlLmdldEl0ZW0oU3RvcmFnZU5hbWVzLlJlZnJlc2hUb2tlbilcclxuICAgICAgfSlcclxuICAgIH07XHJcblxyXG4gICAgaWYgKCF0aGlzLmF1dGhDb25maWcucmVmcmVzaFVybCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlZnJlc2hVcmwgbWlzc2luZyBpbiBBdXRoQ29uZmlnJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnVwZGF0ZVRva2Vuc1BlbmRpbmcobmV3IFRva2Vuc1BlbmRpbmcodHJ1ZSkpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmh0dHBcclxuICAgICAgICAucG9zdDxUb2tlblJlc3BvbnNlPih0aGlzLmF1dGhDb25maWcucmVmcmVzaFVybCwge30sIGh0dHBPcHRpb25zKVxyXG4gICAgICAgIC5waXBlKG1hcCh0b2tlbiA9PiB0aGlzLnJlYWRVc2VyRnJvbVRva2VuKHRva2VuKSkpXHJcbiAgICAgICAgLnRvUHJvbWlzZSgpO1xyXG4gICAgICB0aGlzLnBlcnNpc3RVc2VyKHVzZXIpO1xyXG4gICAgICB0aGlzLnVwZGF0ZVRva2Vuc1BlbmRpbmcobmV3IFRva2Vuc1BlbmRpbmcoZmFsc2UsIHRydWUpKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlVG9rZW5zUGVuZGluZyhuZXcgVG9rZW5zUGVuZGluZyhmYWxzZSwgZmFsc2UpLCBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2dpbiB1c2VyIGFuZCByZWRpcmVjdCBhZnRlciBzdWNjZXNzZnVsIGF1dGhlbnRpY2F0aW9uLlxyXG4gICAqIEN1c3RvbSBhdXRoIHNlcnZpY2VzIG5lZWQgdG8gcHJvdmlkZSBpbXBsZW1lbnRhdGlvblxyXG4gICAqIEBwYXJhbSByZWRpcmVjdFVybCBVcmwgdG8gcmVkaXJlY3QgYWZ0ZXIgc3VjY2Vzc2Z1bCBhdXRoZW50aWNhdGlvblxyXG4gICAqL1xyXG4gIHB1YmxpYyBsb2dpbihyZWRpcmVjdFVybD86IHN0cmluZyk6IHZvaWQge1xyXG4gICAgbG9jYXRpb24uaHJlZiA9IHRoaXMuZ2VuZXJhdGVMb2dpblVybChyZWRpcmVjdFVybCA/IHJlZGlyZWN0VXJsIDogbG9jYXRpb24uaHJlZik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2cgb3V0IHVzZXIgYW5kIHJlZGlyZWN0IGFmdGVyLlxyXG4gICAqIEN1c3RvbSBhdXRoIHNlcnZpY2VzIG5lZWQgdG8gcHJvdmlkZSBpbXBsZW1lbnRhdGlvblxyXG4gICAqIEBwYXJhbSByZWRpcmVjdFVybCBVcmwgdG8gcmVkaXJlY3QgYWZ0ZXIgbG9nZ2luZyBvdXRcclxuICAgKi9cclxuICBwdWJsaWMgbG9nb3V0KHJlZGlyZWN0VXJsPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBjb25zdCB7IGxvZ291dFVybCB9ID0gdGhpcy5hdXRoQ29uZmlnO1xyXG5cclxuICAgIGlmICghbG9nb3V0VXJsKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihMT0dPVVRfQ09ORklHX05PVF9TRVRfRVJST1IpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSHR0cEhlYWRlcnMoeyAncmVmcmVzaC10b2tlbic6IHRoaXMuY3VycmVudFVzZXIucmVmcmVzaF90b2tlbiB9KTtcclxuICAgIHRoaXMuaHR0cFxyXG4gICAgICAucG9zdChsb2dvdXRVcmwsIHt9LCB7IGhlYWRlcnMgfSlcclxuICAgICAgLnBpcGUoXHJcbiAgICAgICAgY2F0Y2hFcnJvcihlcnJvciA9PiB7XHJcbiAgICAgICAgICB0aGlzLm9uTG9nb3V0KHJlZGlyZWN0VXJsKTtcclxuICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH0pXHJcbiAgICAgIClcclxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLm9uTG9nb3V0KHJlZGlyZWN0VXJsKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG9uTG9nb3V0KHJlZGlyZWN0VXJsPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLmNsZWFyVXNlcigpO1xyXG4gICAgdGhpcy5yZWRpcmVjdElmTmVlZGVkKHJlZGlyZWN0VXJsKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVkaXJlY3RJZk5lZWRlZChyZWRpcmVjdFVybD86IHN0cmluZyk6IHZvaWQge1xyXG4gICAgaWYgKHJlZGlyZWN0VXJsKSB7XHJcbiAgICAgIHRoaXMubmF2aWdhdGVUbyhyZWRpcmVjdFVybCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnJlbG9hZFBhZ2UoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVsb2FkUGFnZSgpOiB2b2lkIHtcclxuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgbmF2aWdhdGVUbyhyZWRpcmVjdFVybDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZShbcmVkaXJlY3RVcmxdKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2VuZXJhdGVMb2dpblVybChyZWRpcmVjdFVybDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHJlZGlyZWN0X2I2NCA9ICcnICsgQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkoQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UocmVkaXJlY3RVcmwpKTtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSBhIHNlc3Npb24gdmFsdWUuXHJcbiAgICBjb25zdCBub25jZSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KS50b1N0cmluZygpO1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIHBrY2VcclxuICAgIGNvbnN0IHBrY2UgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgzMikudG9TdHJpbmcoKTtcclxuICAgIGNvbnN0IGJ5dGVzID0gQ3J5cHRvSlMuU0hBMjU2KHBrY2UpIGFzIENyeXB0b0pTLldvcmRBcnJheTtcclxuICAgIGxldCBwa2NlX2hhc2ggPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeShieXRlcyk7XHJcblxyXG4gICAgLy8gS2V5Q2xvYWsgcmVxdWlyZXMgdGhpcyAtIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NjM2I2FwcGVuZGl4LUFcclxuICAgIHBrY2VfaGFzaCA9IHBrY2VfaGFzaC5yZXBsYWNlKC89L2csICcnKTtcclxuICAgIHBrY2VfaGFzaCA9IHBrY2VfaGFzaC5yZXBsYWNlKC9cXCsvZywgJy0nKTtcclxuICAgIHBrY2VfaGFzaCA9IHBrY2VfaGFzaC5yZXBsYWNlKC9cXC8vZywgJ18nKTtcclxuXHJcbiAgICB0aGlzLnBrY2UgPSBwa2NlO1xyXG4gICAgdGhpcy5ub25jZSA9IG5vbmNlO1xyXG5cclxuICAgIGxldCB1cmwgPSB0aGlzLmF1dGhDb25maWcubG9naW5Vcmw7XHJcbiAgICB1cmwgKz0gJz8nICsgdGhpcy5hdXRoQ29uZmlnLmxvZ2luVXJsUGFyYW1SZWRpcmVjdCArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChyZWRpcmVjdF9iNjQpO1xyXG4gICAgdXJsICs9ICcmJyArIHRoaXMuYXV0aENvbmZpZy5sb2dpblVybFBhcmFtQ2hhbGxlbmdlICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBrY2VfaGFzaCk7XHJcbiAgICB1cmwgKz0gJyYnICsgdGhpcy5hdXRoQ29uZmlnLmxvZ2luVXJsUGFyYW1Ob25jZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChub25jZSk7XHJcbiAgICByZXR1cm4gdXJsO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZWFkQ2xhaW1zRnJvbVRva2VuKHRva2VuOiBzdHJpbmcpOiBUb2tlbkNsYWltcyB8IG51bGwge1xyXG4gICAgaWYgKCF0b2tlbi5pbmNsdWRlcygnLicpKSB7XHJcbiAgICAgIC8vIFRva2VuIGlzIG5vdCBhIHZhbGlkIEpXVCB0b2tlblxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHRva2VuUGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xyXG4gICAgY29uc3QgY2xhaW1zU3RyaW5nID0gdGhpcy5iNjREZWNvZGVVbmljb2RlKHRva2VuUGFydHNbMV0pO1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoY2xhaW1zU3RyaW5nKSBhcyBUb2tlbkNsYWltcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYjY0RGVjb2RlVW5pY29kZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBiYXNlNjQgPSBzdHIucmVwbGFjZSgvXFwtL2csICcrJykucmVwbGFjZSgvXFxfL2csICcvJyk7XHJcblxyXG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChcclxuICAgICAgYXRvYihiYXNlNjQpXHJcbiAgICAgICAgLnNwbGl0KCcnKVxyXG4gICAgICAgIC5tYXAoYyA9PiAnJScgKyAoJzAwJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKSlcclxuICAgICAgICAuam9pbignJylcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHBhcnNlUXVlcnlTdHJpbmcocXVlcnlTdHJpbmc6IHN0cmluZyk6IHsga2V5OiBzdHJpbmc7IHZhbHVlOiBzdHJpbmcgfVtdIHtcclxuICAgIGlmICghcXVlcnlTdHJpbmcubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGNvbnN0IHF1ZXJ5RGljdCA9IFtdO1xyXG4gICAgY29uc3QgcGFpcnMgPSBxdWVyeVN0cmluZy5zcGxpdCgnJicpO1xyXG4gICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gcGFpci5pbmRleE9mKCc9Jyk7XHJcbiAgICAgIGxldCBrZXk6IHN0cmluZztcclxuICAgICAgbGV0IHZhbHVlOiBzdHJpbmc7XHJcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBrZXkgPSBwYWlyO1xyXG4gICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGtleSA9IHBhaXIuc3Vic3RyKDAsIGluZGV4KTtcclxuICAgICAgICB2YWx1ZSA9IHBhaXIuc3Vic3RyKGluZGV4ICsgMSk7XHJcbiAgICAgIH1cclxuICAgICAgcXVlcnlEaWN0LnB1c2goe1xyXG4gICAgICAgIGtleTogZGVjb2RlVVJJQ29tcG9uZW50KGtleSksXHJcbiAgICAgICAgdmFsdWU6IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSlcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVlcnlEaWN0O1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlYWRVc2VyRnJvbVNlc3Npb25TdG9yYWdlKCk6IFVzZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5yZWFkVXNlcigpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN0b3JlVXNlclRvU2Vzc2lvblN0b3JhZ2UodXNlcjogVXNlcik6IHZvaWQge1xyXG4gICAgdGhpcy5zdG9yYWdlLnN0b3JlVXNlcih1c2VyKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBjbGVhclVzZXJGcm9tU2Vzc2lvblN0b3JhZ2UoKTogdm9pZCB7XHJcbiAgICB0aGlzLnN0b3JhZ2UuY2xlYXJVc2VyKCk7XHJcbiAgfVxyXG59XHJcbiJdfQ==