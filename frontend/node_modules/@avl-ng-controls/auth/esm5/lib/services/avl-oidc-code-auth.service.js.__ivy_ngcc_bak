var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
import { Injectable, Inject } from '@angular/core';
import { Location } from '@angular/common';
import { HttpBackend, HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, BehaviorSubject } from 'rxjs';
import { Router } from '@angular/router';
import { map, take, distinctUntilKeyChanged, skipWhile } from 'rxjs/operators';
import * as CryptoJS from 'crypto-js';
import { AvlAuthService } from './avl-auth.service';
import { AUTH_CONFIG } from '../variables';
import { TokensPending } from './token-pending';
import { TokenStorage } from './token-storage';
import { StorageNames } from './storage-names';
var AvlOidcCodeAuthService = /** @class */ (function (_super) {
    __extends(AvlOidcCodeAuthService, _super);
    function AvlOidcCodeAuthService(httpBackend, authConfig, router, loc) {
        var _this = _super.call(this) || this;
        _this.httpBackend = httpBackend;
        _this.authConfig = authConfig;
        _this.router = router;
        _this.loc = loc;
        // success will be set after tokens are successfully fetched or not
        _this.tokensPendingSubject = new BehaviorSubject(new TokensPending(false));
        /**
         * Observable tracking if redirected from idb
         * Resolves to true on redirection, false otherwise
         */
        _this.redirectedFromLogIn = new BehaviorSubject(undefined);
        _this.http = new HttpClient(_this.httpBackend);
        _this.tokensPending$ = _this.tokensPendingSubject.asObservable();
        _this.isLoggedIn$ = new Observable(function (observer) {
            var tokensPendingState = _this.tokensPendingSubject.value;
            _this.tokensPending$.pipe(distinctUntilKeyChanged('waiting'), skipWhile(function (tokenPending) { return tokenPending.waiting !== false; }), map(function (tokenPending) {
                if (tokenPending.success != null) {
                    observer.next(tokenPending.success);
                }
            }), take(1)).subscribe();
            if (tokensPendingState.waiting !== true && tokensPendingState.success !== null) {
                observer.next(_this.currentUser != null && _this.isAccessTokenValid());
            }
        });
        _this.storage = new TokenStorage(_this.authConfig.tokenPrefix);
        var user = _this.storage.readUser();
        if (_this.persistedUserInvalid(user)) {
            _this.clearUser();
        }
        else {
            _this.persistUser(user);
        }
        // if user is not logged in and pkce exists handle redirect from oidc server if possible
        if (_this.currentUser == null && _this.pkce) {
            _this.handleOidcRedirect();
        }
        else {
            _this.redirectedFromLogIn.next(Boolean(_this.currentUser));
        }
        return _this;
    }
    AvlOidcCodeAuthService.prototype.persistedUserInvalid = function (data) {
        return (data.username == null || data.access_token == null || data.access_token_expires < Date.now());
    };
    Object.defineProperty(AvlOidcCodeAuthService.prototype, "pkce", {
        get: function () {
            return this.storage.getItem('pkce') || undefined;
        },
        set: function (c) {
            if (c) {
                this.storage.setItem('pkce', c);
            }
            else {
                this.storage.removeItem('pkce');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AvlOidcCodeAuthService.prototype, "nonce", {
        get: function () {
            return sessionStorage.getItem('nonce') || undefined;
        },
        set: function (c) {
            if (c) {
                this.storage.setItem('nonce', c);
            }
            else {
                this.storage.removeItem('nonce');
            }
        },
        enumerable: true,
        configurable: true
    });
    AvlOidcCodeAuthService.prototype.isAccessTokenValid = function () {
        return Date.now() < this.currentUser.access_token_expires;
    };
    AvlOidcCodeAuthService.prototype.persistUser = function (user) {
        if (!user) {
            this.clearUser();
            return;
        }
        this.storage.storeUser(user);
        this.userSubject.next(user);
    };
    AvlOidcCodeAuthService.prototype.clearUser = function () {
        this.storage.clearUser();
        this.userSubject.next(undefined);
    };
    /*
     * Checks if current url is redirect from oidc server and gets access token from the server.
     */
    AvlOidcCodeAuthService.prototype.handleOidcRedirect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var pkce, urlParts, urlHash, first, last, urlPartSplit, query, queryCode, i, nonce, httpOptions, user, error_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        pkce = this.pkce;
                        this.pkce = undefined;
                        urlParts = this.loc.path(true).split('?', 2);
                        if (urlParts.length === 2) {
                            first = urlParts[1].lastIndexOf('#');
                            if (first !== -1) {
                                last = urlParts[1].lastIndexOf('&');
                                urlHash = urlParts[1].slice(first, last);
                                urlPartSplit = urlParts[1].split('#', 2);
                                urlParts[1] = urlParts[1].split('&').pop();
                                urlParts[1] = urlPartSplit[0].concat('&').concat(urlParts[1]);
                            }
                        }
                        query = urlParts.length === 2 ? this.parseQueryString(urlParts[1]) : [];
                        for (i = query.length - 1; i >= 0; i--) {
                            if (query[i].key === 'code') {
                                queryCode = query[i].value;
                                query = __spread(query.slice(0, i), query.slice(i + 1));
                                break;
                            }
                        }
                        if (!(urlParts.length === 2 && queryCode)) return [3 /*break*/, 4];
                        nonce = this.nonce;
                        this.nonce = undefined;
                        httpOptions = {
                            headers: new HttpHeaders({
                                code: queryCode,
                                verifier: pkce,
                                nonce: nonce
                            })
                        };
                        this.updateTokensPending(new TokensPending(true));
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.http
                                .post(this.authConfig.tokenUrl, {}, httpOptions)
                                .pipe(map(function (token) { return _this.readUserFromToken(token); }))
                                .toPromise()];
                    case 2:
                        user = _a.sent();
                        this.persistUser(user);
                        this.updateTokensPending(new TokensPending(false, true));
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        this.updateTokensPending(new TokensPending(false, false), error_1.message);
                        return [3 /*break*/, 4];
                    case 4:
                        if (urlHash) {
                            this.router.navigateByUrl("" + urlParts[0] + this.reconstructQueryParamString(query) + urlHash, { replaceUrl: true });
                            this.redirectedFromLogIn.next(true);
                        }
                        else {
                            this.router.navigateByUrl("" + urlParts[0] + this.reconstructQueryParamString(query), {
                                replaceUrl: true
                            });
                            this.redirectedFromLogIn.next(Boolean(this.currentUser));
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    AvlOidcCodeAuthService.prototype.reloadPersistedUserData = function () {
        var user = this.storage.readUser();
        if (this.persistedUserInvalid(user)) {
            this.clearUser();
        }
        else {
            this.persistUser(user);
        }
    };
    AvlOidcCodeAuthService.prototype.reconstructQueryParamString = function (queryParams) {
        var e_1, _a;
        var s = '?';
        if (queryParams.length === 0) {
            return '';
        }
        try {
            for (var queryParams_1 = __values(queryParams), queryParams_1_1 = queryParams_1.next(); !queryParams_1_1.done; queryParams_1_1 = queryParams_1.next()) {
                var q = queryParams_1_1.value;
                if (s === '?') {
                    s += encodeURIComponent(q.key) + "=" + encodeURIComponent(q.value);
                }
                else {
                    s += "&" + encodeURIComponent(q.key) + "=" + encodeURIComponent(q.value);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (queryParams_1_1 && !queryParams_1_1.done && (_a = queryParams_1.return)) _a.call(queryParams_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return s;
    };
    AvlOidcCodeAuthService.prototype.updateTokensPending = function (state, errorMessage) {
        // the order here is important
        // errorMessage will be set before isLoggedIn becomes false
        if (state.waiting === false) {
            this.errorMessageSubject.next(errorMessage);
        }
        this.tokensPendingSubject.next(state);
    };
    AvlOidcCodeAuthService.prototype.readUserFromToken = function (token) {
        var _a;
        var accessTokenClaims = this.readClaimsFromToken(token.accesstoken);
        // Calculate actual expiry date for this machine
        var accessTokenStoredAt = Date.now(); // [ms]
        var accessTokenExpiresAt = accessTokenStoredAt + token.expiresIn * 1000;
        var refreshTokenClaims = this.readClaimsFromToken(token.refreshtoken);
        var refreshTokenExpiresAt = null;
        if (refreshTokenClaims) {
            // If time value is 0 token lasts indefinitely
            var refreshTokenExpiresIn = refreshTokenClaims['exp'] !== 0 ? refreshTokenClaims['exp'] - refreshTokenClaims['iat'] : 0;
            var refreshTokenStoredAt = accessTokenStoredAt;
            refreshTokenExpiresAt =
                refreshTokenExpiresIn !== 0 ? refreshTokenStoredAt + refreshTokenExpiresIn * 1000 : 0;
        }
        var roles = accessTokenClaims === null || accessTokenClaims === void 0 ? void 0 : accessTokenClaims.roles;
        if (roles && this.hasRequiredRole(roles)) {
            this.storage.setItem(StorageNames.AccessTokenStoredAt, "" + accessTokenStoredAt);
            return {
                username: accessTokenClaims.preferred_username,
                name: (_a = accessTokenClaims.name) !== null && _a !== void 0 ? _a : accessTokenClaims.preferred_username,
                access_token: token.accesstoken,
                access_token_expires: accessTokenExpiresAt,
                refresh_token: token.refreshtoken,
                refresh_token_expires: refreshTokenExpiresAt,
                id_token: token.idToken,
                roles: roles
            };
        }
        else {
            throw new Error("Role " + this.authConfig.requiredRole + " not in claims");
        }
    };
    AvlOidcCodeAuthService.prototype.hasRequiredRole = function (roles) {
        return (!this.authConfig.requiredRole ||
            (this.authConfig.requiredRole && roles.indexOf(this.authConfig.requiredRole) !== -1));
    };
    /**
     * If needed, this method can be called to refresh tokens for current user
     * @returns Promise resolved with object containing new tokens
     */
    AvlOidcCodeAuthService.prototype.refreshTokens = function () {
        return __awaiter(this, void 0, void 0, function () {
            var httpOptions, user, error_2;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        httpOptions = {
                            headers: new HttpHeaders({
                                grant_type: 'refresh_token',
                                'refresh-token': this.storage.getItem(StorageNames.RefreshToken)
                            })
                        };
                        if (!this.authConfig.refreshUrl) {
                            throw new Error('refreshUrl missing in AuthConfig');
                        }
                        this.updateTokensPending(new TokensPending(true));
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.http
                                .post(this.authConfig.refreshUrl, {}, httpOptions)
                                .pipe(map(function (token) { return _this.readUserFromToken(token); }))
                                .toPromise()];
                    case 2:
                        user = _a.sent();
                        this.persistUser(user);
                        this.updateTokensPending(new TokensPending(false, true));
                        return [3 /*break*/, 4];
                    case 3:
                        error_2 = _a.sent();
                        this.updateTokensPending(new TokensPending(false, false), error_2.message);
                        throw error_2;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Login user and redirect after successful authentication.
     * Custom auth services need to provide implementation
     * @param redirectUrl Url to redirect after successful authentication
     */
    AvlOidcCodeAuthService.prototype.login = function (redirectUrl) {
        location.href = this.generateLoginUrl(redirectUrl ? redirectUrl : location.href);
    };
    /**
     * Log out user and redirect after.
     * Custom auth services need to provide implementation
     * @param redirectUrl Url to redirect after logging out
     */
    AvlOidcCodeAuthService.prototype.logout = function (redirectUrl) {
        var logoutConfigSet = this.authConfig.logoutUrl != null || this.authConfig.logoutUrlParamIdToken != null;
        var user = this.userSubject.getValue();
        this.clearUser();
        if (!logoutConfigSet) {
            console.warn('User signed out locally, but logout request towards OIDC server not initiated since logoutUrl or logoutUrlParamIdToken not set in authConfig.');
            return;
        }
        var url = this.authConfig.logoutUrl + "?" + this.authConfig.logoutUrlParamIdToken + "=" + encodeURIComponent(user.id_token);
        if (this.authConfig.logoutUrlParamRedirect) {
            // Avoid any query parameters for the logout redirect url
            redirectUrl = redirectUrl !== null && redirectUrl !== void 0 ? redirectUrl : location.href.split('?')[0];
            url = url + "&" + this.authConfig.logoutUrlParamRedirect + "=" + encodeURIComponent(redirectUrl);
        }
        location.href = url;
    };
    AvlOidcCodeAuthService.prototype.generateLoginUrl = function (redirectUrl) {
        var redirect_b64 = '' + CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(redirectUrl));
        // Generate a session value.
        var nonce = CryptoJS.lib.WordArray.random(16).toString();
        // Generate pkce
        var pkce = CryptoJS.lib.WordArray.random(32).toString();
        var bytes = CryptoJS.SHA256(pkce);
        var pkce_hash = CryptoJS.enc.Base64.stringify(bytes);
        // KeyCloak requires this - https://tools.ietf.org/html/rfc7636#appendix-A
        pkce_hash = pkce_hash.replace(/=/g, '');
        pkce_hash = pkce_hash.replace(/\+/g, '-');
        pkce_hash = pkce_hash.replace(/\//g, '_');
        this.pkce = pkce;
        this.nonce = nonce;
        var url = this.authConfig.loginUrl;
        url += '?' + this.authConfig.loginUrlParamRedirect + '=' + encodeURIComponent(redirect_b64);
        url += '&' + this.authConfig.loginUrlParamChallenge + '=' + encodeURIComponent(pkce_hash);
        url += '&' + this.authConfig.loginUrlParamNonce + '=' + encodeURIComponent(nonce);
        return url;
    };
    AvlOidcCodeAuthService.prototype.readClaimsFromToken = function (token) {
        if (!token.includes('.')) {
            // Token is not a valid JWT token
            return null;
        }
        var tokenParts = token.split('.');
        var claimsString = this.b64DecodeUnicode(tokenParts[1]);
        return JSON.parse(claimsString);
    };
    AvlOidcCodeAuthService.prototype.b64DecodeUnicode = function (str) {
        var base64 = str.replace(/\-/g, '+').replace(/\_/g, '/');
        return decodeURIComponent(atob(base64)
            .split('')
            .map(function (c) { return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2); })
            .join(''));
    };
    AvlOidcCodeAuthService.prototype.parseQueryString = function (queryString) {
        var e_2, _a;
        if (!queryString.length) {
            return [];
        }
        var queryDict = [];
        var pairs = queryString.split('&');
        try {
            for (var pairs_1 = __values(pairs), pairs_1_1 = pairs_1.next(); !pairs_1_1.done; pairs_1_1 = pairs_1.next()) {
                var pair = pairs_1_1.value;
                var index = pair.indexOf('=');
                var key = void 0;
                var value = void 0;
                if (index === -1) {
                    key = pair;
                    value = undefined;
                }
                else {
                    key = pair.substr(0, index);
                    value = pair.substr(index + 1);
                }
                queryDict.push({
                    key: decodeURIComponent(key),
                    value: decodeURIComponent(value)
                });
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (pairs_1_1 && !pairs_1_1.done && (_a = pairs_1.return)) _a.call(pairs_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return queryDict;
    };
    AvlOidcCodeAuthService.ctorParameters = function () { return [
        { type: HttpBackend },
        { type: undefined, decorators: [{ type: Inject, args: [AUTH_CONFIG,] }] },
        { type: Router },
        { type: Location }
    ]; };
    AvlOidcCodeAuthService = __decorate([
        Injectable(),
        __param(1, Inject(AUTH_CONFIG)),
        __metadata("design:paramtypes", [HttpBackend, Object, Router, Location])
    ], AvlOidcCodeAuthService);
    return AvlOidcCodeAuthService;
}(AvlAuthService));
export { AvlOidcCodeAuthService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZsLW9pZGMtY29kZS1hdXRoLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYXZsLW5nLWNvbnRyb2xzL2F1dGgvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvYXZsLW9pZGMtY29kZS1hdXRoLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDNUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbkQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRS9FLE9BQU8sS0FBSyxRQUFRLE1BQU0sV0FBVyxDQUFDO0FBR3RDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUsV0FBVyxFQUFjLE1BQU0sY0FBYyxDQUFDO0FBQ3ZELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNoRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFL0MsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBSy9DO0lBQTRDLDBDQUFjO0lBMkJ4RCxnQ0FBb0IsV0FBd0IsRUFBK0IsVUFBc0IsRUFDdkYsTUFB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RSxLQUFLLENBQUMsQ0FBQztvQkFDNUIsS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO2lCQUNoQztnQkFDRCxTQUFTLENBQUMsSUFBSSxDQUFDO29CQUNiLEdBQUcsRUFBRSxrQkFBa0IsQ0FBQyxHQUFHLENBQUM7b0JBQzVCLEtBQUssRUFBRSxrQkFBa0IsQ0FBQyxLQUFLLENBQUM7aUJBQ2pDLENBQUMsQ0FBQzthQUNKOzs7Ozs7Ozs7UUFDRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDOztnQkFyWGdDLFdBQVc7Z0RBQUcsTUFBTSxTQUFDLFdBQVc7Z0JBQy9DLE1BQU07Z0JBQWUsUUFBUTs7SUE1QnBDLHNCQUFzQjtRQURsQyxVQUFVLEVBQUU7UUE0Qm9DLFdBQUEsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFBO3lDQUFqQyxXQUFXLFVBQzFCLE1BQU0sRUFBZSxRQUFRO09BNUJwQyxzQkFBc0IsQ0FpWmxDO0lBQUQsNkJBQUM7Q0FBQSxBQWpaRCxDQUE0QyxjQUFjLEdBaVp6RDtTQWpaWSxzQkFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTG9jYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBIdHRwQmFja2VuZCwgSHR0cENsaWVudCwgSHR0cEhlYWRlcnMgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBtYXAsIHRha2UsIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLCBza2lwV2hpbGUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgKiBhcyBDcnlwdG9KUyBmcm9tICdjcnlwdG8tanMnO1xyXG5cclxuaW1wb3J0IHsgVXNlciB9IGZyb20gJy4uL3VzZXIubW9kZWwnO1xyXG5pbXBvcnQgeyBBdmxBdXRoU2VydmljZSB9IGZyb20gJy4vYXZsLWF1dGguc2VydmljZSc7XHJcbmltcG9ydCB7IEFVVEhfQ09ORklHLCBBdXRoQ29uZmlnIH0gZnJvbSAnLi4vdmFyaWFibGVzJztcclxuaW1wb3J0IHsgVG9rZW5zUGVuZGluZyB9IGZyb20gJy4vdG9rZW4tcGVuZGluZyc7XHJcbmltcG9ydCB7IFRva2VuU3RvcmFnZSB9IGZyb20gJy4vdG9rZW4tc3RvcmFnZSc7XHJcbmltcG9ydCB7IFRva2VuUmVzcG9uc2UgfSBmcm9tICcuL3Rva2VuLXJlc3BvbnNlJztcclxuaW1wb3J0IHsgU3RvcmFnZU5hbWVzIH0gZnJvbSAnLi9zdG9yYWdlLW5hbWVzJztcclxuaW1wb3J0IHsgVG9rZW5DbGFpbXMgfSBmcm9tICcuL3Rva2VuLWNsYWltcyc7XHJcblxyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQXZsT2lkY0NvZGVBdXRoU2VydmljZSBleHRlbmRzIEF2bEF1dGhTZXJ2aWNlIHtcclxuICAvLyBzdWNjZXNzIHdpbGwgYmUgc2V0IGFmdGVyIHRva2VucyBhcmUgc3VjY2Vzc2Z1bGx5IGZldGNoZWQgb3Igbm90XHJcbiAgcHJpdmF0ZSB0b2tlbnNQZW5kaW5nU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VG9rZW5zUGVuZGluZz4obmV3IFRva2Vuc1BlbmRpbmcoZmFsc2UpKTtcclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbiBmZXRjaGluZyB0b2tlbnMsIHRoaXMgb2JzZXJ2YWJsZSBjaGFuZ2VzXHJcbiAgICogQHJldHVybnMgT2JzZXJ2YWJsZSB3aXRoIGZvbGxvd2luZyBjb250ZXh0OlxyXG4gICAqIC0gd2FpdGluZyAtIGlmIHRydWUsIHJlcXVlc3QgZm9yIG5ldyB0b2tlbnMgaXMgbWFkZSwgdGhpcyBoYXBwZW5zIG9uIGluaXRpYWwgYXV0aGVudGljYXRpb24gYW5kIG9uIHJlZnJlc2hUb2tlbnNcclxuICAgKiAtIHN1Y2Nlc3MgLSB0cnVlIGZvciBzdWNjZXNzZnVsIGF1dGhlbnRpY2F0aW9uXHJcbiAgICovXHJcbiAgcHVibGljIHRva2Vuc1BlbmRpbmckOiBPYnNlcnZhYmxlPFRva2Vuc1BlbmRpbmc+O1xyXG5cclxuICAvKipcclxuICAgKiBPYnNlcnZhYmxlIHRyYWNraW5nIGF1dGhlbnRpY2F0ZWQgc3RhdGVcclxuICAgKiBSZXNvbHZlcyB0byB0cnVlIG9uIHN1Y2Nlc3NmdWwgbG9nIGluLCBmYWxzZSBvdGhlcndpc2VcclxuICAgKi9cclxuICBwdWJsaWMgaXNMb2dnZWRJbiQ6IE9ic2VydmFibGU8Ym9vbGVhbj47XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogT2JzZXJ2YWJsZSB0cmFja2luZyBpZiByZWRpcmVjdGVkIGZyb20gaWRiXHJcbiAgICogUmVzb2x2ZXMgdG8gdHJ1ZSBvbiByZWRpcmVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgcHVibGljIHJlZGlyZWN0ZWRGcm9tTG9nSW4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KHVuZGVmaW5lZCk7XHJcblxyXG4gIHByaXZhdGUgaHR0cDogSHR0cENsaWVudDtcclxuICBwcml2YXRlIHN0b3JhZ2U6IFRva2VuU3RvcmFnZTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBodHRwQmFja2VuZDogSHR0cEJhY2tlbmQsIEBJbmplY3QoQVVUSF9DT05GSUcpIHByaXZhdGUgYXV0aENvbmZpZzogQXV0aENvbmZpZyxcclxuICAgIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIsIHByaXZhdGUgbG9jOiBMb2NhdGlvbikge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLmh0dHAgPSBuZXcgSHR0cENsaWVudCh0aGlzLmh0dHBCYWNrZW5kKTtcclxuXHJcbiAgICB0aGlzLnRva2Vuc1BlbmRpbmckID0gdGhpcy50b2tlbnNQZW5kaW5nU3ViamVjdC5hc09ic2VydmFibGUoKTtcclxuICAgIHRoaXMuaXNMb2dnZWRJbiQgPSBuZXcgT2JzZXJ2YWJsZTxib29sZWFuPihvYnNlcnZlciA9PiB7XHJcbiAgICAgIGNvbnN0IHRva2Vuc1BlbmRpbmdTdGF0ZSA9IHRoaXMudG9rZW5zUGVuZGluZ1N1YmplY3QudmFsdWU7XHJcbiAgICAgIHRoaXMudG9rZW5zUGVuZGluZyQucGlwZShcclxuICAgICAgICBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCgnd2FpdGluZycpLFxyXG4gICAgICAgIHNraXBXaGlsZSh0b2tlblBlbmRpbmcgPT4gdG9rZW5QZW5kaW5nLndhaXRpbmcgIT09IGZhbHNlKSxcclxuICAgICAgICBtYXAodG9rZW5QZW5kaW5nID0+IHtcclxuICAgICAgICAgIGlmICh0b2tlblBlbmRpbmcuc3VjY2VzcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQodG9rZW5QZW5kaW5nLnN1Y2Nlc3MpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pLCB0YWtlKDEpKS5zdWJzY3JpYmUoKTtcclxuICAgICAgaWYgKHRva2Vuc1BlbmRpbmdTdGF0ZS53YWl0aW5nICE9PSB0cnVlICYmIHRva2Vuc1BlbmRpbmdTdGF0ZS5zdWNjZXNzICE9PSBudWxsKSB7XHJcbiAgICAgICAgb2JzZXJ2ZXIubmV4dCh0aGlzLmN1cnJlbnRVc2VyICE9IG51bGwgJiYgdGhpcy5pc0FjY2Vzc1Rva2VuVmFsaWQoKSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBUb2tlblN0b3JhZ2UodGhpcy5hdXRoQ29uZmlnLnRva2VuUHJlZml4KTtcclxuICAgIGNvbnN0IHVzZXIgPSB0aGlzLnN0b3JhZ2UucmVhZFVzZXIoKTtcclxuICAgIFxyXG4gICAgaWYgKHRoaXMucGVyc2lzdGVkVXNlckludmFsaWQodXNlcikpIHtcclxuICAgICAgdGhpcy5jbGVhclVzZXIoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucGVyc2lzdFVzZXIodXNlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgdXNlciBpcyBub3QgbG9nZ2VkIGluIGFuZCBwa2NlIGV4aXN0cyBoYW5kbGUgcmVkaXJlY3QgZnJvbSBvaWRjIHNlcnZlciBpZiBwb3NzaWJsZVxyXG4gICAgaWYgKHRoaXMuY3VycmVudFVzZXIgPT0gbnVsbCAmJiB0aGlzLnBrY2UpIHtcclxuICAgICAgdGhpcy5oYW5kbGVPaWRjUmVkaXJlY3QoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucmVkaXJlY3RlZEZyb21Mb2dJbi5uZXh0KEJvb2xlYW4odGhpcy5jdXJyZW50VXNlcikpO1xyXG4gICAgfVxyXG4gIH0gXHJcblxyXG4gIFxyXG4gIHByaXZhdGUgcGVyc2lzdGVkVXNlckludmFsaWQoZGF0YTogUGFydGlhbDxVc2VyPik6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgZGF0YS51c2VybmFtZSA9PSBudWxsIHx8IGRhdGEuYWNjZXNzX3Rva2VuID09IG51bGwgfHwgZGF0YS5hY2Nlc3NfdG9rZW5fZXhwaXJlcyA8IERhdGUubm93KClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldCBwa2NlKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmdldEl0ZW0oJ3BrY2UnKSB8fCB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIHByaXZhdGUgc2V0IHBrY2UoYzogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAoYykge1xyXG4gICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSgncGtjZScsIGMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ3BrY2UnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0IG5vbmNlKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnbm9uY2UnKSB8fCB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIHByaXZhdGUgc2V0IG5vbmNlKGM6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKGMpIHtcclxuICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0oJ25vbmNlJywgYyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnbm9uY2UnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgaXNBY2Nlc3NUb2tlblZhbGlkKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIERhdGUubm93KCkgPCB0aGlzLmN1cnJlbnRVc2VyLmFjY2Vzc190b2tlbl9leHBpcmVzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBwZXJzaXN0VXNlcih1c2VyPzogVXNlcik6IHZvaWQge1xyXG4gICAgaWYgKCF1c2VyKSB7XHJcbiAgICAgIHRoaXMuY2xlYXJVc2VyKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuc3RvcmFnZS5zdG9yZVVzZXIodXNlcik7XHJcbiAgICB0aGlzLnVzZXJTdWJqZWN0Lm5leHQodXNlcik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNsZWFyVXNlcigpOiB2b2lkIHtcclxuICAgIHRoaXMuc3RvcmFnZS5jbGVhclVzZXIoKTtcclxuICAgIHRoaXMudXNlclN1YmplY3QubmV4dCh1bmRlZmluZWQpO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBDaGVja3MgaWYgY3VycmVudCB1cmwgaXMgcmVkaXJlY3QgZnJvbSBvaWRjIHNlcnZlciBhbmQgZ2V0cyBhY2Nlc3MgdG9rZW4gZnJvbSB0aGUgc2VydmVyLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlT2lkY1JlZGlyZWN0KCkge1xyXG4gICAgY29uc3QgcGtjZSA9IHRoaXMucGtjZTtcclxuICAgIHRoaXMucGtjZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBjb25zdCB1cmxQYXJ0cyA9IHRoaXMubG9jLnBhdGgodHJ1ZSkuc3BsaXQoJz8nLCAyKTtcclxuICAgIGxldCB1cmxIYXNoOiBzdHJpbmc7XHJcbiAgICBsZXQgZmlyc3Q6IG51bWJlcjtcclxuICAgIGxldCBsYXN0OiBudW1iZXI7XHJcbiAgICBsZXQgdXJsUGFydFNwbGl0OiBzdHJpbmdbXTtcclxuXHJcbiAgICBpZiAodXJsUGFydHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgIGZpcnN0ID0gdXJsUGFydHNbMV0ubGFzdEluZGV4T2YoJyMnKTtcclxuICAgICAgaWYgKGZpcnN0ICE9PSAtMSkge1xyXG4gICAgICAgIGxhc3QgPSB1cmxQYXJ0c1sxXS5sYXN0SW5kZXhPZignJicpO1xyXG4gICAgICAgIHVybEhhc2ggPSB1cmxQYXJ0c1sxXS5zbGljZShmaXJzdCwgbGFzdCk7XHJcbiAgICAgICAgdXJsUGFydFNwbGl0ID0gdXJsUGFydHNbMV0uc3BsaXQoJyMnLCAyKTtcclxuICAgICAgICB1cmxQYXJ0c1sxXSA9IHVybFBhcnRzWzFdLnNwbGl0KCcmJykucG9wKCk7XHJcbiAgICAgICAgdXJsUGFydHNbMV0gPSB1cmxQYXJ0U3BsaXRbMF0uY29uY2F0KCcmJykuY29uY2F0KHVybFBhcnRzWzFdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBxdWVyeSA9IHVybFBhcnRzLmxlbmd0aCA9PT0gMiA/IHRoaXMucGFyc2VRdWVyeVN0cmluZyh1cmxQYXJ0c1sxXSkgOiBbXTtcclxuICAgIGxldCBxdWVyeUNvZGU6IHN0cmluZztcclxuICAgIGZvciAobGV0IGkgPSBxdWVyeS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICBpZiAocXVlcnlbaV0ua2V5ID09PSAnY29kZScpIHtcclxuICAgICAgICBxdWVyeUNvZGUgPSBxdWVyeVtpXS52YWx1ZTtcclxuICAgICAgICBxdWVyeSA9IFsuLi5xdWVyeS5zbGljZSgwLCBpKSwgLi4ucXVlcnkuc2xpY2UoaSArIDEpXTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHVybFBhcnRzLmxlbmd0aCA9PT0gMiAmJiBxdWVyeUNvZGUpIHtcclxuICAgICAgY29uc3Qgbm9uY2UgPSB0aGlzLm5vbmNlO1xyXG4gICAgICB0aGlzLm5vbmNlID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgY29uc3QgaHR0cE9wdGlvbnMgPSB7XHJcbiAgICAgICAgaGVhZGVyczogbmV3IEh0dHBIZWFkZXJzKHtcclxuICAgICAgICAgIGNvZGU6IHF1ZXJ5Q29kZSxcclxuICAgICAgICAgIHZlcmlmaWVyOiBwa2NlLFxyXG4gICAgICAgICAgbm9uY2U6IG5vbmNlXHJcbiAgICAgICAgfSlcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMudXBkYXRlVG9rZW5zUGVuZGluZyhuZXcgVG9rZW5zUGVuZGluZyh0cnVlKSk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuaHR0cFxyXG4gICAgICAgICAgLnBvc3Q8VG9rZW5SZXNwb25zZT4odGhpcy5hdXRoQ29uZmlnLnRva2VuVXJsLCB7fSwgaHR0cE9wdGlvbnMpXHJcbiAgICAgICAgICAucGlwZShtYXAodG9rZW4gPT4gdGhpcy5yZWFkVXNlckZyb21Ub2tlbih0b2tlbikpKVxyXG4gICAgICAgICAgLnRvUHJvbWlzZSgpO1xyXG4gICAgICAgIHRoaXMucGVyc2lzdFVzZXIodXNlcik7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUb2tlbnNQZW5kaW5nKG5ldyBUb2tlbnNQZW5kaW5nKGZhbHNlLCB0cnVlKSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUb2tlbnNQZW5kaW5nKG5ldyBUb2tlbnNQZW5kaW5nKGZhbHNlLCBmYWxzZSksIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHVybEhhc2gpIHtcclxuICAgICAgdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybChcclxuICAgICAgICBgJHt1cmxQYXJ0c1swXX0ke3RoaXMucmVjb25zdHJ1Y3RRdWVyeVBhcmFtU3RyaW5nKHF1ZXJ5KX0ke3VybEhhc2h9YCxcclxuICAgICAgICB7IHJlcGxhY2VVcmw6IHRydWUgfVxyXG4gICAgICApO1xyXG4gICAgICB0aGlzLnJlZGlyZWN0ZWRGcm9tTG9nSW4ubmV4dCh0cnVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwoYCR7dXJsUGFydHNbMF19JHt0aGlzLnJlY29uc3RydWN0UXVlcnlQYXJhbVN0cmluZyhxdWVyeSl9YCwge1xyXG4gICAgICAgIHJlcGxhY2VVcmw6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMucmVkaXJlY3RlZEZyb21Mb2dJbi5uZXh0KEJvb2xlYW4odGhpcy5jdXJyZW50VXNlcikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlbG9hZFBlcnNpc3RlZFVzZXJEYXRhKCkge1xyXG4gICAgY29uc3QgdXNlciA9IHRoaXMuc3RvcmFnZS5yZWFkVXNlcigpO1xyXG4gICAgXHJcbiAgICBpZiAodGhpcy5wZXJzaXN0ZWRVc2VySW52YWxpZCh1c2VyKSkge1xyXG4gICAgICB0aGlzLmNsZWFyVXNlcigpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5wZXJzaXN0VXNlcih1c2VyKTtcclxuICAgIH1cclxuICB9XHJcbiAgcHJpdmF0ZSByZWNvbnN0cnVjdFF1ZXJ5UGFyYW1TdHJpbmcocXVlcnlQYXJhbXM6IHsga2V5OiBzdHJpbmc7IHZhbHVlOiBzdHJpbmcgfVtdKTogc3RyaW5nIHtcclxuICAgIGxldCBzID0gJz8nO1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHEgb2YgcXVlcnlQYXJhbXMpIHtcclxuICAgICAgaWYgKHMgPT09ICc/Jykge1xyXG4gICAgICAgIHMgKz0gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KHEua2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQocS52YWx1ZSl9YDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzICs9IGAmJHtlbmNvZGVVUklDb21wb25lbnQocS5rZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudChxLnZhbHVlKX1gO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdXBkYXRlVG9rZW5zUGVuZGluZyhcclxuICAgIHN0YXRlOiBUb2tlbnNQZW5kaW5nLFxyXG4gICAgZXJyb3JNZXNzYWdlPzogc3RyaW5nXHJcbiAgKSB7XHJcbiAgICAvLyB0aGUgb3JkZXIgaGVyZSBpcyBpbXBvcnRhbnRcclxuICAgIC8vIGVycm9yTWVzc2FnZSB3aWxsIGJlIHNldCBiZWZvcmUgaXNMb2dnZWRJbiBiZWNvbWVzIGZhbHNlXHJcbiAgICBpZiAoc3RhdGUud2FpdGluZyA9PT0gZmFsc2UpIHtcclxuICAgICAgdGhpcy5lcnJvck1lc3NhZ2VTdWJqZWN0Lm5leHQoZXJyb3JNZXNzYWdlKTtcclxuICAgIH1cclxuICAgIHRoaXMudG9rZW5zUGVuZGluZ1N1YmplY3QubmV4dChzdGF0ZSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlYWRVc2VyRnJvbVRva2VuKHRva2VuOiBUb2tlblJlc3BvbnNlKTogVXNlciB7XHJcbiAgICBjb25zdCBhY2Nlc3NUb2tlbkNsYWltcyA9IHRoaXMucmVhZENsYWltc0Zyb21Ub2tlbih0b2tlbi5hY2Nlc3N0b2tlbik7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGFjdHVhbCBleHBpcnkgZGF0ZSBmb3IgdGhpcyBtYWNoaW5lXHJcbiAgICBjb25zdCBhY2Nlc3NUb2tlblN0b3JlZEF0ID0gRGF0ZS5ub3coKTsgLy8gW21zXVxyXG4gICAgY29uc3QgYWNjZXNzVG9rZW5FeHBpcmVzQXQgPSBhY2Nlc3NUb2tlblN0b3JlZEF0ICsgdG9rZW4uZXhwaXJlc0luICogMTAwMDtcclxuXHJcbiAgICBjb25zdCByZWZyZXNoVG9rZW5DbGFpbXMgPSB0aGlzLnJlYWRDbGFpbXNGcm9tVG9rZW4odG9rZW4ucmVmcmVzaHRva2VuKTtcclxuICAgIGxldCByZWZyZXNoVG9rZW5FeHBpcmVzQXQgPSBudWxsO1xyXG4gICAgaWYgKHJlZnJlc2hUb2tlbkNsYWltcykge1xyXG4gICAgICAvLyBJZiB0aW1lIHZhbHVlIGlzIDAgdG9rZW4gbGFzdHMgaW5kZWZpbml0ZWx5XHJcbiAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbkV4cGlyZXNJbiA9XHJcbiAgICAgICAgcmVmcmVzaFRva2VuQ2xhaW1zWydleHAnXSAhPT0gMCA/IHJlZnJlc2hUb2tlbkNsYWltc1snZXhwJ10gLSByZWZyZXNoVG9rZW5DbGFpbXNbJ2lhdCddIDogMDtcclxuICAgICAgY29uc3QgcmVmcmVzaFRva2VuU3RvcmVkQXQgPSBhY2Nlc3NUb2tlblN0b3JlZEF0O1xyXG4gICAgICByZWZyZXNoVG9rZW5FeHBpcmVzQXQgPVxyXG4gICAgICAgIHJlZnJlc2hUb2tlbkV4cGlyZXNJbiAhPT0gMCA/IHJlZnJlc2hUb2tlblN0b3JlZEF0ICsgcmVmcmVzaFRva2VuRXhwaXJlc0luICogMTAwMCA6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgcm9sZXMgPSBhY2Nlc3NUb2tlbkNsYWltcz8ucm9sZXMgYXMgc3RyaW5nW107XHJcbiAgICBpZiAocm9sZXMgJiYgdGhpcy5oYXNSZXF1aXJlZFJvbGUocm9sZXMpKSB7XHJcbiAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKFN0b3JhZ2VOYW1lcy5BY2Nlc3NUb2tlblN0b3JlZEF0LCBgJHthY2Nlc3NUb2tlblN0b3JlZEF0fWApO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZXJuYW1lOiBhY2Nlc3NUb2tlbkNsYWltcy5wcmVmZXJyZWRfdXNlcm5hbWUsXHJcbiAgICAgICAgbmFtZTogYWNjZXNzVG9rZW5DbGFpbXMubmFtZSA/PyBhY2Nlc3NUb2tlbkNsYWltcy5wcmVmZXJyZWRfdXNlcm5hbWUsXHJcbiAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlbi5hY2Nlc3N0b2tlbixcclxuICAgICAgICBhY2Nlc3NfdG9rZW5fZXhwaXJlczogYWNjZXNzVG9rZW5FeHBpcmVzQXQsXHJcbiAgICAgICAgcmVmcmVzaF90b2tlbjogdG9rZW4ucmVmcmVzaHRva2VuLFxyXG4gICAgICAgIHJlZnJlc2hfdG9rZW5fZXhwaXJlczogcmVmcmVzaFRva2VuRXhwaXJlc0F0LFxyXG4gICAgICAgIGlkX3Rva2VuOiB0b2tlbi5pZFRva2VuLFxyXG4gICAgICAgIHJvbGVzOiByb2xlc1xyXG4gICAgICB9IGFzIFVzZXI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJvbGUgJHt0aGlzLmF1dGhDb25maWcucmVxdWlyZWRSb2xlfSBub3QgaW4gY2xhaW1zYCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGhhc1JlcXVpcmVkUm9sZShyb2xlczogc3RyaW5nW10pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICF0aGlzLmF1dGhDb25maWcucmVxdWlyZWRSb2xlIHx8XHJcbiAgICAgICh0aGlzLmF1dGhDb25maWcucmVxdWlyZWRSb2xlICYmIHJvbGVzLmluZGV4T2YodGhpcy5hdXRoQ29uZmlnLnJlcXVpcmVkUm9sZSkgIT09IC0xKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIElmIG5lZWRlZCwgdGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byByZWZyZXNoIHRva2VucyBmb3IgY3VycmVudCB1c2VyXHJcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZlZCB3aXRoIG9iamVjdCBjb250YWluaW5nIG5ldyB0b2tlbnNcclxuICAgKi9cclxuICBwdWJsaWMgYXN5bmMgcmVmcmVzaFRva2VucygpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgY29uc3QgaHR0cE9wdGlvbnMgPSB7XHJcbiAgICAgIGhlYWRlcnM6IG5ldyBIdHRwSGVhZGVycyh7XHJcbiAgICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxyXG4gICAgICAgICdyZWZyZXNoLXRva2VuJzogdGhpcy5zdG9yYWdlLmdldEl0ZW0oU3RvcmFnZU5hbWVzLlJlZnJlc2hUb2tlbilcclxuICAgICAgfSlcclxuICAgIH07XHJcblxyXG4gICAgaWYgKCF0aGlzLmF1dGhDb25maWcucmVmcmVzaFVybCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlZnJlc2hVcmwgbWlzc2luZyBpbiBBdXRoQ29uZmlnJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnVwZGF0ZVRva2Vuc1BlbmRpbmcobmV3IFRva2Vuc1BlbmRpbmcodHJ1ZSkpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmh0dHBcclxuICAgICAgICAucG9zdDxUb2tlblJlc3BvbnNlPih0aGlzLmF1dGhDb25maWcucmVmcmVzaFVybCwge30sIGh0dHBPcHRpb25zKVxyXG4gICAgICAgIC5waXBlKG1hcCh0b2tlbiA9PiB0aGlzLnJlYWRVc2VyRnJvbVRva2VuKHRva2VuKSkpXHJcbiAgICAgICAgLnRvUHJvbWlzZSgpO1xyXG4gICAgICB0aGlzLnBlcnNpc3RVc2VyKHVzZXIpO1xyXG4gICAgICB0aGlzLnVwZGF0ZVRva2Vuc1BlbmRpbmcobmV3IFRva2Vuc1BlbmRpbmcoZmFsc2UsIHRydWUpKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlVG9rZW5zUGVuZGluZyhuZXcgVG9rZW5zUGVuZGluZyhmYWxzZSwgZmFsc2UpLCBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2dpbiB1c2VyIGFuZCByZWRpcmVjdCBhZnRlciBzdWNjZXNzZnVsIGF1dGhlbnRpY2F0aW9uLlxyXG4gICAqIEN1c3RvbSBhdXRoIHNlcnZpY2VzIG5lZWQgdG8gcHJvdmlkZSBpbXBsZW1lbnRhdGlvblxyXG4gICAqIEBwYXJhbSByZWRpcmVjdFVybCBVcmwgdG8gcmVkaXJlY3QgYWZ0ZXIgc3VjY2Vzc2Z1bCBhdXRoZW50aWNhdGlvblxyXG4gICAqL1xyXG4gIGxvZ2luKHJlZGlyZWN0VXJsPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBsb2NhdGlvbi5ocmVmID0gdGhpcy5nZW5lcmF0ZUxvZ2luVXJsKHJlZGlyZWN0VXJsID8gcmVkaXJlY3RVcmwgOiBsb2NhdGlvbi5ocmVmKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvZyBvdXQgdXNlciBhbmQgcmVkaXJlY3QgYWZ0ZXIuXHJcbiAgICogQ3VzdG9tIGF1dGggc2VydmljZXMgbmVlZCB0byBwcm92aWRlIGltcGxlbWVudGF0aW9uXHJcbiAgICogQHBhcmFtIHJlZGlyZWN0VXJsIFVybCB0byByZWRpcmVjdCBhZnRlciBsb2dnaW5nIG91dFxyXG4gICAqL1xyXG4gIGxvZ291dChyZWRpcmVjdFVybD86IHN0cmluZyk6IHZvaWQge1xyXG4gICAgY29uc3QgbG9nb3V0Q29uZmlnU2V0ID1cclxuICAgICAgdGhpcy5hdXRoQ29uZmlnLmxvZ291dFVybCAhPSBudWxsIHx8IHRoaXMuYXV0aENvbmZpZy5sb2dvdXRVcmxQYXJhbUlkVG9rZW4gIT0gbnVsbDtcclxuICAgIGNvbnN0IHVzZXIgPSB0aGlzLnVzZXJTdWJqZWN0LmdldFZhbHVlKCk7XHJcbiAgICB0aGlzLmNsZWFyVXNlcigpO1xyXG4gICAgaWYgKCFsb2dvdXRDb25maWdTZXQpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICdVc2VyIHNpZ25lZCBvdXQgbG9jYWxseSwgYnV0IGxvZ291dCByZXF1ZXN0IHRvd2FyZHMgT0lEQyBzZXJ2ZXIgbm90IGluaXRpYXRlZCBzaW5jZSBsb2dvdXRVcmwgb3IgbG9nb3V0VXJsUGFyYW1JZFRva2VuIG5vdCBzZXQgaW4gYXV0aENvbmZpZy4nXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCB1cmwgPSBgJHt0aGlzLmF1dGhDb25maWcubG9nb3V0VXJsfT8ke1xyXG4gICAgICB0aGlzLmF1dGhDb25maWcubG9nb3V0VXJsUGFyYW1JZFRva2VuXHJcbiAgICB9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHVzZXIuaWRfdG9rZW4pfWA7XHJcbiAgICBpZiAodGhpcy5hdXRoQ29uZmlnLmxvZ291dFVybFBhcmFtUmVkaXJlY3QpIHtcclxuICAgICAgLy8gQXZvaWQgYW55IHF1ZXJ5IHBhcmFtZXRlcnMgZm9yIHRoZSBsb2dvdXQgcmVkaXJlY3QgdXJsXHJcbiAgICAgIHJlZGlyZWN0VXJsID0gcmVkaXJlY3RVcmwgPz8gbG9jYXRpb24uaHJlZi5zcGxpdCgnPycpWzBdO1xyXG4gICAgICB1cmwgPSBgJHt1cmx9JiR7dGhpcy5hdXRoQ29uZmlnLmxvZ291dFVybFBhcmFtUmVkaXJlY3R9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHJlZGlyZWN0VXJsKX1gO1xyXG4gICAgfVxyXG4gICAgbG9jYXRpb24uaHJlZiA9IHVybDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2VuZXJhdGVMb2dpblVybChyZWRpcmVjdFVybDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHJlZGlyZWN0X2I2NCA9ICcnICsgQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkoQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UocmVkaXJlY3RVcmwpKTtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSBhIHNlc3Npb24gdmFsdWUuXHJcbiAgICBjb25zdCBub25jZSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KS50b1N0cmluZygpO1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIHBrY2VcclxuICAgIGNvbnN0IHBrY2UgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgzMikudG9TdHJpbmcoKTtcclxuICAgIGNvbnN0IGJ5dGVzID0gQ3J5cHRvSlMuU0hBMjU2KHBrY2UpIGFzIENyeXB0b0pTLldvcmRBcnJheTtcclxuICAgIGxldCBwa2NlX2hhc2ggPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeShieXRlcyk7XHJcblxyXG4gICAgLy8gS2V5Q2xvYWsgcmVxdWlyZXMgdGhpcyAtIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NjM2I2FwcGVuZGl4LUFcclxuICAgIHBrY2VfaGFzaCA9IHBrY2VfaGFzaC5yZXBsYWNlKC89L2csICcnKTtcclxuICAgIHBrY2VfaGFzaCA9IHBrY2VfaGFzaC5yZXBsYWNlKC9cXCsvZywgJy0nKTtcclxuICAgIHBrY2VfaGFzaCA9IHBrY2VfaGFzaC5yZXBsYWNlKC9cXC8vZywgJ18nKTtcclxuXHJcbiAgICB0aGlzLnBrY2UgPSBwa2NlO1xyXG4gICAgdGhpcy5ub25jZSA9IG5vbmNlO1xyXG5cclxuICAgIGxldCB1cmwgPSB0aGlzLmF1dGhDb25maWcubG9naW5Vcmw7XHJcbiAgICB1cmwgKz0gJz8nICsgdGhpcy5hdXRoQ29uZmlnLmxvZ2luVXJsUGFyYW1SZWRpcmVjdCArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChyZWRpcmVjdF9iNjQpO1xyXG4gICAgdXJsICs9ICcmJyArIHRoaXMuYXV0aENvbmZpZy5sb2dpblVybFBhcmFtQ2hhbGxlbmdlICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBrY2VfaGFzaCk7XHJcbiAgICB1cmwgKz0gJyYnICsgdGhpcy5hdXRoQ29uZmlnLmxvZ2luVXJsUGFyYW1Ob25jZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChub25jZSk7XHJcbiAgICByZXR1cm4gdXJsO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZWFkQ2xhaW1zRnJvbVRva2VuKHRva2VuOiBzdHJpbmcpOiBUb2tlbkNsYWltcyB8IG51bGwge1xyXG4gICAgaWYgKCF0b2tlbi5pbmNsdWRlcygnLicpKSB7XHJcbiAgICAgIC8vIFRva2VuIGlzIG5vdCBhIHZhbGlkIEpXVCB0b2tlblxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHRva2VuUGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xyXG4gICAgY29uc3QgY2xhaW1zU3RyaW5nID0gdGhpcy5iNjREZWNvZGVVbmljb2RlKHRva2VuUGFydHNbMV0pO1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoY2xhaW1zU3RyaW5nKSBhcyBUb2tlbkNsYWltcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYjY0RGVjb2RlVW5pY29kZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBiYXNlNjQgPSBzdHIucmVwbGFjZSgvXFwtL2csICcrJykucmVwbGFjZSgvXFxfL2csICcvJyk7XHJcblxyXG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChcclxuICAgICAgYXRvYihiYXNlNjQpXHJcbiAgICAgICAgLnNwbGl0KCcnKVxyXG4gICAgICAgIC5tYXAoYyA9PiAnJScgKyAoJzAwJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKSlcclxuICAgICAgICAuam9pbignJylcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHBhcnNlUXVlcnlTdHJpbmcocXVlcnlTdHJpbmc6IHN0cmluZyk6IHsga2V5OiBzdHJpbmc7IHZhbHVlOiBzdHJpbmcgfVtdIHtcclxuICAgIGlmICghcXVlcnlTdHJpbmcubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGNvbnN0IHF1ZXJ5RGljdCA9IFtdO1xyXG4gICAgY29uc3QgcGFpcnMgPSBxdWVyeVN0cmluZy5zcGxpdCgnJicpO1xyXG4gICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gcGFpci5pbmRleE9mKCc9Jyk7XHJcbiAgICAgIGxldCBrZXk6IHN0cmluZztcclxuICAgICAgbGV0IHZhbHVlOiBzdHJpbmc7XHJcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBrZXkgPSBwYWlyO1xyXG4gICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGtleSA9IHBhaXIuc3Vic3RyKDAsIGluZGV4KTtcclxuICAgICAgICB2YWx1ZSA9IHBhaXIuc3Vic3RyKGluZGV4ICsgMSk7XHJcbiAgICAgIH1cclxuICAgICAgcXVlcnlEaWN0LnB1c2goe1xyXG4gICAgICAgIGtleTogZGVjb2RlVVJJQ29tcG9uZW50KGtleSksXHJcbiAgICAgICAgdmFsdWU6IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSlcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVlcnlEaWN0O1xyXG4gIH1cclxufVxyXG4iXX0=