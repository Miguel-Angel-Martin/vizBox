var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
import { Injectable, Inject } from '@angular/core';
import { from, throwError } from 'rxjs';
import { catchError, switchMap } from 'rxjs/operators';
import { AvlAuthService } from './avl-auth.service';
import { INTERCEPTOR_BASE_PATHS } from '../variables';
var AvlTokenInterceptor = /** @class */ (function () {
    function AvlTokenInterceptor(auth, basePaths) {
        this.auth = auth;
        this.basePaths = basePaths;
        this.enabled = true;
        for (var i in this.basePaths) {
            if (this.basePaths.hasOwnProperty(i)) {
                this.basePaths[i] = this.basePaths[i].toLowerCase();
            }
        }
    }
    AvlTokenInterceptor.prototype.setAuthHeader = function (req) {
        var access_token = this.auth.currentUser.access_token;
        var header = "Bearer " + access_token;
        var headers = req.headers.set('Authorization', header);
        return req.clone({ headers: headers });
    };
    AvlTokenInterceptor.prototype.intercept = function (req, next) {
        var e_1, _a;
        var _this = this;
        if (!this.enabled) {
            return next.handle(req);
        }
        // check if we need to add token into request
        var url = req.url.toLowerCase();
        try {
            for (var _b = __values(this.basePaths), _c = _b.next(); !_c.done; _c = _b.next()) {
                var basePath = _c.value;
                if (url.startsWith(basePath)) {
                    if (this.auth.currentUser != null) {
                        req = this.setAuthHeader(req);
                    }
                    break;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return next.handle(req).pipe(catchError(function (err) {
            if (err.status === 401) {
                return from(_this.auth.refreshTokens()).pipe(switchMap(function (_) { return next.handle(_this.setAuthHeader(req)); }), catchError(function (_) { return throwError(err); }));
            }
            return throwError(err);
        }));
    };
    AvlTokenInterceptor.ctorParameters = function () { return [
        { type: AvlAuthService },
        { type: Array, decorators: [{ type: Inject, args: [INTERCEPTOR_BASE_PATHS,] }] }
    ]; };
    AvlTokenInterceptor = __decorate([
        Injectable(),
        __param(1, Inject(INTERCEPTOR_BASE_PATHS)),
        __metadata("design:paramtypes", [AvlAuthService, Array])
    ], AvlTokenInterceptor);
    return AvlTokenInterceptor;
}());
export { AvlTokenInterceptor };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZsLXRva2VuLmludGVyY2VwdG9yLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGF2bC1uZy1jb250cm9scy9hdXRoLyIsInNvdXJjZXMiOlsibGliL3NlcnZpY2VzL2F2bC10b2tlbi5pbnRlcmNlcHRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBUW5ELE9BQU8sRUFBYyxJQUFJLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3BELE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFdkQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3BELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUd0RDtJQUdFLDZCQUNTLElBQW9CLEVBQ2UsU0FBbUI7UUFEdEQsU0FBSSxHQUFKLElBQUksQ0FBZ0I7UUFDZSxjQUFTLEdBQVQsU0FBUyxDQUFVO1FBSnJELFlBQU8sR0FBRyxJQUFJLENBQUM7UUFNdkIsS0FBSyxJQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQzlCLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3BDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUNyRDtTQUNGO0lBQ0gsQ0FBQztJQUVPLDJDQUFhLEdBQXJCLFVBQXNCLEdBQXFCO1FBQ3pDLElBQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQztRQUN4RCxJQUFNLE1BQU0sR0FBRyxZQUFVLFlBQWMsQ0FBQztRQUN4QyxJQUFNLE9BQU8sR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxlQUFlLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFekQsT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsT0FBTyxTQUFBLEVBQUUsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRCx1Q0FBUyxHQUFULFVBQVUsR0FBcUIsRUFBRSxJQUFpQjs7UUFBbEQsaUJBMkJDO1FBMUJDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2pCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN6QjtRQUVELDZDQUE2QztRQUM3QyxJQUFNLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDOztZQUNsQyxLQUF1QixJQUFBLEtBQUEsU0FBQSxJQUFJLENBQUMsU0FBUyxDQUFBLGdCQUFBLDRCQUFFO2dCQUFsQyxJQUFNLFFBQVEsV0FBQTtnQkFDakIsSUFBSSxHQUFHLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxFQUFFO29CQUM1QixJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksRUFBRTt3QkFDakMsR0FBRyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7cUJBQy9CO29CQUNELE1BQU07aUJBQ1A7YUFDRjs7Ozs7Ozs7O1FBRUQsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FDMUIsVUFBVSxDQUFDLFVBQUMsR0FBc0I7WUFDaEMsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLEdBQUcsRUFBRTtnQkFDdEIsT0FBTyxJQUFJLENBQUMsS0FBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FDekMsU0FBUyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQXBDLENBQW9DLENBQUMsRUFDcEQsVUFBVSxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFmLENBQWUsQ0FBQyxDQUNqQyxDQUFDO2FBQ0g7WUFDRCxPQUFPLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6QixDQUFDLENBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQzs7Z0JBN0NjLGNBQWM7NENBQzFCLE1BQU0sU0FBQyxzQkFBc0I7O0lBTHJCLG1CQUFtQjtRQUQvQixVQUFVLEVBQUU7UUFNUixXQUFBLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFBO3lDQURsQixjQUFjO09BSmxCLG1CQUFtQixDQWtEL0I7SUFBRCwwQkFBQztDQUFBLEFBbERELElBa0RDO1NBbERZLG1CQUFtQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge1xyXG4gIEh0dHBSZXF1ZXN0LFxyXG4gIEh0dHBIYW5kbGVyLFxyXG4gIEh0dHBFdmVudCxcclxuICBIdHRwSW50ZXJjZXB0b3IsXHJcbiAgSHR0cEVycm9yUmVzcG9uc2VcclxufSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIGZyb20sIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgY2F0Y2hFcnJvciwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgQXZsQXV0aFNlcnZpY2UgfSBmcm9tICcuL2F2bC1hdXRoLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJTlRFUkNFUFRPUl9CQVNFX1BBVEhTIH0gZnJvbSAnLi4vdmFyaWFibGVzJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEF2bFRva2VuSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xyXG4gIHByb3RlY3RlZCBlbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwdWJsaWMgYXV0aDogQXZsQXV0aFNlcnZpY2UsXHJcbiAgICBASW5qZWN0KElOVEVSQ0VQVE9SX0JBU0VfUEFUSFMpIHByb3RlY3RlZCBiYXNlUGF0aHM6IHN0cmluZ1tdXHJcbiAgKSB7XHJcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5iYXNlUGF0aHMpIHtcclxuICAgICAgaWYgKHRoaXMuYmFzZVBhdGhzLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgICAgdGhpcy5iYXNlUGF0aHNbaV0gPSB0aGlzLmJhc2VQYXRoc1tpXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNldEF1dGhIZWFkZXIocmVxOiBIdHRwUmVxdWVzdDxhbnk+KTogSHR0cFJlcXVlc3Q8YW55PiB7XHJcbiAgICBjb25zdCBhY2Nlc3NfdG9rZW4gPSB0aGlzLmF1dGguY3VycmVudFVzZXIuYWNjZXNzX3Rva2VuO1xyXG4gICAgY29uc3QgaGVhZGVyID0gYEJlYXJlciAke2FjY2Vzc190b2tlbn1gO1xyXG4gICAgY29uc3QgaGVhZGVycyA9IHJlcS5oZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGhlYWRlcik7XHJcblxyXG4gICAgcmV0dXJuIHJlcS5jbG9uZSh7IGhlYWRlcnMgfSk7XHJcbiAgfVxyXG5cclxuICBpbnRlcmNlcHQocmVxOiBIdHRwUmVxdWVzdDxhbnk+LCBuZXh0OiBIdHRwSGFuZGxlcik6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+IHtcclxuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XHJcbiAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gYWRkIHRva2VuIGludG8gcmVxdWVzdFxyXG4gICAgY29uc3QgdXJsID0gcmVxLnVybC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgZm9yIChjb25zdCBiYXNlUGF0aCBvZiB0aGlzLmJhc2VQYXRocykge1xyXG4gICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoYmFzZVBhdGgpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0aC5jdXJyZW50VXNlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICByZXEgPSB0aGlzLnNldEF1dGhIZWFkZXIocmVxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKS5waXBlKFxyXG4gICAgICBjYXRjaEVycm9yKChlcnI6IEh0dHBFcnJvclJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgaWYgKGVyci5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hdXRoLnJlZnJlc2hUb2tlbnMoKSkucGlwZShcclxuICAgICAgICAgICAgc3dpdGNoTWFwKF8gPT4gbmV4dC5oYW5kbGUodGhpcy5zZXRBdXRoSGVhZGVyKHJlcSkpKSxcclxuICAgICAgICAgICAgY2F0Y2hFcnJvcihfID0+IHRocm93RXJyb3IoZXJyKSlcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycik7XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG4iXX0=