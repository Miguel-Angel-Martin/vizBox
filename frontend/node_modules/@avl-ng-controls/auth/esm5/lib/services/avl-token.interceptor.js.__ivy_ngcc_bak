var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { Injectable, Inject } from '@angular/core';
import { from, throwError } from 'rxjs';
import { catchError, switchMap } from 'rxjs/operators';
import { AvlAuthService } from './avl-auth.service';
import { INTERCEPTOR_BASE_PATHS } from '../variables';
var AvlTokenInterceptor = /** @class */ (function () {
    function AvlTokenInterceptor(auth, basePaths) {
        this.auth = auth;
        this.basePaths = basePaths;
        for (var i in this.basePaths) {
            if (this.basePaths.hasOwnProperty(i)) {
                this.basePaths[i] = this.basePaths[i].toLowerCase();
            }
        }
    }
    AvlTokenInterceptor.prototype.intercept = function (req, next) {
        var _this = this;
        if (!this.isUrlInBasePaths(req)) {
            return next.handle(req);
        }
        if (this.auth.currentUser) {
            req = this.setAuthHeader(req);
        }
        return next
            .handle(req)
            .pipe(catchError(function (err) { return _this.handleHttpError(req, next, err); }));
    };
    AvlTokenInterceptor.prototype.handleHttpError = function (req, next, err) {
        var _this = this;
        if (err.status === 401) {
            // Unauthorized, tokens expired
            return from(this.auth.refreshTokens()).pipe(switchMap(function (_) { return next.handle(_this.setAuthHeader(req)); }), catchError(function (_) { return throwError(err); }));
        }
        return throwError(err);
    };
    /** Check if request URL is in provided basePaths
     * @param request Http request instance whose URL is checked.
     */
    AvlTokenInterceptor.prototype.isUrlInBasePaths = function (request) {
        var url = request.url.toLowerCase();
        var path = this.basePaths.find(function (path) { return url.startsWith(path); });
        return Boolean(path);
    };
    /** Sets access token to authorization header of HTTP request
     * @param request HTTP request instance
     * @returns Cloned HTTP with adapted headers
     */
    AvlTokenInterceptor.prototype.setAuthHeader = function (req) {
        var access_token = this.auth.currentUser.access_token;
        var header = "Bearer " + access_token;
        var headers = req.headers.set('Authorization', header);
        return req.clone({ headers: headers });
    };
    AvlTokenInterceptor.ctorParameters = function () { return [
        { type: AvlAuthService },
        { type: Array, decorators: [{ type: Inject, args: [INTERCEPTOR_BASE_PATHS,] }] }
    ]; };
    AvlTokenInterceptor = __decorate([
        Injectable(),
        __param(1, Inject(INTERCEPTOR_BASE_PATHS)),
        __metadata("design:paramtypes", [AvlAuthService, Array])
    ], AvlTokenInterceptor);
    return AvlTokenInterceptor;
}());
export { AvlTokenInterceptor };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZsLXRva2VuLmludGVyY2VwdG9yLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGF2bC1uZy1jb250cm9scy9hdXRoLyIsInNvdXJjZXMiOlsibGliL3NlcnZpY2VzL2F2bC10b2tlbi5pbnRlcmNlcHRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQVFuRCxPQUFPLEVBQWMsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNwRCxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXZELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFHdEQ7SUFDRSw2QkFDUyxJQUFvQixFQUNlLFNBQW1CO1FBRHRELFNBQUksR0FBSixJQUFJLENBQWdCO1FBQ2UsY0FBUyxHQUFULFNBQVMsQ0FBVTtRQUU3RCxLQUFLLElBQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDOUIsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRTtnQkFDcEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO2FBQ3JEO1NBQ0Y7SUFDSCxDQUFDO0lBRUQsdUNBQVMsR0FBVCxVQUFVLEdBQXFCLEVBQUUsSUFBaUI7UUFBbEQsaUJBWUM7UUFYQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQy9CLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN6QjtRQUVELElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDekIsR0FBRyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDL0I7UUFFRCxPQUFPLElBQUk7YUFDUixNQUFNLENBQUMsR0FBRyxDQUFDO2FBQ1gsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFDLEdBQXNCLElBQUssT0FBQSxLQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQXBDLENBQW9DLENBQUMsQ0FBQyxDQUFDO0lBQ3hGLENBQUM7SUFFTyw2Q0FBZSxHQUF2QixVQUNFLEdBQXFCLEVBQ3JCLElBQWlCLEVBQ2pCLEdBQXNCO1FBSHhCLGlCQWFDO1FBUkMsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLEdBQUcsRUFBRTtZQUN0QiwrQkFBK0I7WUFDL0IsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FDekMsU0FBUyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQXBDLENBQW9DLENBQUMsRUFDcEQsVUFBVSxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFmLENBQWUsQ0FBQyxDQUNqQyxDQUFDO1NBQ0g7UUFDRCxPQUFPLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRUQ7O09BRUc7SUFDSyw4Q0FBZ0IsR0FBeEIsVUFBeUIsT0FBeUI7UUFDaEQsSUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN0QyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFBLElBQUksSUFBSSxPQUFBLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQXBCLENBQW9CLENBQUMsQ0FBQztRQUMvRCxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssMkNBQWEsR0FBckIsVUFBc0IsR0FBcUI7UUFDekMsSUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDO1FBQ3hELElBQU0sTUFBTSxHQUFHLFlBQVUsWUFBYyxDQUFDO1FBQ3hDLElBQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLGVBQWUsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUV6RCxPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxPQUFPLFNBQUEsRUFBRSxDQUFDLENBQUM7SUFDaEMsQ0FBQzs7Z0JBMURjLGNBQWM7NENBQzFCLE1BQU0sU0FBQyxzQkFBc0I7O0lBSHJCLG1CQUFtQjtRQUQvQixVQUFVLEVBQUU7UUFJUixXQUFBLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFBO3lDQURsQixjQUFjO09BRmxCLG1CQUFtQixDQTZEL0I7SUFBRCwwQkFBQztDQUFBLEFBN0RELElBNkRDO1NBN0RZLG1CQUFtQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge1xyXG4gIEh0dHBSZXF1ZXN0LFxyXG4gIEh0dHBIYW5kbGVyLFxyXG4gIEh0dHBFdmVudCxcclxuICBIdHRwSW50ZXJjZXB0b3IsXHJcbiAgSHR0cEVycm9yUmVzcG9uc2VcclxufSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIGZyb20sIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgY2F0Y2hFcnJvciwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgQXZsQXV0aFNlcnZpY2UgfSBmcm9tICcuL2F2bC1hdXRoLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJTlRFUkNFUFRPUl9CQVNFX1BBVEhTIH0gZnJvbSAnLi4vdmFyaWFibGVzJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEF2bFRva2VuSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHVibGljIGF1dGg6IEF2bEF1dGhTZXJ2aWNlLFxyXG4gICAgQEluamVjdChJTlRFUkNFUFRPUl9CQVNFX1BBVEhTKSBwcm90ZWN0ZWQgYmFzZVBhdGhzOiBzdHJpbmdbXVxyXG4gICkge1xyXG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuYmFzZVBhdGhzKSB7XHJcbiAgICAgIGlmICh0aGlzLmJhc2VQYXRocy5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICAgIHRoaXMuYmFzZVBhdGhzW2ldID0gdGhpcy5iYXNlUGF0aHNbaV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaW50ZXJjZXB0KHJlcTogSHR0cFJlcXVlc3Q8YW55PiwgbmV4dDogSHR0cEhhbmRsZXIpOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PiB7XHJcbiAgICBpZiAoIXRoaXMuaXNVcmxJbkJhc2VQYXRocyhyZXEpKSB7XHJcbiAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmF1dGguY3VycmVudFVzZXIpIHtcclxuICAgICAgcmVxID0gdGhpcy5zZXRBdXRoSGVhZGVyKHJlcSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5leHRcclxuICAgICAgLmhhbmRsZShyZXEpXHJcbiAgICAgIC5waXBlKGNhdGNoRXJyb3IoKGVycjogSHR0cEVycm9yUmVzcG9uc2UpID0+IHRoaXMuaGFuZGxlSHR0cEVycm9yKHJlcSwgbmV4dCwgZXJyKSkpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBoYW5kbGVIdHRwRXJyb3IoXHJcbiAgICByZXE6IEh0dHBSZXF1ZXN0PGFueT4sXHJcbiAgICBuZXh0OiBIdHRwSGFuZGxlcixcclxuICAgIGVycjogSHR0cEVycm9yUmVzcG9uc2VcclxuICApOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgaWYgKGVyci5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAvLyBVbmF1dGhvcml6ZWQsIHRva2VucyBleHBpcmVkXHJcbiAgICAgIHJldHVybiBmcm9tKHRoaXMuYXV0aC5yZWZyZXNoVG9rZW5zKCkpLnBpcGUoXHJcbiAgICAgICAgc3dpdGNoTWFwKF8gPT4gbmV4dC5oYW5kbGUodGhpcy5zZXRBdXRoSGVhZGVyKHJlcSkpKSxcclxuICAgICAgICBjYXRjaEVycm9yKF8gPT4gdGhyb3dFcnJvcihlcnIpKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRocm93RXJyb3IoZXJyKTtcclxuICB9XHJcblxyXG4gIC8qKiBDaGVjayBpZiByZXF1ZXN0IFVSTCBpcyBpbiBwcm92aWRlZCBiYXNlUGF0aHNcclxuICAgKiBAcGFyYW0gcmVxdWVzdCBIdHRwIHJlcXVlc3QgaW5zdGFuY2Ugd2hvc2UgVVJMIGlzIGNoZWNrZWQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBpc1VybEluQmFzZVBhdGhzKHJlcXVlc3Q6IEh0dHBSZXF1ZXN0PGFueT4pOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHVybCA9IHJlcXVlc3QudXJsLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBjb25zdCBwYXRoID0gdGhpcy5iYXNlUGF0aHMuZmluZChwYXRoID0+IHVybC5zdGFydHNXaXRoKHBhdGgpKTtcclxuICAgIHJldHVybiBCb29sZWFuKHBhdGgpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFNldHMgYWNjZXNzIHRva2VuIHRvIGF1dGhvcml6YXRpb24gaGVhZGVyIG9mIEhUVFAgcmVxdWVzdFxyXG4gICAqIEBwYXJhbSByZXF1ZXN0IEhUVFAgcmVxdWVzdCBpbnN0YW5jZVxyXG4gICAqIEByZXR1cm5zIENsb25lZCBIVFRQIHdpdGggYWRhcHRlZCBoZWFkZXJzXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzZXRBdXRoSGVhZGVyKHJlcTogSHR0cFJlcXVlc3Q8YW55Pik6IEh0dHBSZXF1ZXN0PGFueT4ge1xyXG4gICAgY29uc3QgYWNjZXNzX3Rva2VuID0gdGhpcy5hdXRoLmN1cnJlbnRVc2VyLmFjY2Vzc190b2tlbjtcclxuICAgIGNvbnN0IGhlYWRlciA9IGBCZWFyZXIgJHthY2Nlc3NfdG9rZW59YDtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSByZXEuaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBoZWFkZXIpO1xyXG5cclxuICAgIHJldHVybiByZXEuY2xvbmUoeyBoZWFkZXJzIH0pO1xyXG4gIH1cclxufVxyXG4iXX0=