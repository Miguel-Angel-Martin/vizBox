import { __decorate, __param } from 'tslib';
import { ɵɵdefineInjectable, ɵɵinject, Injectable, Inject, Optional, SkipSelf, NgModule } from '@angular/core';
import { Router } from '@angular/router';
import { Subject, BehaviorSubject, interval } from 'rxjs';
import { v4 } from 'uuid';
import { AvlAuthService } from '@avl-ng-controls/auth';
import { TranslateService } from '@ngx-translate/core';
import { NgxTranslateTranslationService } from '@avl-controls/ng-binders';
import '@avl-controls/core/dist/avl-localization-service/avl-localization-service';
import { HttpHeaders, HttpClient } from '@angular/common/http';
import { takeUntil, switchMap, tap, filter } from 'rxjs/operators';
import { HubConnectionState, HubConnectionBuilder, LogLevel } from '@microsoft/signalr';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/router';
import * as ɵngcc2 from '@avl-ng-controls/auth';
import * as ɵngcc3 from '@ngx-translate/core';
import * as ɵngcc4 from '@avl-controls/ng-binders';
import * as ɵngcc5 from '@angular/common/http';
var MessageType;
(function (MessageType) {
    MessageType["action"] = "action";
    MessageType["colorScheme"] = "colorScheme";
    MessageType["language"] = "language";
    MessageType["locale"] = "locale";
    MessageType["navigation"] = "navigation";
    MessageType["registration"] = "registration";
    MessageType["theme"] = "theme";
    MessageType["login"] = "login";
    MessageType["authentication"] = "authentication";
    MessageType["redirectedFromLogIn"] = "redirectedFromLogIn";
    MessageType["user"] = "user";
})(MessageType || (MessageType = {}));

let ShellCommunicationService = class ShellCommunicationService {
    constructor(router, authService) {
        this.router = router;
        this.authService = authService;
        this.handlers = {
            [MessageType.theme]: (theme) => this.handleTheme(theme),
            [MessageType.locale]: (locale) => this.handleLocale(locale),
            [MessageType.language]: (language) => this.handleLanguage(language),
            [MessageType.colorScheme]: (colorScheme) => this.handleColorScheme(colorScheme),
            [MessageType.navigation]: (url) => this.handleNavigation(url),
            [MessageType.action]: (action) => this.handleAction(action),
            [MessageType.authentication]: (user) => this.handleAuthentication(user),
            [MessageType.redirectedFromLogIn]: (redirected) => this.handleRedirectedFromLogIn(redirected),
        };
        this.themeSubject = new Subject();
        this.languageSubject = new Subject();
        this.actionSubject = new Subject();
        this.localeSubject = new Subject();
        this.colorSchemeSubject = new Subject();
        /**
        * Observable tracking theme
        * Emits "dark" if dark theme selected, "light" otherwise
        */
        this.theme$ = this.themeSubject;
        /**
        * Observable tracking language
        */
        this.language$ = this.languageSubject;
        this.action$ = this.actionSubject;
        /**
        * Observable tracking country changes
        */
        this.locale$ = this.localeSubject;
        /**
        * Observable tracking color scheme changes
        */
        this.colorScheme$ = this.colorSchemeSubject;
        /**
         * Observable tracking if redirected from idb
         * Resolves to true on redirection, false otherwise
         */
        this.redirectedFromLogIn = new BehaviorSubject(undefined);
        /**
         * If current application is inside shell application
         * True if current application is inside shell application, false otherwise.
         */
        this.isChild = window.location !== window.parent.location;
        window.addEventListener('message', (event) => this.onMessage(event));
        this.id = v4();
    }
    notifyShellAboutAction(action) {
        this.postMessageToShell(MessageType.action, action);
    }
    /**
     * Sends message to shell that it needs to navigate to login page
     */
    notifyShellAboutLogin(url) {
        this.postMessageToShell(MessageType.login, url);
    }
    /**
     * Sends message to shell that it needs to navigate to @url
     */
    notifyShellAboutNavigation(url) {
        this.postMessageToShell(MessageType.navigation, url);
    }
    /**
     * Sends registration message to shell
     */
    registerToShell() {
        this.postMessageToShell(MessageType.registration, this.id);
    }
    /**
    * Send updated user data to shell
    */
    updateUserToShell() {
        const user = this.authService.readUserFromSessionStorage();
        this.postMessageToShell(MessageType.user, user);
    }
    onMessage(event) {
        const { payload, messageType } = event.data;
        const handlers = Object.assign(Object.assign({}, this.handlers), { default: () => console.log('Unrecognized message for the shell.', event) });
        (handlers[messageType] || handlers.default)(payload);
    }
    postMessageToShell(messageType, payload) {
        const message = { messageType, payload };
        window.parent.window.postMessage(message, '*');
    }
    handleColorScheme(colorScheme) {
        this.colorSchemeSubject.next(colorScheme);
    }
    handleLanguage(language) {
        this.languageSubject.next(language);
    }
    handleLocale(locale) {
        this.localeSubject.next(locale);
    }
    handleTheme(theme) {
        this.themeSubject.next(theme);
    }
    handleNavigation(url) {
        this.router.navigateByUrl(url);
    }
    handleAction(action) {
        this.actionSubject.next(action);
    }
    handleAuthentication(user) {
        if (user === null || user === void 0 ? void 0 : user.access_token) {
            this.authService.storeUserToSessionStorage(user);
        }
        else {
            this.authService.clearUserFromSessionStorage();
        }
        this.authService.reloadPersistedUserData();
    }
    handleRedirectedFromLogIn(redirected) {
        this.redirectedFromLogIn.next(redirected);
    }
};
ShellCommunicationService.ɵfac = function ShellCommunicationService_Factory(t) { return new (t || ShellCommunicationService)(ɵngcc0.ɵɵinject(ɵngcc1.Router), ɵngcc0.ɵɵinject(ɵngcc2.AvlAuthService)); };
ShellCommunicationService.ctorParameters = () => [
    { type: Router },
    { type: AvlAuthService }
];
ShellCommunicationService.ɵprov = ɵɵdefineInjectable({ factory: function ShellCommunicationService_Factory() { return new ShellCommunicationService(ɵɵinject(Router), ɵɵinject(AvlAuthService)); }, token: ShellCommunicationService, providedIn: "root" });

let TranslationManagementService = class TranslationManagementService {
    constructor(translateService, translationService) {
        this.translateService = translateService;
        this.translationService = translationService;
        this.languages = [
            { code: 'en', label: 'English' },
            { code: 'hr', label: 'Croatian' },
        ];
    }
    initializeTranslations() {
        return () => {
            AvlLocalizationService.translationService = this.translationService;
            let lang = localStorage.getItem('lang');
            if (lang == null) {
                lang = this.languages[0].code;
                localStorage.setItem('lang', lang);
            }
            return this.translateService.use(lang).toPromise();
        };
    }
    get language() {
        return localStorage.getItem('lang');
    }
    changeLanguage(lang) {
        const oldLang = localStorage.getItem('lang');
        if (!oldLang || oldLang !== lang) {
            localStorage.setItem('lang', lang);
            location.reload();
        }
    }
};
TranslationManagementService.ɵfac = function TranslationManagementService_Factory(t) { return new (t || TranslationManagementService)(ɵngcc0.ɵɵinject(ɵngcc3.TranslateService), ɵngcc0.ɵɵinject(ɵngcc4.NgxTranslateTranslationService)); };
TranslationManagementService.ctorParameters = () => [
    { type: TranslateService },
    { type: NgxTranslateTranslationService }
];
TranslationManagementService.ɵprov = ɵɵdefineInjectable({ factory: function TranslationManagementService_Factory() { return new TranslationManagementService(ɵɵinject(TranslateService), ɵɵinject(NgxTranslateTranslationService)); }, token: TranslationManagementService, providedIn: "root" });

let ThemeService = class ThemeService {
    constructor() {
        this.themeChangedSubject = new Subject();
        this.themeChanged = this.themeChangedSubject.asObservable();
        this.changeTheme();
    }
    get isDarkTheme() {
        if (this._isDarkTheme == null) {
            this._isDarkTheme = localStorage.getItem('theme') === 'dark' || false;
        }
        return this._isDarkTheme;
    }
    set isDarkTheme(newValue) {
        this._isDarkTheme = newValue;
        localStorage.setItem('theme', newValue === true ? 'dark' : 'light');
        this.themeChangedSubject.next(this.getCurrentTheme());
        this.changeTheme();
    }
    getCurrentTheme() {
        return this.isDarkTheme ? 'dark' : 'light';
    }
    changeTheme() {
        document.body.setAttribute('theme', this.getCurrentTheme());
    }
};
ThemeService.ɵfac = function ThemeService_Factory(t) { return new (t || ThemeService)(); };
ThemeService.ɵprov = ɵɵdefineInjectable({ factory: function ThemeService_Factory() { return new ThemeService(); }, token: ThemeService, providedIn: "root" });

let ChildCommunicationService = class ChildCommunicationService {
    constructor(translationManagementService, themeService, authService) {
        this.translationManagementService = translationManagementService;
        this.themeService = themeService;
        this.authService = authService;
        this.handlers = {
            [MessageType.login]: (url) => this.handleLogin(url),
            [MessageType.navigation]: (url) => this.handleNavigation(url),
            [MessageType.action]: (action) => this.handleAction(action),
            [MessageType.registration]: (_) => this.handleRegistration(),
            [MessageType.user]: (user) => this.handleUser(user),
        };
        this.actionSubject = new Subject();
        this.navigationSubject = new Subject();
        this.loginSubject = new Subject();
        this.registrationCompletedSubject = new Subject();
        this.action$ = this.actionSubject;
        /**
         * Observable tracking url to navigate to
         */
        this.navigation$ = this.navigationSubject;
        /**
         * Observable tracking url for login
         * Url for login provided by child application
         */
        this.login$ = this.loginSubject;
        /**
         * Observable tracking child registration
         * Emits true if registration was successful, false otherwise
         */
        this.registrationCompleted$ = this
            .registrationCompletedSubject;
        window.addEventListener("message", (event) => this.onMessage(event));
        this.themeService.themeChanged.subscribe(() => this.postThemeToChildren());
    }
    /**
     * Sends message to child about locale
     */
    notifyChildAboutLocale(country) {
        this.postMessageToChild(MessageType.locale, country);
    }
    /**
     * Sends message to child about language
     */
    notifyChildAboutLanguage(language) {
        this.postMessageToChild(MessageType.language, language);
    }
    /**
     * Sends message to child about action
     */
    notifyChildAboutAction(action) {
        this.postMessageToChild(MessageType.action, action);
    }
    /**
     * Sends message to child about navigation
     */
    notifyChildAboutNavigation(url) {
        this.postMessageToChild(MessageType.navigation, url);
    }
    /**
     * Sends messages to children about current user
     */
    postAuthenticationDataToChildren() {
        const payload = this.authService.readUserFromSessionStorage();
        this.postMessageToChild(MessageType.authentication, payload);
    }
    /**
     * Sends messages to children about selected application theme
     */
    postThemeToChildren() {
        const theme = this.themeService.getCurrentTheme();
        this.postMessageToChild(MessageType.theme, theme);
    }
    /**
     * Sends messages to children about selected language
     */
    postLanguageToChildren() {
        this.postMessageToChild(MessageType.language, this.translationManagementService.language);
    }
    /**
     * Sends messages to children about selected country
     */
    postLocaleToChildren() {
        const country = localStorage.getItem("country");
        this.postMessageToChild(MessageType.locale, country);
    }
    /**
     * Sends message to child about redirection from idb
     */
    postRedirectedFromLogIn(payload) {
        this.postMessageToChild(MessageType.redirectedFromLogIn, payload);
    }
    /**
     * Sends message to children about color scheme
     */
    postColorSchemeToChildren() {
        const computedStyle = window.getComputedStyle(document.body);
        const productColor = computedStyle.getPropertyValue("--avl-product-color");
        const productHoverColor = computedStyle.getPropertyValue("--avl-product-hover-color");
        const productFocusColor = computedStyle.getPropertyValue("--avl-product-focus-color");
        const colorScheme = {
            "--avl-product-color": productColor,
            "--avl-product-hover-color": productHoverColor,
            "--avl-product-focus-color": productFocusColor,
        };
        this.postMessageToChild(MessageType.colorScheme, colorScheme);
    }
    handleAction(action) {
        this.actionSubject.next(action);
    }
    handleNavigation(navigation) {
        this.navigationSubject.next(navigation);
    }
    handleLogin(login) {
        this.loginSubject.next(login);
    }
    // when child started its registration iframe is loaded and shell gets a message that he can send messages to iframe
    handleRegistration() {
        this.iframeEl = document.getElementsByTagName("iframe")[0];
        this.postThemeToChildren();
        this.postColorSchemeToChildren();
        this.postLanguageToChildren();
        this.postLocaleToChildren();
        this.registrationCompletedSubject.next(true);
    }
    onMessage(event) {
        const { payload, messageType } = event.data;
        const handlers = Object.assign(Object.assign({}, this.handlers), { default: () => console.log("Unrecognized message for the child.", event) });
        (handlers[messageType] || handlers.default)(payload);
    }
    postMessageToChild(messageType, payload) {
        var _a;
        if (!this.iframeEl) {
            return;
        }
        const message = { messageType, payload };
        (_a = this.iframeEl.contentWindow) === null || _a === void 0 ? void 0 : _a.postMessage(message, "*");
    }
    // when child updates user data, it has to reflect in user data in shell
    handleUser(user) {
        if (user === null || user === void 0 ? void 0 : user.access_token) {
            this.authService.storeUserToSessionStorage(user);
        }
        else {
            this.authService.clearUserFromSessionStorage();
        }
        this.authService.reloadPersistedUserData();
    }
};
ChildCommunicationService.ɵfac = function ChildCommunicationService_Factory(t) { return new (t || ChildCommunicationService)(ɵngcc0.ɵɵinject(TranslationManagementService), ɵngcc0.ɵɵinject(ThemeService), ɵngcc0.ɵɵinject(ɵngcc2.AvlAuthService)); };
ChildCommunicationService.ctorParameters = () => [
    { type: TranslationManagementService },
    { type: ThemeService },
    { type: AvlAuthService }
];
ChildCommunicationService.ɵprov = ɵɵdefineInjectable({ factory: function ChildCommunicationService_Factory() { return new ChildCommunicationService(ɵɵinject(TranslationManagementService), ɵɵinject(ThemeService), ɵɵinject(AvlAuthService)); }, token: ChildCommunicationService, providedIn: "root" });

/**
 * List of all types of messages that can be logged.
 */
var LogSeverity;
(function (LogSeverity) {
    LogSeverity[LogSeverity["Debug"] = 0] = "Debug";
    LogSeverity[LogSeverity["Info"] = 1] = "Info";
    LogSeverity[LogSeverity["Warning"] = 2] = "Warning";
    LogSeverity[LogSeverity["Error"] = 3] = "Error";
    LogSeverity[LogSeverity["Fatal"] = 4] = "Fatal";
})(LogSeverity || (LogSeverity = {}));
/**
 * **LogConfig** class is required by the _LoggingModule_.
 *
 * An instance of this class should be passed into _forRoot_ method of _LoggingModule_
 * when importing module in the Angular application.
 * ```
 * import logConfig from 'logging.config.ts;
 * import LoggingModule from '@avl-services/ng-services';
 *  ....
 *  @NgModule({
 *    imports: [
 *      LoggingModule.forRoot(logConfig),
 *      ...
 *    ],
 *    ...
 *  }) export class AppModule {}
 * ```
 */
class LogConfig {
    /**
     * Creates instance of _LogConfig_ class.
     * @param endpoint API endpoint for logging.
     * @param targetName Name of the database in which logs will be stored
     * @param appName Name of the application that uses the logging service
     * @param version Version of the application that uses the logging service
     * @param autologging Flag that indicates whether logging starts automatically once the user logs in using credential. Default: false
     * @param globalLogLevel Minimum message severity to log. Default: LogSeverity.Info
     * @param debounceTime Time in milliseconds, determines the period of API requests for logging. Default: 30_000 ms
     * @param capacity Log queue capacity. Default: 10
     */
    constructor(endpoint, targetName, appName, version, autologging = false, globalLogLevel = LogSeverity.Info, debounceTime = 30000, capacity = 10) {
        /**
         * Flag that indicates whether logging starts automatically once the user logs in using credential.
         *
         * If true, app requires _AvlAuthService_ instance in _AppModule_ providers array:
         * ```
         * { provide: AvlAuthService, useClass: AvlOidcCodeAuthService }
         * ```
         * If false, user can control logging using the service (_startLogging_, _stopLogging_ methods).
         *
         * - Optional
         * - Default: false
         */
        this.autologging = false;
        /**
         * Minimum message severity to log.
         * - Optional
         * - Default: LogSeverity.Info
         */
        this.globalLogLevel = LogSeverity.Info;
        /**
         * Time in milliseconds, determines the period of API requests for logging.
         * - Optional
         * - Default: 30_000 ms
         */
        this.debounceTime = 30000;
        /**
         * Log queue capacity
         *
         * If reached, API request is sent with all logs in log queue, and queue is cleared out.
         * - Optional
         * - Default: 10
         */
        this.capacity = 10;
        this.endpoint = endpoint;
        this.targetName = targetName;
        this.appName = appName;
        this.version = version;
        this.autologging = autologging;
        this.globalLogLevel = globalLogLevel;
        this.debounceTime = debounceTime;
        this.capacity = capacity;
    }
}

let LoggingService = class LoggingService {
    /**
     * @ignore
     */
    constructor(http, config, authService) {
        var _a;
        this.http = http;
        this.config = config;
        this.authService = authService;
        this.logs = [];
        this.isLogging = false;
        this.debounceTime$ = new Subject();
        this.logs$ = new Subject();
        this.stopLogging$ = new Subject();
        this.postLogs$ = new Subject();
        this.destroyed$ = new Subject();
        this.headers = new HttpHeaders({
            targetName: this.config.targetName,
        });
        if (config.autologging) {
            (_a = this.authService) === null || _a === void 0 ? void 0 : _a.isLoggedIn$.pipe(takeUntil(this.destroyed$)).subscribe((isLoggedIn) => this.decideOnLogging(isLoggedIn));
        }
    }
    /**
     * @ignore
     */
    ngOnDestroy() {
        this.postLogs$.complete();
        this.debounceTime$.complete();
        this.logs$.complete();
        this.stopLogging$.next();
        this.stopLogging$.complete();
        this.destroyed$.next();
        this.destroyed$.complete();
    }
    /**
     * Starts periodical logging process.
     *
     * Depends on _debounceTime_ and _capacity_ properties.
     */
    startLogging() {
        this.isLogging = true;
        this.debounceTime$
            .pipe(takeUntil(this.stopLogging$), switchMap((debounceTime) => this.periodicalLogging(debounceTime)))
            .subscribe(() => this.onPostMessages());
        this.postLogs$
            .pipe(takeUntil(this.stopLogging$), switchMap(() => this.postMessages()))
            .subscribe(() => this.onPostMessages());
        this.setLoggingDebounceTime(this.config.debounceTime);
    }
    /**
     * Stops logging process.
     */
    stopLogging() {
        this.isLogging = false;
        this.postLogs();
        this.stopLogging$.next();
    }
    /**
     * Gets all currently queued logs as an observable value.
     * @returns All currently queued logs as an observable value
     */
    getLogs$() {
        return this.logs$.asObservable();
    }
    /**
     * Logs message with debug severity.
     * @param message Message used for constructing a debug log
     * @param componentName Name of the component which called this method
     */
    debug(message, componentName = '') {
        this.log(message, LogSeverity.Debug, componentName);
    }
    /**
     * Logs message with info severity.
     * @param message Message used for constructing a info log
     * @param componentName Name of the component which called this method
     */
    info(message, componentName = '') {
        this.log(message, LogSeverity.Info, componentName);
    }
    /**
     * Logs message with warning severity.
     * @param message Message used for constructing a warning log
     * @param componentName Name of the component which called this method
     */
    warn(message, componentName = '') {
        this.log(message, LogSeverity.Warning, componentName);
    }
    /**
     * Logs message with error severity.
     * @param message Message used for constructing a error log
     * @param componentName Name of the component which called this method
     */
    error(message, componentName = '') {
        this.log(message, LogSeverity.Error, componentName);
    }
    /**
     * Logs message with fatal severity.
     * @param message Message used for constructing a fatal log
     * @param componentName Name of the component which called this method
     */
    fatal(message, componentName = '') {
        this.log(message, LogSeverity.Fatal, componentName);
    }
    /**
     * Setter for debounce time (log period).
     * @param debounceTime Time in milliseconds; determines the period of API requests for logging
     */
    setLoggingDebounceTime(debounceTime) {
        this.config.debounceTime = debounceTime;
        this.debounceTime$.next(debounceTime);
    }
    /**
     * Setter for global log level.
     * @param globalLogLevel Minimum message severity to log
     */
    setGlobalLogLevel(globalLogLevel) {
        this.config.globalLogLevel = globalLogLevel;
    }
    /**
     * Setter for log queue capacity.
     * @param capacity Log queue capacity
     */
    setLogCapacity(capacity) {
        this.config.capacity = capacity;
    }
    // Logic, private methods
    log(message, severity, componentName) {
        if (!this.isLogging || severity < this.config.globalLogLevel) {
            return;
        }
        this.createAndStoreLog(message, severity, componentName);
        this.dispatchLogs();
        if (this.isFullCapacity()) {
            this.postLogs$.next();
        }
    }
    createAndStoreLog(message, severityType, componentName) {
        const timestamp = new Date().toISOString();
        const { appName, version } = this.config;
        const severity = severityType.toString();
        const log = { message, severity, timestamp, componentName, appName, version };
        this.logs.push(log);
    }
    isFullCapacity() {
        return this.logs.length >= this.config.capacity;
    }
    clearLogs() {
        this.logs = [];
    }
    onPostMessages() {
        this.clearLogs();
        this.dispatchLogs();
    }
    postLogs() {
        this.postLogs$.next();
    }
    periodicalLogging(period) {
        return interval(period).pipe(tap(() => {
            if (!this.logs.length) {
                this.dispatchLogs();
            }
        }), filter(() => !!this.logs.length), switchMap(() => this.postMessages()));
    }
    postMessages() {
        return this.http.post(this.config.endpoint, this.logs, {
            headers: this.headers,
        });
    }
    dispatchLogs() {
        this.logs$.next(this.logs);
    }
    decideOnLogging(isLoggedIn) {
        if (isLoggedIn) {
            this.startLogging();
        }
        else {
            this.stopLogging();
        }
    }
};
LoggingService.ɵfac = function LoggingService_Factory(t) { return new (t || LoggingService)(ɵngcc0.ɵɵinject(ɵngcc5.HttpClient), ɵngcc0.ɵɵinject('loggingConfig'), ɵngcc0.ɵɵinject(AvlAuthService, 8)); };
LoggingService.ctorParameters = () => [
    { type: HttpClient },
    { type: LogConfig, decorators: [{ type: Inject, args: ['loggingConfig',] }] },
    { type: AvlAuthService, decorators: [{ type: Optional }, { type: Inject, args: [AvlAuthService,] }] }
];
LoggingService.ɵprov = ɵɵdefineInjectable({ factory: function LoggingService_Factory() { return new LoggingService(ɵɵinject(HttpClient), ɵɵinject("loggingConfig"), ɵɵinject(AvlAuthService, 8)); }, token: LoggingService, providedIn: "root" });
LoggingService = __decorate([ __param(1, Inject('loggingConfig')),
    __param(2, Optional()), __param(2, Inject(AvlAuthService))
], LoggingService);

var LoggingModule_1;
let LoggingModule = LoggingModule_1 = class LoggingModule {
    constructor(parentModule) {
        if (parentModule) {
            throw new Error('LoggingModule is already loaded. Import it in the AppModule only');
        }
    }
    static forRoot(config) {
        return {
            ngModule: LoggingModule_1,
            providers: [LoggingService, { provide: 'loggingConfig', useValue: config }],
        };
    }
};
LoggingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LoggingModule });
LoggingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LoggingModule_Factory(t) { return new (t || LoggingModule)(ɵngcc0.ɵɵinject(LoggingModule, 12)); } });
LoggingModule.ctorParameters = () => [
    { type: LoggingModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
];
LoggingModule = LoggingModule_1 = __decorate([ __param(0, Optional()), __param(0, SkipSelf())
], LoggingModule);

let NotificationService = class NotificationService {
    constructor() {
        this.hubConnections = [];
        this.notification = new Subject();
        /**
         * Observable which emits newly arrived notifications.
         */
        this.notification$ = this.notification;
    }
    /**
     * Builds and starts signalR hub connection with the server.
     * If connection already exists and is not connected, restarts the connection.
     * @param endpoint server endpoint
     * @param options options of the connection
     */
    startConnection(endpoint, options) {
        let connection = this.getConnectionByID(options.connectionID);
        if (!connection) {
            connection = this.buildConnection(endpoint, options);
        }
        if (connection.state === HubConnectionState.Connected) {
            return;
        }
        connection
            .start()
            .then(() => this.startNotifications(connection, options.metadata))
            .catch(() => console.warn('Notification service: Failed to establish connection.'));
    }
    /**
     * Stops connection with the server
     * @param connectionID connection identifier
     */
    stopConnection(connectionID) {
        const connection = this.getConnectionByID(connectionID);
        if (!connection) {
            return;
        }
        connection.off('transferNotification');
        connection.stop();
    }
    /**
     * Removes connection entirely
     * @param connectionID connection identifier
     */
    removeConnection(connectionID) {
        this.stopConnection(connectionID);
        const index = this.hubConnections.findIndex(connection => connection.id === connectionID);
        if (index !== -1) {
            this.hubConnections.splice(index, 1);
        }
    }
    /**
     * Updates notifications metadata for specific connection. Notifies server about it.
     * @param connectionID connection identifier
     * @param metadata notification metadata, (e.g language)
     */
    updateNotifications(connectionID, metadata) {
        const connection = this.getConnectionByID(connectionID);
        if (!connection) {
            return;
        }
        this.startNotifications(connection, metadata);
    }
    // Private methods
    startNotifications(connection, metadata) {
        connection.invoke('startNotifications', metadata);
    }
    getConnectionByID(connectionID) {
        var _a;
        const index = this.hubConnections.findIndex(connection => connection.id === connectionID);
        return (_a = this.hubConnections[index]) === null || _a === void 0 ? void 0 : _a.connection;
    }
    buildConnection(endpoint, options) {
        const hubConnection = new HubConnectionBuilder()
            .configureLogging(LogLevel.None)
            .withUrl(endpoint)
            .withAutomaticReconnect()
            .build();
        hubConnection.onreconnected(() => this.startNotifications(hubConnection, options.metadata));
        hubConnection.on('transferNotification', (notification) => {
            this.notification.next(notification);
        });
        this.hubConnections.push({
            id: options.connectionID,
            connection: hubConnection
        });
        return hubConnection;
    }
};
NotificationService.ɵfac = function NotificationService_Factory(t) { return new (t || NotificationService)(); };
NotificationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NotificationService, factory: NotificationService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ShellCommunicationService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.Router }, { type: ɵngcc2.AvlAuthService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TranslationManagementService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc3.TranslateService }, { type: ɵngcc4.NgxTranslateTranslationService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThemeService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChildCommunicationService, [{
        type: Injectable,
        args: [{
                providedIn: "root"
            }]
    }], function () { return [{ type: TranslationManagementService }, { type: ThemeService }, { type: ɵngcc2.AvlAuthService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LoggingService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc5.HttpClient }, { type: LogConfig, decorators: [{
                type: Inject,
                args: ['loggingConfig']
            }] }, { type: ɵngcc2.AvlAuthService, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [AvlAuthService]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LoggingModule, [{
        type: NgModule
    }], function () { return [{ type: LoggingModule, decorators: [{
                type: Optional
            }, {
                type: SkipSelf
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NotificationService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/*
 * Public API Surface of ng-services
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ChildCommunicationService, LogConfig, LogSeverity, LoggingModule, LoggingService, MessageType, NotificationService, ShellCommunicationService, ThemeService, TranslationManagementService };

//# sourceMappingURL=avl-services-ng-services.js.map