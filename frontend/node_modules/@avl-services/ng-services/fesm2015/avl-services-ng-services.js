import { BehaviorSubject, from, throwError, Subject, interval, of } from 'rxjs';
import { __awaiter } from 'tslib';
import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Inject, Optional, NgModule, SkipSelf, Directive, Input } from '@angular/core';
import * as i1 from '@angular/common/http';
import { HttpClient, HttpHeaders, HttpEventType } from '@angular/common/http';
import { skipWhile, map, catchError, switchMap, takeUntil, tap, filter, debounceTime, skip } from 'rxjs/operators';
import * as i2 from '@angular/router';
import * as i3 from '@angular/common';
import { v4 } from 'uuid';
import '@avl-services/vanilla-js-services/avl-localization-service/avl-localization-service.api';
import * as i1$1 from '@ngx-translate/core';
import { HubConnectionState, HubConnectionBuilder, LogLevel } from '@microsoft/signalr';

class AvlAuthService {
    constructor() {
        /**
         * User data is held in this property
         */
        this.userSubject = new BehaviorSubject(undefined);
        /**
         * Current user as Observable
         */
        this.user$ = this.userSubject.asObservable();
        /**
         * String holding error message in case user couldn't authenticate
         */
        this.errorMessageSubject = new BehaviorSubject(undefined);
        /**
         * Error messsage in case failed authentication as Observable
         */
        this.errorMessage$ = this.errorMessageSubject.asObservable();
    }
    /**
     * Currently authenticated user data
     */
    get currentUser() {
        return this.userSubject.value;
    }
    /**
     * Current error message for fail authentication
     * Undefined when user is logged in
     */
    get errorMessage() {
        return this.errorMessageSubject.value;
    }
    /**
     * Use to clear error message after user is informed
     */
    clearErrorMessage() {
        this.errorMessageSubject.next(undefined);
    }
}

const AUTH_CONFIG = new InjectionToken(undefined);
const INTERCEPTOR_BASE_PATHS = new InjectionToken(undefined);

var StorageNames;
(function (StorageNames) {
    StorageNames["AccessToken"] = "access_token";
    StorageNames["AccessTokenExpiresAt"] = "access_token_expires_at";
    StorageNames["AccessTokenStoredAt"] = "access_token_stored_at";
    StorageNames["RefreshToken"] = "refresh_token";
    StorageNames["RefreshTokenExpiresAt"] = "refresh_token_expires_at";
    StorageNames["IdToken"] = "id_token";
    StorageNames["Roles"] = "roles";
    StorageNames["UserName"] = "username";
    StorageNames["Name"] = "name";
})(StorageNames || (StorageNames = {}));

class TokenStorage {
    constructor(prefix = '') {
        this.prefix = '';
        this.parseJson = (string) => {
            if ((string === null || string === void 0 ? void 0 : string.indexOf('undefined')) > -1) {
                string = string.replace('undefined', null);
            }
            try {
                return JSON.parse(string);
            }
            catch (e) {
                console.error(e);
                return null;
            }
        };
        this.prefix = prefix;
    }
    readUser() {
        const accessToken = this.getItem(StorageNames.AccessToken);
        return accessToken && accessToken != null ? {
            username: this.getItem(StorageNames.UserName),
            name: this.getItem(StorageNames.Name),
            access_token: accessToken,
            access_token_expires: this.getNumber(StorageNames.AccessTokenExpiresAt),
            access_token_stored: this.getNumber(StorageNames.AccessTokenStoredAt),
            refresh_token: this.getItem(StorageNames.RefreshToken),
            refresh_token_expires: this.getNumber(StorageNames.RefreshTokenExpiresAt),
            id_token: this.getItem(StorageNames.IdToken),
            roles: this.parseJson(this.getItem(StorageNames.Roles))
        } : null;
    }
    storeUser(user) {
        this.setItem(StorageNames.UserName, user.username);
        this.setItem(StorageNames.Name, user.name);
        this.setItem(StorageNames.AccessToken, user.access_token);
        this.setItem(StorageNames.AccessTokenExpiresAt, `${user.access_token_expires}`);
        this.setItem(StorageNames.AccessTokenStoredAt, `${user.access_token_stored}`);
        this.setItem(StorageNames.RefreshToken, user.refresh_token);
        this.setItem(StorageNames.RefreshTokenExpiresAt, `${user.refresh_token_expires}`);
        this.setItem(StorageNames.IdToken, user.id_token);
        if (user.roles) {
            const rolesStr = JSON.stringify(user.roles);
            sessionStorage.setItem(StorageNames.Roles, `${rolesStr}`);
        }
    }
    clearUser() {
        for (const name in StorageNames) {
            if (StorageNames.hasOwnProperty(name)) {
                this.removeItem(StorageNames[name]);
            }
        }
    }
    getNumber(key) {
        return parseInt(this.getItem(key), 10);
    }
    getItem(key) {
        return sessionStorage.getItem(this.prefix + key);
    }
    setItem(key, value) {
        sessionStorage.setItem(this.prefix + key, value);
    }
    removeItem(key) {
        sessionStorage.removeItem(this.prefix + key);
    }
}

class CryptoHelper {
    // PKCE HELPER FUNCTIONS
    // Generate a secure random string using the browser crypto functions
    generateRandomString(length) {
        const array = new Uint8Array(length);
        window.crypto.getRandomValues(array);
        return Array.from(array, dec => ('0' + dec.toString(16)).substr(-2)).join('');
    }
    // Base64-encodes the input string
    base64Encode(buffer) {
        // Convert the ArrayBuffer to string using Uint8 array to convert to what btoa accepts.
        // btoa accepts chars only within ascii 0-255 and base64 encodes them.
        return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)));
    }
    // Calculate the SHA256 hash of the input text. 
    // Returns a promise that resolves to base64 encoded string
    sha256(plain) {
        return __awaiter(this, void 0, void 0, function* () {
            const encoder = new TextEncoder();
            const data = encoder.encode(plain);
            const buffer = yield window.crypto.subtle.digest('SHA-256', data);
            return this.base64Encode(buffer);
        });
    }
    // Base64-decodes the input string
    base64DecodeUnicode(str) {
        const base64 = str.replace(/\-/g, '+').replace(/\_/g, '/');
        return decodeURIComponent(atob(base64)
            .split('')
            .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
            .join(''));
    }
}

const LOGOUT_CONFIG_NOT_SET_ERROR = 'User signed out locally, but logout request towards OIDC server not initiated since logoutUrl is not set in authConfig.';
class AvlOidcCodeAuthService extends AvlAuthService {
    constructor(httpBackend, authConfig, router, loc) {
        super();
        this.httpBackend = httpBackend;
        this.authConfig = authConfig;
        this.router = router;
        this.loc = loc;
        this.isLoggedInSubject = new BehaviorSubject(undefined);
        /**
         * Observable tracking authenticated state
         * Resolves to true on successful log in, false otherwise
         */
        this.isLoggedIn$ = this.isLoggedInSubject
            .asObservable()
            .pipe(skipWhile(isLoggedIn => isLoggedIn === undefined));
        /**
         * Observable tracking if redirected from idb
         * Resolves to true on redirection, false otherwise
         */
        this.redirectedFromLogIn = new BehaviorSubject(undefined);
        this.emitLoggedIn = (value) => {
            this.isLoggedInSubject.next(value);
        };
        this.http = new HttpClient(this.httpBackend);
        this.storage = new TokenStorage(this.authConfig.tokenPrefix);
        this.cryptoHelper = new CryptoHelper();
        this.userSubject.pipe(skipWhile(value => value === undefined)).subscribe(userValue => {
            this.emitLoggedIn(Boolean(userValue));
        });
        const user = this.storage.readUser();
        if (user && !this.isUserInvalid(user)) {
            this.persistUser(user);
        }
        else if (!this.currentUser && this.pkce) {
            // if user is not logged in and pkce exists handle redirect from oidc server if possible
            this.handleOidcRedirect();
        }
        else {
            this.clearUser();
            this.userSubject.next(null);
        }
        this.redirectedFromLogIn.next(Boolean(this.currentUser));
    }
    /** @hidden */
    isUserInvalid(data) {
        return (!data ||
            data.username == null ||
            data.access_token == null ||
            data.access_token_expires < Date.now());
    }
    get pkce() {
        return this.storage.getItem('pkce') || undefined;
    }
    set pkce(c) {
        if (c) {
            this.storage.setItem('pkce', c);
        }
        else {
            this.storage.removeItem('pkce');
        }
    }
    get nonce() {
        return sessionStorage.getItem('nonce') || undefined;
    }
    set nonce(c) {
        if (c) {
            this.storage.setItem('nonce', c);
        }
        else {
            this.storage.removeItem('nonce');
        }
    }
    isAccessTokenValid() {
        return Date.now() < this.currentUser.access_token_expires;
    }
    persistUser(user) {
        if (user) {
            this.storage.storeUser(user);
            this.userSubject.next(user);
        }
        else {
            this.clearUser();
        }
    }
    clearUser() {
        this.storage.clearUser();
        this.userSubject.next(undefined);
    }
    /*
     * Checks if current url is redirect from oidc server and gets access token from the server.
     */
    handleOidcRedirect() {
        return __awaiter(this, void 0, void 0, function* () {
            const pkce = this.pkce;
            this.pkce = undefined;
            const urlParts = this.loc.path(true).split('?', 2);
            let urlHash;
            let first;
            let last;
            let urlPartSplit;
            if (urlParts.length === 2) {
                first = urlParts[1].lastIndexOf('#');
                if (first !== -1) {
                    last = urlParts[1].lastIndexOf('&');
                    urlHash = urlParts[1].slice(first, last);
                    urlPartSplit = urlParts[1].split('#', 2);
                    urlParts[1] = urlParts[1].split('&').pop();
                    urlParts[1] = urlPartSplit[0].concat('&').concat(urlParts[1]);
                }
            }
            let query = urlParts.length === 2 ? this.parseQueryString(urlParts[1]) : [];
            let queryCode;
            for (let i = query.length - 1; i >= 0; i--) {
                if (query[i].key === 'code') {
                    queryCode = query[i].value;
                    query = [...query.slice(0, i), ...query.slice(i + 1)];
                    break;
                }
            }
            if (urlParts.length === 2 && queryCode) {
                const nonce = this.nonce;
                this.nonce = undefined;
                const httpOptions = {
                    headers: new HttpHeaders({
                        code: queryCode,
                        verifier: pkce,
                        nonce: nonce
                    })
                };
                try {
                    const user = yield this.http
                        .post(this.authConfig.tokenUrl, {}, httpOptions)
                        .pipe(map(token => this.readUserFromToken(token)))
                        .toPromise();
                    this.persistUser(user);
                }
                catch (error) {
                    this.errorMessageSubject.next(error.message);
                }
            }
            if (urlHash) {
                this.router.navigateByUrl(`${urlParts[0]}${this.reconstructQueryParamString(query)}${urlHash}`, { replaceUrl: true });
                this.redirectedFromLogIn.next(true);
            }
            else {
                this.router.navigateByUrl(`${urlParts[0]}${this.reconstructQueryParamString(query)}`, {
                    replaceUrl: true
                });
                this.redirectedFromLogIn.next(Boolean(this.currentUser));
            }
        });
    }
    reloadPersistedUserData() {
        var _a;
        const user = this.storage.readUser();
        if (((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.access_token) === (user === null || user === void 0 ? void 0 : user.access_token)) {
            return;
        }
        if (this.isUserInvalid(user)) {
            this.clearUser();
        }
        else {
            this.persistUser(user);
        }
    }
    reconstructQueryParamString(queryParams) {
        let s = '?';
        if (queryParams.length === 0) {
            return '';
        }
        for (const q of queryParams) {
            if (s === '?') {
                s += `${encodeURIComponent(q.key)}=${encodeURIComponent(q.value)}`;
            }
            else {
                s += `&${encodeURIComponent(q.key)}=${encodeURIComponent(q.value)}`;
            }
        }
        return s;
    }
    readUserFromToken(token) {
        var _a;
        const accessTokenClaims = this.readClaimsFromToken(token.accesstoken);
        // Calculate actual expiry date for this machine
        const accessTokenStoredAt = Date.now(); // [ms]
        const accessTokenExpiresAt = accessTokenStoredAt + token.expiresIn * 1000;
        const refreshTokenClaims = this.readClaimsFromToken(token.refreshtoken);
        let refreshTokenExpiresAt = null;
        if (refreshTokenClaims) {
            // If time value is 0 token lasts indefinitely
            const refreshTokenExpiresIn = refreshTokenClaims['exp'] !== 0 ? refreshTokenClaims['exp'] - refreshTokenClaims['iat'] : 0;
            const refreshTokenStoredAt = accessTokenStoredAt;
            refreshTokenExpiresAt =
                refreshTokenExpiresIn !== 0 ? refreshTokenStoredAt + refreshTokenExpiresIn * 1000 : 0;
        }
        const roles = accessTokenClaims === null || accessTokenClaims === void 0 ? void 0 : accessTokenClaims.roles;
        if (!accessTokenClaims) {
            return null;
        }
        return {
            username: accessTokenClaims.preferred_username,
            name: (_a = accessTokenClaims.name) !== null && _a !== void 0 ? _a : accessTokenClaims.preferred_username,
            access_token: token.accesstoken,
            access_token_expires: accessTokenExpiresAt,
            access_token_stored: accessTokenStoredAt,
            refresh_token: token.refreshtoken,
            refresh_token_expires: refreshTokenExpiresAt,
            id_token: token.idToken,
            roles: roles
        };
    }
    refreshUserIfNeeded() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const accessTokenExpired = ((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.access_token_expires) < Date.now();
            if (accessTokenExpired) {
                yield this.refreshTokens();
            }
        });
    }
    /**
     * If needed, this method can be called to refresh tokens for current user
     * @returns Promise resolved with object containing new tokens
     */
    refreshTokens() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const refreshTokenValid = ((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.refresh_token_expires) > Date.now();
            if (!refreshTokenValid) {
                this.logout();
                return;
            }
            const httpOptions = {
                headers: new HttpHeaders({
                    grant_type: 'refresh_token',
                    'refresh-token': this.storage.getItem(StorageNames.RefreshToken)
                })
            };
            if (!this.authConfig.refreshUrl) {
                throw new Error('refreshUrl missing in AuthConfig');
            }
            try {
                const user = yield this.http
                    .post(this.authConfig.refreshUrl, {}, httpOptions)
                    .pipe(map(token => this.readUserFromToken(token)))
                    .toPromise();
                this.persistUser(user);
            }
            catch (error) {
                this.errorMessageSubject.next(error.message);
                throw error;
            }
        });
    }
    /**
     * Login user and redirect after successful authentication.
     * Custom auth services need to provide implementation
     * @param redirectUrl Url to redirect after successful authentication
     */
    login(redirectUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            location.href = yield this.generateLoginUrl(redirectUrl || location.href);
        });
    }
    /**
     * Log out user and redirect after.
     * Custom auth services need to provide implementation
     * @param redirectUrl Url to redirect after logging out
     */
    logout(redirectUrl) {
        const { logoutUrl } = this.authConfig;
        if (!logoutUrl) {
            console.warn(LOGOUT_CONFIG_NOT_SET_ERROR);
        }
        const headers = new HttpHeaders({ 'refresh-token': this.currentUser.refresh_token });
        this.http
            .post(logoutUrl, {}, { headers })
            .pipe(catchError(error => {
            this.onLogout(redirectUrl);
            throw error;
        }))
            .subscribe(() => this.onLogout(redirectUrl));
    }
    onLogout(redirectUrl) {
        this.clearUser();
        this.redirectIfNeeded(redirectUrl);
    }
    redirectIfNeeded(redirectUrl) {
        if (redirectUrl) {
            this.navigateTo(redirectUrl);
        }
        else {
            this.reloadPage();
        }
    }
    reloadPage() {
        window.location.reload();
    }
    navigateTo(redirectUrl) {
        this.router.navigate([redirectUrl]);
    }
    generateLoginUrl(redirectUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const encoder = new TextEncoder();
            const uint8Array = encoder.encode(redirectUrl);
            const redirect_b64 = this.cryptoHelper.base64Encode(uint8Array);
            // Generate a session value.
            const nonce = this.cryptoHelper.generateRandomString(16);
            // Generate pkce
            const pkce = this.cryptoHelper.generateRandomString(32);
            let pkce_hash = yield this.cryptoHelper.sha256(pkce);
            // KeyCloak requires this - https://tools.ietf.org/html/rfc7636#appendix-A
            pkce_hash = pkce_hash.replace(/=/g, '');
            pkce_hash = pkce_hash.replace(/\+/g, '-');
            pkce_hash = pkce_hash.replace(/\//g, '_');
            this.pkce = pkce;
            this.nonce = nonce;
            let url = this.authConfig.loginUrl;
            url += '?' + this.authConfig.loginUrlParamRedirect + '=' + encodeURIComponent(redirect_b64);
            url += '&' + this.authConfig.loginUrlParamChallenge + '=' + encodeURIComponent(pkce_hash);
            url += '&' + this.authConfig.loginUrlParamNonce + '=' + encodeURIComponent(nonce);
            return url;
        });
    }
    readClaimsFromToken(token) {
        if (!token.includes('.')) {
            // Token is not a valid JWT token
            return null;
        }
        const tokenParts = token.split('.');
        const claimsString = this.cryptoHelper.base64DecodeUnicode(tokenParts[1]);
        return this.storage.parseJson(claimsString);
    }
    parseQueryString(queryString) {
        if (!queryString.length) {
            return [];
        }
        const queryDict = [];
        const pairs = queryString.split('&');
        for (const pair of pairs) {
            const index = pair.indexOf('=');
            let key;
            let value;
            if (index === -1) {
                key = pair;
                value = undefined;
            }
            else {
                key = pair.substr(0, index);
                value = pair.substr(index + 1);
            }
            queryDict.push({
                key: decodeURIComponent(key),
                value: decodeURIComponent(value)
            });
        }
        return queryDict;
    }
    readUserFromSessionStorage() {
        return this.storage.readUser();
    }
    storeUserToSessionStorage(user) {
        this.storage.storeUser(user);
    }
    clearUserFromSessionStorage() {
        this.storage.clearUser();
    }
}
AvlOidcCodeAuthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlOidcCodeAuthService, deps: [{ token: i1.HttpBackend }, { token: AUTH_CONFIG }, { token: i2.Router }, { token: i3.Location }], target: i0.ɵɵFactoryTarget.Injectable });
AvlOidcCodeAuthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlOidcCodeAuthService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlOidcCodeAuthService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpBackend }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [AUTH_CONFIG]
                }] }, { type: i2.Router }, { type: i3.Location }]; } });

class AvlTokenInterceptor {
    constructor(auth, basePaths) {
        this.auth = auth;
        this.basePaths = basePaths;
        for (const i in this.basePaths) {
            if (this.basePaths.hasOwnProperty(i)) {
                this.basePaths[i] = this.basePaths[i].toLowerCase();
            }
        }
    }
    intercept(req, next) {
        if (!this.isUrlInBasePaths(req)) {
            return next.handle(req);
        }
        if (this.auth.currentUser) {
            req = this.setAuthHeader(req);
        }
        return next
            .handle(req)
            .pipe(catchError((err) => this.handleHttpError(req, next, err)));
    }
    handleHttpError(req, next, err) {
        if (err.status === 401) {
            // Unauthorized, tokens expired
            return from(this.auth.refreshTokens()).pipe(switchMap(_ => next.handle(this.setAuthHeader(req))), catchError(_ => throwError(err)));
        }
        return throwError(err);
    }
    /** Check if request URL is in provided basePaths
     * @param request Http request instance whose URL is checked.
     */
    isUrlInBasePaths(request) {
        const url = request.url.toLowerCase();
        const path = this.basePaths.find(path => url.startsWith(path));
        return Boolean(path);
    }
    /** Sets access token to authorization header of HTTP request
     * @param request HTTP request instance
     * @returns Cloned HTTP with adapted headers
     */
    setAuthHeader(req) {
        const access_token = this.auth.currentUser.access_token;
        const header = `Bearer ${access_token}`;
        const headers = req.headers.set('Authorization', header);
        return req.clone({ headers });
    }
}
AvlTokenInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlTokenInterceptor, deps: [{ token: AvlAuthService }, { token: INTERCEPTOR_BASE_PATHS }], target: i0.ɵɵFactoryTarget.Injectable });
AvlTokenInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlTokenInterceptor });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: AvlTokenInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: AvlAuthService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [INTERCEPTOR_BASE_PATHS]
                }] }]; } });

var MessageType;
(function (MessageType) {
    MessageType["action"] = "action";
    MessageType["colorScheme"] = "colorScheme";
    MessageType["language"] = "language";
    MessageType["locale"] = "locale";
    MessageType["navigation"] = "navigation";
    MessageType["unsavedChanges"] = "unsavedChanges";
    MessageType["registration"] = "registration";
    MessageType["theme"] = "theme";
    MessageType["login"] = "login";
    MessageType["authentication"] = "authentication";
    MessageType["redirectedFromLogIn"] = "redirectedFromLogIn";
    MessageType["user"] = "user";
    MessageType["shellInfo"] = "shellInfo";
})(MessageType || (MessageType = {}));

class ShellCommunicationService {
    constructor(router, authService) {
        this.router = router;
        this.authService = authService;
        this.handlers = {
            [MessageType.theme]: (theme) => this.handleTheme(theme),
            [MessageType.locale]: (locale) => this.handleLocale(locale),
            [MessageType.language]: (language) => this.handleLanguage(language),
            [MessageType.colorScheme]: (colorScheme) => this.handleColorScheme(colorScheme),
            [MessageType.navigation]: (url) => this.handleNavigation(url),
            [MessageType.action]: (action) => this.handleAction(action),
            [MessageType.authentication]: (user) => this.handleAuthentication(user),
            [MessageType.redirectedFromLogIn]: (redirected) => this.handleRedirectedFromLogIn(redirected),
            [MessageType.shellInfo]: (shellInfo) => this.handleShellInfo(shellInfo)
        };
        this.themeSubject = new Subject();
        this.languageSubject = new Subject();
        this.actionSubject = new Subject();
        this.localeSubject = new Subject();
        this.colorSchemeSubject = new Subject();
        this.shellInfoSubject = new Subject();
        this.shellUrl = '';
        /**
         * Observable tracking theme
         * Emits 'dark' if dark theme selected, 'light' otherwise
         */
        this.theme$ = this.themeSubject;
        /**
         * Observable tracking language
         */
        this.language$ = this.languageSubject;
        this.action$ = this.actionSubject;
        /**
         * Observable tracking locale changes
         */
        this.locale$ = this.localeSubject;
        /**
         * Observable tracking color scheme changes
         */
        this.colorScheme$ = this.colorSchemeSubject;
        /**
         * Observable tracking if redirected from idb
         * Resolves to true on redirection, false otherwise
         */
        this.redirectedFromLogIn = new BehaviorSubject(undefined);
        /**
         * Observable tracking shell origin and list of children
         */
        this.shellInfo$ = this.shellInfoSubject;
        /**
         * If current application is inside shell application
         * True if current application is inside shell application, false otherwise.
         */
        this.isChild = window.location !== window.parent.location;
        window.addEventListener('message', event => this.onMessage(event));
        this.id = v4();
    }
    notifyShellAboutAction(action) {
        this.postMessageToShell(MessageType.action, action);
    }
    /**
     * Sends message to shell that it needs to navigate to login page
     */
    notifyShellAboutLogin(url) {
        this.postMessageToShell(MessageType.login, url);
    }
    /**
     * Sends message containing information about unsaved changes in a form to shell
     */
    notifyShellAboutUnsavedChanges(formDirty) {
        this.postMessageToShell(MessageType.unsavedChanges, formDirty);
    }
    /**
     * Sends message to shell that it needs to navigate to @url
     */
    notifyShellAboutNavigation(url) {
        this.postMessageToShell(MessageType.navigation, url);
    }
    /**
     * Sends registration message to shell
     */
    registerToShell() {
        this.postMessageToShell(MessageType.registration, this.id);
    }
    /**
     * Send updated user data to shell
     */
    updateUserToShell() {
        const user = this.authService.readUserFromSessionStorage();
        this.postMessageToShell(MessageType.user, user);
    }
    onMessage(event) {
        // if the app is used as a child in iframe, it should only accept messages
        // comming from shell using shell origin
        if (this.shellUrl && this.shellUrl != event.origin) {
            return;
        }
        const { payload, messageType } = event.data;
        const handlers = Object.assign(Object.assign({}, this.handlers), { default: () => console.log('Unrecognized message for the child.', event) });
        (handlers[messageType] || handlers.default)(payload);
    }
    postMessageToShell(messageType, payload) {
        const message = { messageType, payload };
        // send to shellUrl targetOrigin as soon it is awailable (shell must provide it after registration)
        if (this.shellUrl) {
            window.parent.window.postMessage(message, this.shellUrl);
        }
        else if (document.referrer && message.messageType === MessageType.registration) {
            const url = new URL(document.referrer);
            window.parent.window.postMessage(message, url.origin);
        }
    }
    handleColorScheme(colorScheme) {
        this.colorSchemeSubject.next(colorScheme);
    }
    handleLanguage(language) {
        this.languageSubject.next(language);
    }
    handleLocale(locale) {
        this.localeSubject.next(locale);
    }
    handleTheme(theme) {
        this.themeSubject.next(theme);
    }
    handleNavigation(url) {
        this.router.navigateByUrl(url);
    }
    handleAction(action) {
        this.actionSubject.next(action);
    }
    handleAuthentication(user) {
        if (user === null || user === void 0 ? void 0 : user.access_token) {
            this.authService.storeUserToSessionStorage(user);
        }
        else {
            this.authService.clearUserFromSessionStorage();
        }
        this.authService.reloadPersistedUserData();
    }
    handleRedirectedFromLogIn(redirected) {
        this.redirectedFromLogIn.next(redirected);
    }
    handleShellInfo(shellInfo) {
        if (shellInfo) {
            this.shellUrl = new URL(shellInfo.url).origin;
        }
        this.shellInfoSubject.next(shellInfo);
        this.shellInfo = shellInfo;
    }
}
ShellCommunicationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: ShellCommunicationService, deps: [{ token: i2.Router }, { token: AvlAuthService }], target: i0.ɵɵFactoryTarget.Injectable });
ShellCommunicationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: ShellCommunicationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: ShellCommunicationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2.Router }, { type: AvlAuthService }]; } });

class NgxTranslateTranslationService {
    constructor(translateService) {
        this.translateService = translateService;
    }
    get language() {
        return this.translateService.currentLang;
    }
    translate(key, interpolateParams) {
        return this.translateService.get(key, interpolateParams).toPromise();
    }
}
NgxTranslateTranslationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: NgxTranslateTranslationService, deps: [{ token: i1$1.TranslateService }], target: i0.ɵɵFactoryTarget.Injectable });
NgxTranslateTranslationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: NgxTranslateTranslationService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: NgxTranslateTranslationService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.TranslateService }]; } });

class TranslationManagementService {
    constructor(translateService, translationService) {
        this.translateService = translateService;
        this.translationService = translationService;
        this.languages = [
            { code: 'en', label: 'English' },
            { code: 'hr', label: 'Croatian' }
        ];
    }
    initializeTranslations() {
        return () => {
            AvlLocalizationService.translationService = this.translationService;
            let lang = localStorage.getItem('lang');
            if (lang == null) {
                lang = this.languages[0].code;
                localStorage.setItem('lang', lang);
            }
            return this.translateService.use(lang).toPromise();
        };
    }
    get language() {
        return localStorage.getItem('lang');
    }
    changeLanguage(lang) {
        const oldLang = localStorage.getItem('lang');
        if (!oldLang || oldLang !== lang) {
            localStorage.setItem('lang', lang);
            location.reload();
        }
    }
}
TranslationManagementService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: TranslationManagementService, deps: [{ token: i1$1.TranslateService }, { token: NgxTranslateTranslationService }], target: i0.ɵɵFactoryTarget.Injectable });
TranslationManagementService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: TranslationManagementService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: TranslationManagementService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1$1.TranslateService }, { type: NgxTranslateTranslationService }]; } });

class ThemeService {
    constructor() {
        this.themeChangedSubject = new Subject();
        this.themeChanged = this.themeChangedSubject.asObservable();
        this.changeTheme();
    }
    /**
     * Determines whether theme is dark or not
     */
    get isDarkTheme() {
        if (this._isDarkTheme == null) {
            this._isDarkTheme = localStorage.getItem('theme') === 'dark' || false;
        }
        return this._isDarkTheme;
    }
    /**
     * Sets the dark theme to true or false
     * @param isDark boolean that sets theme to dark if true; light if false
     */
    set isDarkTheme(isDark) {
        this._isDarkTheme = isDark;
        localStorage.setItem('theme', isDark === true ? 'dark' : 'light');
        this.themeChangedSubject.next(this.getCurrentTheme());
        this.changeTheme();
    }
    /**
     * Gets current theme string
     * @returns string 'dark' or 'light'
     */
    getCurrentTheme() {
        return this.isDarkTheme ? 'dark' : 'light';
    }
    changeTheme() {
        document.body.setAttribute('theme', this.getCurrentTheme());
    }
}
ThemeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: ThemeService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ThemeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: ThemeService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: ThemeService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

class ChildCommunicationService {
    constructor(translationManagementService, themeService, authService) {
        this.translationManagementService = translationManagementService;
        this.themeService = themeService;
        this.authService = authService;
        this.handlers = {
            [MessageType.login]: (url) => this.handleLogin(url),
            [MessageType.navigation]: (url) => this.handleNavigation(url),
            [MessageType.action]: (action) => this.handleAction(action),
            [MessageType.registration]: _ => this.handleRegistration(),
            [MessageType.user]: (user) => this.handleUser(user),
            [MessageType.unsavedChanges]: (formDirty) => this.handleUnsavedChanges(formDirty)
        };
        this.actionSubject = new Subject();
        this.navigationSubject = new Subject();
        this.loginSubject = new Subject();
        this.registrationCompletedSubject = new Subject();
        this.unsavedChangesSubject = new BehaviorSubject(false);
        this.action$ = this.actionSubject;
        /**
         * Observable tracking url to navigate to
         */
        this.navigation$ = this.navigationSubject;
        /**
         * Observable tracking url for login
         * Url for login provided by child application
         */
        this.login$ = this.loginSubject;
        /**
         * Observable tracking if there are unsaved changes in a form
         */
        this.unsavedChanges$ = this.unsavedChangesSubject.asObservable();
        /**
         * Observable tracking child registration
         * Emits true if registration was successful, false otherwise
         */
        this.registrationCompleted$ = this.registrationCompletedSubject;
        window.addEventListener('message', event => this.onMessage(event));
        this.themeService.themeChanged.subscribe(() => this.postThemeToChildren());
    }
    /**
     * Sends the new value to the unsaved changes observer
     * @param value Value to send to the observer
     */
    handleUnsavedChanges(formDirty) {
        this.unsavedChangesSubject.next(formDirty);
    }
    /**
     * Sends message to child about locale
     */
    notifyChildAboutLocale(locale) {
        this.postMessageToChild(MessageType.locale, locale);
    }
    /**
     * Sends message to child about language
     */
    notifyChildAboutLanguage(language) {
        this.postMessageToChild(MessageType.language, language);
    }
    /**
     * Sends message to child about action
     */
    notifyChildAboutAction(action) {
        this.postMessageToChild(MessageType.action, action);
    }
    /**
     * Sends message to child about navigation
     */
    notifyChildAboutNavigation(url) {
        this.postMessageToChild(MessageType.navigation, url);
    }
    /**
     * Sends messages to children about current user
     */
    postAuthenticationDataToChildren() {
        const payload = this.authService.readUserFromSessionStorage();
        this.postMessageToChild(MessageType.authentication, payload);
    }
    /**
     * Sends messages to children about selected application theme
     */
    postThemeToChildren() {
        const theme = this.themeService.getCurrentTheme();
        this.postMessageToChild(MessageType.theme, theme);
    }
    /**
     * Sends messages to children about selected language
     */
    postLanguageToChildren() {
        this.postMessageToChild(MessageType.language, this.translationManagementService.language);
    }
    /**
     * Sends messages to children about selected locale
     */
    postLocaleToChildren() {
        const country = localStorage.getItem('country');
        const dateTimeFormat = localStorage.getItem('dateTimeFormat');
        const decimalSeparator = localStorage.getItem('decimalSeparator');
        this.postMessageToChild(MessageType.locale, {
            country,
            dateTimeFormat,
            decimalSeparator
        });
    }
    /**
     * Sends message to child about redirection from idb
     */
    postRedirectedFromLogIn(payload) {
        this.postMessageToChild(MessageType.redirectedFromLogIn, payload);
    }
    /**
     * Sends message to child about shell url (origin/solution/app name) and list of children
     */
    postShellInfoToChildren(payload) {
        this.postMessageToChild(MessageType.shellInfo, payload);
    }
    /**
     * Sends message to children about color scheme
     */
    postColorSchemeToChildren() {
        const computedStyle = window.getComputedStyle(document.body);
        const productColor = computedStyle.getPropertyValue('--avl-product-color');
        const productHoverColor = computedStyle.getPropertyValue('--avl-product-hover-color');
        const productFocusColor = computedStyle.getPropertyValue('--avl-product-focus-color');
        const colorScheme = {
            '--avl-product-color': productColor,
            '--avl-product-hover-color': productHoverColor,
            '--avl-product-focus-color': productFocusColor
        };
        this.postMessageToChild(MessageType.colorScheme, colorScheme);
    }
    handleAction(action) {
        this.actionSubject.next(action);
    }
    handleNavigation(navigation) {
        this.handleUnsavedChanges(false);
        this.navigationSubject.next(navigation);
    }
    handleLogin(login) {
        this.loginSubject.next(login);
    }
    // when child started its registration iframe is loaded and shell gets a message that he can send messages to iframe
    handleRegistration() {
        this.iframeEl = document.getElementsByTagName('iframe')[0];
        this.postThemeToChildren();
        this.postColorSchemeToChildren();
        this.postLanguageToChildren();
        this.postLocaleToChildren();
        this.registrationCompletedSubject.next(true);
    }
    onMessage(event) {
        const { payload, messageType } = event.data;
        if (messageType !== MessageType.registration && !this.iframeEl) {
            return;
        }
        if (this.iframeEl) {
            // ignore messages that are not from iframe
            const url = new URL(this.iframeEl.src);
            if (url.origin !== event.origin) {
                return;
            }
        }
        const handlers = Object.assign(Object.assign({}, this.handlers), { default: () => console.log('Unrecognized message for the shell.', event) });
        (handlers[messageType] || handlers.default)(payload);
    }
    postMessageToChild(messageType, payload) {
        var _a;
        if (!this.iframeEl) {
            return;
        }
        const message = { messageType, payload };
        const url = new URL(this.iframeEl.src);
        (_a = this.iframeEl.contentWindow) === null || _a === void 0 ? void 0 : _a.postMessage(message, url.origin);
    }
    // when child updates user data, it has to reflect in user data in shell
    handleUser(user) {
        var _a;
        if (user && (user === null || user === void 0 ? void 0 : user.access_token) !== ((_a = this.authService.currentUser) === null || _a === void 0 ? void 0 : _a.access_token)) {
            this.authService.storeUserToSessionStorage(user);
            this.authService.reloadPersistedUserData();
        }
        else if (user === null && this.authService.isUserInvalid(this.authService.currentUser)) {
            this.authService.clearUserFromSessionStorage();
            this.authService.reloadPersistedUserData();
        }
    }
}
ChildCommunicationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: ChildCommunicationService, deps: [{ token: TranslationManagementService }, { token: ThemeService }, { token: AvlAuthService }], target: i0.ɵɵFactoryTarget.Injectable });
ChildCommunicationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: ChildCommunicationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: ChildCommunicationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: TranslationManagementService }, { type: ThemeService }, { type: AvlAuthService }]; } });

/**
 * List of all types of messages that can be logged.
 */
var LogSeverity;
(function (LogSeverity) {
    LogSeverity[LogSeverity["Debug"] = 0] = "Debug";
    LogSeverity[LogSeverity["Info"] = 1] = "Info";
    LogSeverity[LogSeverity["Warning"] = 2] = "Warning";
    LogSeverity[LogSeverity["Error"] = 3] = "Error";
    LogSeverity[LogSeverity["Fatal"] = 4] = "Fatal";
})(LogSeverity || (LogSeverity = {}));
/**
 * **LogConfig** class is required by the _LoggingModule_.
 *
 * An instance of this class should be passed into _forRoot_ method of _LoggingModule_
 * when importing module in the Angular application.
 * ```
 * import logConfig from 'logging.config.ts;
 * import LoggingModule from '@avl-services/ng-services';
 *  ....
 *  @NgModule({
 *    imports: [
 *      LoggingModule.forRoot(logConfig),
 *      ...
 *    ],
 *    ...
 *  }) export class AppModule {}
 * ```
 */
class LogConfig {
    /**
     * Creates instance of _LogConfig_ class.
     * @param endpoint API endpoint for logging.
     * @param targetName Name of the database in which logs will be stored
     * @param appName Name of the application that uses the logging service
     * @param version Version of the application that uses the logging service
     * @param autologging Flag that indicates whether logging starts automatically once the user logs in using credential. Default: false
     * @param globalLogLevel Minimum message severity to log. Default: LogSeverity.Info
     * @param debounceTime Time in milliseconds, determines the period of API requests for logging. Default: 30_000 ms
     * @param capacity Log queue capacity. Default: 10
     */
    constructor(endpoint, targetName, appName, version, autologging = false, globalLogLevel = LogSeverity.Info, debounceTime = 30000, capacity = 10) {
        /**
         * Flag that indicates whether logging starts automatically once the user logs in using credential.
         *
         * If true, app requires _AvlAuthService_ instance in _AppModule_ providers array:
         * ```
         * { provide: AvlAuthService, useClass: AvlOidcCodeAuthService }
         * ```
         * If false, user can control logging using the service (_startLogging_, _stopLogging_ methods).
         *
         * - Optional
         * - Default: false
         */
        this.autologging = false;
        /**
         * Minimum message severity to log.
         * - Optional
         * - Default: LogSeverity.Info
         */
        this.globalLogLevel = LogSeverity.Info;
        /**
         * Time in milliseconds, determines the period of API requests for logging.
         * - Optional
         * - Default: 30_000 ms
         */
        this.debounceTime = 30000;
        /**
         * Log queue capacity
         *
         * If reached, API request is sent with all logs in log queue, and queue is cleared out.
         * - Optional
         * - Default: 10
         */
        this.capacity = 10;
        this.endpoint = endpoint;
        this.targetName = targetName;
        this.appName = appName;
        this.version = version;
        this.autologging = autologging;
        this.globalLogLevel = globalLogLevel;
        this.debounceTime = debounceTime;
        this.capacity = capacity;
    }
}

class LoggingService {
    /**
     * @ignore
     */
    constructor(http, config, authService) {
        var _a;
        this.http = http;
        this.config = config;
        this.authService = authService;
        this.logs = [];
        this.isLogging = false;
        this.debounceTime$ = new Subject();
        this.logs$ = new Subject();
        this.stopLogging$ = new Subject();
        this.postLogs$ = new Subject();
        this.destroyed$ = new Subject();
        this.headers = new HttpHeaders({
            targetName: this.config.targetName,
        });
        if (config.autologging) {
            (_a = this.authService) === null || _a === void 0 ? void 0 : _a.isLoggedIn$.pipe(takeUntil(this.destroyed$)).subscribe((isLoggedIn) => this.decideOnLogging(isLoggedIn));
        }
    }
    /**
     * @ignore
     */
    ngOnDestroy() {
        this.postLogs$.complete();
        this.debounceTime$.complete();
        this.logs$.complete();
        this.stopLogging$.next();
        this.stopLogging$.complete();
        this.destroyed$.next();
        this.destroyed$.complete();
    }
    /**
     * Starts periodical logging process.
     *
     * Depends on _debounceTime_ and _capacity_ properties.
     */
    startLogging() {
        this.isLogging = true;
        this.debounceTime$
            .pipe(takeUntil(this.stopLogging$), switchMap((debounceTime) => this.periodicalLogging(debounceTime)))
            .subscribe(() => this.onPostMessages());
        this.postLogs$
            .pipe(takeUntil(this.stopLogging$), switchMap(() => this.postMessages()))
            .subscribe(() => this.onPostMessages());
        this.setLoggingDebounceTime(this.config.debounceTime);
    }
    /**
     * Stops logging process.
     */
    stopLogging() {
        this.isLogging = false;
        this.postLogs();
        this.stopLogging$.next();
    }
    /**
     * Gets all currently queued logs as an observable value.
     * @returns All currently queued logs as an observable value
     */
    getLogs$() {
        return this.logs$.asObservable();
    }
    /**
     * Logs message with debug severity.
     * @param message Message used for constructing a debug log
     * @param componentName Name of the component which called this method
     */
    debug(message, componentName = '') {
        this.log(message, LogSeverity.Debug, componentName);
    }
    /**
     * Logs message with info severity.
     * @param message Message used for constructing a info log
     * @param componentName Name of the component which called this method
     */
    info(message, componentName = '') {
        this.log(message, LogSeverity.Info, componentName);
    }
    /**
     * Logs message with warning severity.
     * @param message Message used for constructing a warning log
     * @param componentName Name of the component which called this method
     */
    warn(message, componentName = '') {
        this.log(message, LogSeverity.Warning, componentName);
    }
    /**
     * Logs message with error severity.
     * @param message Message used for constructing a error log
     * @param componentName Name of the component which called this method
     */
    error(message, componentName = '') {
        this.log(message, LogSeverity.Error, componentName);
    }
    /**
     * Logs message with fatal severity.
     * @param message Message used for constructing a fatal log
     * @param componentName Name of the component which called this method
     */
    fatal(message, componentName = '') {
        this.log(message, LogSeverity.Fatal, componentName);
    }
    /**
     * Setter for debounce time (log period).
     * @param debounceTime Time in milliseconds; determines the period of API requests for logging
     */
    setLoggingDebounceTime(debounceTime) {
        this.config.debounceTime = debounceTime;
        this.debounceTime$.next(debounceTime);
    }
    /**
     * Setter for global log level.
     * @param globalLogLevel Minimum message severity to log
     */
    setGlobalLogLevel(globalLogLevel) {
        this.config.globalLogLevel = globalLogLevel;
    }
    /**
     * Setter for log queue capacity.
     * @param capacity Log queue capacity
     */
    setLogCapacity(capacity) {
        this.config.capacity = capacity;
    }
    // Logic, private methods
    log(message, severity, componentName) {
        if (!this.isLogging || severity < this.config.globalLogLevel) {
            return;
        }
        this.createAndStoreLog(message, severity, componentName);
        this.dispatchLogs();
        if (this.isFullCapacity()) {
            this.postLogs$.next();
        }
    }
    createAndStoreLog(message, severityType, componentName) {
        const timestamp = new Date().toISOString();
        const { appName, version } = this.config;
        const severity = severityType.toString();
        const log = { message, severity, timestamp, componentName, appName, version };
        this.logs.push(log);
    }
    isFullCapacity() {
        return this.logs.length >= this.config.capacity;
    }
    clearLogs() {
        this.logs = [];
    }
    onPostMessages() {
        this.clearLogs();
        this.dispatchLogs();
    }
    postLogs() {
        this.postLogs$.next();
    }
    periodicalLogging(period) {
        return interval(period).pipe(tap(() => {
            if (!this.logs.length) {
                this.dispatchLogs();
            }
        }), filter(() => !!this.logs.length), switchMap(() => this.postMessages()));
    }
    postMessages() {
        return this.http.post(this.config.endpoint, this.logs, {
            headers: this.headers,
        });
    }
    dispatchLogs() {
        this.logs$.next(this.logs);
    }
    decideOnLogging(isLoggedIn) {
        if (isLoggedIn) {
            this.startLogging();
        }
        else {
            this.stopLogging();
        }
    }
}
LoggingService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: LoggingService, deps: [{ token: i1.HttpClient }, { token: 'loggingConfig' }, { token: AvlAuthService, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
LoggingService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: LoggingService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: LoggingService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: LogConfig, decorators: [{
                    type: Inject,
                    args: ['loggingConfig']
                }] }, { type: AvlAuthService, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [AvlAuthService]
                }] }]; } });

class LoggingModule {
    constructor(parentModule) {
        if (parentModule) {
            throw new Error('LoggingModule is already loaded. Import it in the AppModule only');
        }
    }
    static forRoot(config) {
        return {
            ngModule: LoggingModule,
            providers: [LoggingService, { provide: 'loggingConfig', useValue: config }],
        };
    }
}
LoggingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: LoggingModule, deps: [{ token: LoggingModule, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.NgModule });
LoggingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: LoggingModule });
LoggingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: LoggingModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: LoggingModule, decorators: [{
            type: NgModule
        }], ctorParameters: function () { return [{ type: LoggingModule, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }]; } });

class NotificationService {
    constructor() {
        this.hubConnections = [];
        this.notification = new Subject();
        /**
         * Observable which emits newly arrived notifications.
         */
        this.notification$ = this.notification;
    }
    /**
     * Builds and starts signalR hub connection with the server.
     * If connection already exists and is not connected, restarts the connection.
     * @param endpoint server endpoint
     * @param options options of the connection
     */
    startConnection(endpoint, options) {
        let connection = this.getConnectionByID(options.connectionID);
        if (!connection) {
            connection = this.buildConnection(endpoint, options);
        }
        if (connection.state === HubConnectionState.Connected) {
            return;
        }
        connection
            .start()
            .then(() => this.startNotifications(connection, options.metadata))
            .catch(() => console.warn('Notification service: Failed to establish connection.'));
    }
    /**
     * Stops connection with the server
     * @param connectionID connection identifier
     */
    stopConnection(connectionID) {
        const connection = this.getConnectionByID(connectionID);
        if (!connection) {
            return;
        }
        connection.off('transferNotification');
        connection.stop();
    }
    /**
     * Removes connection entirely
     * @param connectionID connection identifier
     */
    removeConnection(connectionID) {
        this.stopConnection(connectionID);
        const index = this.hubConnections.findIndex(connection => connection.id === connectionID);
        if (index !== -1) {
            this.hubConnections.splice(index, 1);
        }
    }
    /**
     * Updates notifications metadata for specific connection. Notifies server about it.
     * @param connectionID connection identifier
     * @param metadata notification metadata, (e.g language)
     */
    updateNotifications(connectionID, metadata) {
        const connection = this.getConnectionByID(connectionID);
        if (!connection) {
            return;
        }
        this.startNotifications(connection, metadata);
    }
    // Private methods
    startNotifications(connection, metadata) {
        connection.invoke('startNotifications', metadata);
    }
    getConnectionByID(connectionID) {
        var _a;
        const index = this.hubConnections.findIndex(connection => connection.id === connectionID);
        return (_a = this.hubConnections[index]) === null || _a === void 0 ? void 0 : _a.connection;
    }
    buildConnection(endpoint, options) {
        const hubConnection = new HubConnectionBuilder()
            .configureLogging(LogLevel.None)
            .withUrl(endpoint, { accessTokenFactory: () => options.accessToken })
            .withAutomaticReconnect()
            .build();
        hubConnection.onreconnected(() => this.startNotifications(hubConnection, options.metadata));
        hubConnection.on('transferNotification', (notification) => {
            this.notification.next(notification);
        });
        this.hubConnections.push({
            id: options.connectionID,
            connection: hubConnection
        });
        return hubConnection;
    }
}
NotificationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: NotificationService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NotificationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: NotificationService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: NotificationService, decorators: [{
            type: Injectable
        }] });

const UPLOAD_SERVICE = new InjectionToken('UPLOAD_SERVICE');

class UploadService {
    constructor(httpClient) {
        this.httpClient = httpClient;
    }
    downloadFile(url, progressCallback, completeCallback, failCallback) {
        const req = this.httpClient.get(url, { reportProgress: true, responseType: 'blob', observe: 'events' })
            .pipe(map(event => {
            if (event.type === HttpEventType.DownloadProgress) {
                progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback(event);
            }
            if (event.type === HttpEventType.Response && event.body != null) {
                completeCallback === null || completeCallback === void 0 ? void 0 : completeCallback(event.body);
            }
        }), catchError((err) => {
            const response = err.error instanceof Event ? err.error.target.response : err.error;
            if (failCallback) {
                failCallback({
                    status: err.status,
                    response: response
                });
            }
            return of(null);
        }));
        const subscription = req.subscribe();
        return subscription.unsubscribe.bind(subscription);
    }
    uploadFile(file, target, progressCallback, completeCallback, failCallback) {
        const formData = new FormData();
        formData.append('file', file.file);
        const uploadReq = this.httpClient.post(target, formData, { reportProgress: true, observe: 'events' })
            .pipe(map(event => {
            if (event.type === HttpEventType.UploadProgress) {
                progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback(event);
            }
            if (event.type === HttpEventType.Response) {
                if (event.body != null && event.body.downloadUrl) {
                    completeCallback === null || completeCallback === void 0 ? void 0 : completeCallback(event.body.downloadUrl);
                }
                else {
                    completeCallback === null || completeCallback === void 0 ? void 0 : completeCallback();
                }
            }
        }), catchError((err, caught) => {
            const response = err.error instanceof Event ? err.error.target.response : err.error;
            if (failCallback) {
                failCallback({
                    status: err.status,
                    response: response
                });
            }
            return of(null);
        }));
        const subscription = uploadReq.subscribe();
        return subscription.unsubscribe.bind(subscription);
    }
}
UploadService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UploadService, deps: [{ token: i1.HttpClient }], target: i0.ɵɵFactoryTarget.Injectable });
UploadService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UploadService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UploadService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }]; } });

class UnsavedChangesShellService {
    constructor() {
        /**
         * Boolean value for opening and closing of the unsaved changes warning dialog
         */
        this.isDialogOpen = false;
        /**
         * Boolean value indicating if there are unsaved changes in the application
         */
        this.hasUnsavedChanges = false;
        /**
         * If current application is inside shell application
         * True if current application is inside shell application, false otherwise.
         */
        this.isChild = window.location !== window.parent.location;
        /**
         * Subject tracking if the user can navigate in application, default value is true
         */
        this.canNavigateSubject = new BehaviorSubject(true);
        this.preventRefresh();
    }
    /**
     * Called when user clicks the 'Leave' button, allows navigation and closes the dialog
     */
    onProceed() {
        this.hasUnsavedChanges = false;
        this.canNavigateSubject.next(true);
        this.closeDialog();
    }
    /**
     * Called when user clicks the 'Stay' button, keeps the state, doesn't allow navigation
     * and closes the dialog
     */
    onAbort() {
        this.canNavigateSubject.next(false);
        this.closeDialog();
    }
    preventRefresh() {
        window.onbeforeunload = (event) => {
            if (this.hasUnsavedChanges) {
                if (this.isChild && !this.isDialogOpen) {
                    event.preventDefault();
                }
                else if (!this.isChild) {
                    event.returnValue = true;
                }
            }
            else {
                event.preventDefault();
            }
        };
    }
    /**
     * Opens the unsaved changes warning dialog
     */
    openDialog() {
        this.isDialogOpen = true;
    }
    /**
     * Closes the unsaved changes warning dialog
     */
    closeDialog() {
        this.isDialogOpen = false;
    }
}
UnsavedChangesShellService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesShellService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
UnsavedChangesShellService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesShellService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesShellService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return []; } });

class UnsavedChangesService extends UnsavedChangesShellService {
    constructor(shellCommunicationService) {
        super();
        this.shellCommunicationService = shellCommunicationService;
        /**
         * Boolean value for opening and closing of the unsaved changes warning dialog
         */
        this.isDialogOpen = false;
        this.formArray = [];
    }
    /**
     * Adds the form to the form array and notifies shell if there are any unsaved changes in forms
     * @param form Form to be registered
     */
    registerForm(form) {
        this.formArray.push(form);
        form.valueChanges.pipe(debounceTime(300)).subscribe(() => {
            super.hasUnsavedChanges = this.isAnyFormDirty();
            this.shellCommunicationService.notifyShellAboutUnsavedChanges(this.isAnyFormDirty());
        });
    }
    /**
     * Removes the form from the form array and notifies shell and child
     * @hidden
     * @param form Form to be unregistered
     */
    unregisterForm(form) {
        this.formArray.splice(this.formArray.indexOf(form), 1);
        super.hasUnsavedChanges = this.isAnyFormDirty();
        this.shellCommunicationService.notifyShellAboutUnsavedChanges(this.isAnyFormDirty());
    }
    /**
     * @hidden
     * @returns Array of forms registered to the service
     */
    getRegisteredForms() {
        return this.formArray;
    }
    /**
     * Method checking if there are unsaved changes in any of the forms
     * @returns Boolean value indicating is there a 'dirty' form
     */
    isAnyFormDirty() {
        return this.formArray.some(form => {
            if (!form) {
                return false;
            }
            let formGroupValues = Object.values(form.value);
            return formGroupValues.some((value) => Boolean(value));
        });
    }
    /**
     * Updates observers, closes the unsaved changes dialog, allows the user to navigate away
     * and notifies shell
     */
    onProceed() {
        super.onProceed();
        this.shellCommunicationService.notifyShellAboutUnsavedChanges(false);
    }
    /**
     * Updates observers, closes the unsaved changes dialog and keeps the user on the same page
     */
    onAbort() {
        super.onAbort();
    }
}
UnsavedChangesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesService, deps: [{ token: ShellCommunicationService }], target: i0.ɵɵFactoryTarget.Injectable });
UnsavedChangesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: ShellCommunicationService }]; } });

class UnsavedChangesDirective {
    constructor(unsavedChangesService) {
        this.unsavedChangesService = unsavedChangesService;
    }
    ngOnInit() {
        this.unsavedChangesService.registerForm(this.formGroup);
    }
    ngOnDestroy() {
        this.unsavedChangesService.unregisterForm(this.formGroup);
    }
    ngOnChanges(changes) {
        if (changes.formGroup.previousValue !== changes.formGroup.currentValue && changes.formGroup.firstChange === false) {
            this.unsavedChangesService.unregisterForm(this.formGroup);
            this.unsavedChangesService.registerForm(changes.formGroup.currentValue);
        }
        if (this.formGroup === undefined) {
            throw new Error("Attribute 'formGroup' is required");
        }
    }
}
UnsavedChangesDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesDirective, deps: [{ token: UnsavedChangesService }], target: i0.ɵɵFactoryTarget.Directive });
UnsavedChangesDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.3", type: UnsavedChangesDirective, selector: "form[detectUnsavedChanges]", inputs: { formGroup: "formGroup" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'form[detectUnsavedChanges]'
                }]
        }], ctorParameters: function () { return [{ type: UnsavedChangesService }]; }, propDecorators: { formGroup: [{
                type: Input
            }] } });

class UnsavedChangesGuard {
    constructor(unsavedChangesService) {
        this.unsavedChangesService = unsavedChangesService;
    }
    canDeactivate() {
        if (this.unsavedChangesService.isAnyFormDirty()) {
            this.unsavedChangesService.openDialog();
            return this.unsavedChangesService.canNavigateSubject.pipe(skip(1));
        }
        else {
            return true;
        }
    }
}
UnsavedChangesGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesGuard, deps: [{ token: UnsavedChangesService }], target: i0.ɵɵFactoryTarget.Injectable });
UnsavedChangesGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesGuard, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: UnsavedChangesService }]; } });

class UnsavedChangesModule {
    static forRoot() {
        return {
            ngModule: UnsavedChangesModule,
            providers: [UnsavedChangesGuard, UnsavedChangesShellService, UnsavedChangesService]
        };
    }
}
UnsavedChangesModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
UnsavedChangesModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesModule, declarations: [UnsavedChangesDirective], exports: [UnsavedChangesDirective] });
UnsavedChangesModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0, type: UnsavedChangesModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [UnsavedChangesDirective],
                    exports: [UnsavedChangesDirective]
                }]
        }] });

/*
 * Public API Surface of ng-services
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AUTH_CONFIG, AvlAuthService, AvlOidcCodeAuthService, AvlTokenInterceptor, ChildCommunicationService, INTERCEPTOR_BASE_PATHS, LogConfig, LogSeverity, LoggingModule, LoggingService, MessageType, NgxTranslateTranslationService, NotificationService, ShellCommunicationService, ThemeService, TranslationManagementService, UPLOAD_SERVICE, UnsavedChangesDirective, UnsavedChangesGuard, UnsavedChangesModule, UnsavedChangesService, UnsavedChangesShellService, UploadService };
//# sourceMappingURL=avl-services-ng-services.js.map
