import { __assign, __decorate, __param } from 'tslib';
import { ɵɵdefineInjectable, ɵɵinject, Injectable, Inject, Optional, SkipSelf, NgModule } from '@angular/core';
import { Router } from '@angular/router';
import { Subject, BehaviorSubject, interval } from 'rxjs';
import { v4 } from 'uuid';
import { AvlAuthService } from '@avl-ng-controls/auth';
import { TranslateService } from '@ngx-translate/core';
import { NgxTranslateTranslationService } from '@avl-controls/ng-binders';
import '@avl-controls/core/dist/avl-localization-service/avl-localization-service';
import { HttpHeaders, HttpClient } from '@angular/common/http';
import { takeUntil, switchMap, tap, filter } from 'rxjs/operators';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/router';
import * as ɵngcc2 from '@avl-ng-controls/auth';
import * as ɵngcc3 from '@ngx-translate/core';
import * as ɵngcc4 from '@avl-controls/ng-binders';
import * as ɵngcc5 from '@angular/common/http';
var MessageType;
(function (MessageType) {
    MessageType["action"] = "action";
    MessageType["colorScheme"] = "colorScheme";
    MessageType["language"] = "language";
    MessageType["locale"] = "locale";
    MessageType["navigation"] = "navigation";
    MessageType["registration"] = "registration";
    MessageType["theme"] = "theme";
    MessageType["login"] = "login";
    MessageType["authentication"] = "authentication";
    MessageType["redirectedFromLogIn"] = "redirectedFromLogIn";
})(MessageType || (MessageType = {}));

var ShellCommunicationService = /** @class */ (function () {
    function ShellCommunicationService(router, authService) {
        var _a;
        var _this = this;
        this.router = router;
        this.authService = authService;
        this.handlers = (_a = {},
            _a[MessageType.theme] = function (theme) { return _this.handleTheme(theme); },
            _a[MessageType.locale] = function (locale) { return _this.handleLocale(locale); },
            _a[MessageType.language] = function (language) { return _this.handleLanguage(language); },
            _a[MessageType.colorScheme] = function (colorScheme) { return _this.handleColorScheme(colorScheme); },
            _a[MessageType.navigation] = function (url) { return _this.handleNavigation(url); },
            _a[MessageType.action] = function (action) { return _this.handleAction(action); },
            _a[MessageType.authentication] = function (user) { return _this.handleAuthentication(user); },
            _a[MessageType.redirectedFromLogIn] = function (redirected) { return _this.handleRedirectedFromLogIn(redirected); },
            _a);
        this.themeSubject = new Subject();
        this.languageSubject = new Subject();
        this.actionSubject = new Subject();
        this.localeSubject = new Subject();
        this.colorSchemeSubject = new Subject();
        /**
        * Observable tracking theme
        * Emits "dark" if dark theme selected, "light" otherwise
        */
        this.theme$ = this.themeSubject;
        /**
        * Observable tracking language
        */
        this.language$ = this.languageSubject;
        this.action$ = this.actionSubject;
        /**
        * Observable tracking country changes
        */
        this.locale$ = this.localeSubject;
        /**
        * Observable tracking color scheme changes
        */
        this.colorScheme$ = this.colorSchemeSubject;
        /**
         * Observable tracking if redirected from idb
         * Resolves to true on redirection, false otherwise
         */
        this.redirectedFromLogIn = new BehaviorSubject(undefined);
        /**
         * If current application is inside shell application
         * True if current application is inside shell application, false otherwise.
         */
        this.isChild = window.location !== window.parent.location;
        window.addEventListener('message', function (event) { return _this.onMessage(event); });
        this.id = v4();
    }
    ShellCommunicationService.prototype.notifyShellAboutAction = function (action) {
        this.postMessageToShell(MessageType.action, action);
    };
    /**
     * Sends message to shell that it needs to navigate to login page
     */
    ShellCommunicationService.prototype.notifyShellAboutLogin = function (url) {
        this.postMessageToShell(MessageType.login, url);
    };
    /**
     * Sends message to shell that it needs to navigate to @url
     */
    ShellCommunicationService.prototype.notifyShellAboutNavigation = function (url) {
        this.postMessageToShell(MessageType.navigation, url);
    };
    /**
     * Sends registration message to shell
     */
    ShellCommunicationService.prototype.registerToShell = function () {
        this.postMessageToShell(MessageType.registration, this.id);
    };
    ShellCommunicationService.prototype.onMessage = function (event) {
        var _a = event.data, payload = _a.payload, messageType = _a.messageType;
        var handlers = __assign(__assign({}, this.handlers), { default: function () { return console.log('Unrecognized message for the shell.', event); } });
        (handlers[messageType] || handlers.default)(payload);
    };
    ShellCommunicationService.prototype.postMessageToShell = function (messageType, payload) {
        var message = { messageType: messageType, payload: payload };
        window.parent.window.postMessage(message, '*');
    };
    ShellCommunicationService.prototype.handleColorScheme = function (colorScheme) {
        this.colorSchemeSubject.next(colorScheme);
    };
    ShellCommunicationService.prototype.handleLanguage = function (language) {
        this.languageSubject.next(language);
    };
    ShellCommunicationService.prototype.handleLocale = function (locale) {
        this.localeSubject.next(locale);
    };
    ShellCommunicationService.prototype.handleTheme = function (theme) {
        this.themeSubject.next(theme);
    };
    ShellCommunicationService.prototype.handleNavigation = function (url) {
        this.router.navigateByUrl(url);
    };
    ShellCommunicationService.prototype.handleAction = function (action) {
        this.actionSubject.next(action);
    };
    ShellCommunicationService.prototype.handleAuthentication = function (user) {
        if (user === null || user === void 0 ? void 0 : user.access_token) {
            this.setUserToSessionStorage(user);
        }
        else {
            this.removeUserFromSessionStorage();
        }
        this.authService.reloadPersistedUserData();
    };
    ShellCommunicationService.prototype.handleRedirectedFromLogIn = function (redirected) {
        this.redirectedFromLogIn.next(redirected);
    };
    ShellCommunicationService.prototype.setUserToSessionStorage = function (user) {
        sessionStorage.setItem('refresh_token', user.refresh_token);
        sessionStorage.setItem('access_token', user.access_token);
        sessionStorage.setItem('id_token', user.id_token);
        sessionStorage.setItem('refresh_token_expires_at', String(user.refresh_token_expires_at));
        sessionStorage.setItem('access_token_expires_at', String(user.access_token_expires_at));
        sessionStorage.setItem('access_token_stored_at', String(user.access_token_stored_at));
        sessionStorage.setItem('username', user.username);
        sessionStorage.setItem('name', user.name);
        sessionStorage.setItem('roles', JSON.stringify(user.roles));
    };
    ShellCommunicationService.prototype.removeUserFromSessionStorage = function () {
        sessionStorage.removeItem('refresh_token');
        sessionStorage.removeItem('access_token');
        sessionStorage.removeItem('id_token');
        sessionStorage.removeItem('refresh_token_expires_at');
        sessionStorage.removeItem('access_token_expires_at');
        sessionStorage.removeItem('access_token_stored_at');
        sessionStorage.removeItem('username');
        sessionStorage.removeItem('name');
        sessionStorage.removeItem('roles');
    };
    ShellCommunicationService.ctorParameters = function () { return [
        { type: Router },
        { type: AvlAuthService }
    ]; };
    ShellCommunicationService.ɵprov = ɵɵdefineInjectable({ factory: function ShellCommunicationService_Factory() { return new ShellCommunicationService(ɵɵinject(Router), ɵɵinject(AvlAuthService)); }, token: ShellCommunicationService, providedIn: "root" });
ShellCommunicationService.ɵfac = function ShellCommunicationService_Factory(t) { return new (t || ShellCommunicationService)(ɵngcc0.ɵɵinject(ɵngcc1.Router), ɵngcc0.ɵɵinject(ɵngcc2.AvlAuthService)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ShellCommunicationService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.Router }, { type: ɵngcc2.AvlAuthService }]; }, null); })();
    return ShellCommunicationService;
}());

var TranslationManagementService = /** @class */ (function () {
    function TranslationManagementService(translateService, translationService) {
        this.translateService = translateService;
        this.translationService = translationService;
        this.languages = [
            { code: 'en', label: 'English' },
            { code: 'hr', label: 'Croatian' },
        ];
    }
    TranslationManagementService.prototype.initializeTranslations = function () {
        var _this = this;
        return function () {
            AvlLocalizationService.translationService = _this.translationService;
            var lang = localStorage.getItem('lang');
            if (lang == null) {
                lang = _this.languages[0].code;
                localStorage.setItem('lang', lang);
            }
            return _this.translateService.use(lang).toPromise();
        };
    };
    Object.defineProperty(TranslationManagementService.prototype, "language", {
        get: function () {
            return localStorage.getItem('lang');
        },
        enumerable: true,
        configurable: true
    });
    TranslationManagementService.prototype.changeLanguage = function (lang) {
        var oldLang = localStorage.getItem('lang');
        if (!oldLang || oldLang !== lang) {
            localStorage.setItem('lang', lang);
            location.reload();
        }
    };
    TranslationManagementService.ctorParameters = function () { return [
        { type: TranslateService },
        { type: NgxTranslateTranslationService }
    ]; };
    TranslationManagementService.ɵprov = ɵɵdefineInjectable({ factory: function TranslationManagementService_Factory() { return new TranslationManagementService(ɵɵinject(TranslateService), ɵɵinject(NgxTranslateTranslationService)); }, token: TranslationManagementService, providedIn: "root" });
TranslationManagementService.ɵfac = function TranslationManagementService_Factory(t) { return new (t || TranslationManagementService)(ɵngcc0.ɵɵinject(ɵngcc3.TranslateService), ɵngcc0.ɵɵinject(ɵngcc4.NgxTranslateTranslationService)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TranslationManagementService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc3.TranslateService }, { type: ɵngcc4.NgxTranslateTranslationService }]; }, null); })();
    return TranslationManagementService;
}());

var ThemeService = /** @class */ (function () {
    function ThemeService() {
        this.themeChangedSubject = new Subject();
        this.themeChanged = this.themeChangedSubject.asObservable();
        this.changeTheme();
    }
    Object.defineProperty(ThemeService.prototype, "isDarkTheme", {
        get: function () {
            if (this._isDarkTheme == null) {
                this._isDarkTheme = localStorage.getItem('theme') === 'dark' || false;
            }
            return this._isDarkTheme;
        },
        set: function (newValue) {
            this._isDarkTheme = newValue;
            localStorage.setItem('theme', newValue === true ? 'dark' : 'light');
            this.themeChangedSubject.next(this.getCurrentTheme());
            this.changeTheme();
        },
        enumerable: true,
        configurable: true
    });
    ThemeService.prototype.getCurrentTheme = function () {
        return this.isDarkTheme ? 'dark' : 'light';
    };
    ThemeService.prototype.changeTheme = function () {
        document.body.setAttribute('theme', this.getCurrentTheme());
    };
    ThemeService.ɵprov = ɵɵdefineInjectable({ factory: function ThemeService_Factory() { return new ThemeService(); }, token: ThemeService, providedIn: "root" });
ThemeService.ɵfac = function ThemeService_Factory(t) { return new (t || ThemeService)(); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ThemeService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
    return ThemeService;
}());

var ChildCommunicationService = /** @class */ (function () {
    function ChildCommunicationService(translationManagementService, themeService) {
        var _a;
        var _this = this;
        this.translationManagementService = translationManagementService;
        this.themeService = themeService;
        this.handlers = (_a = {},
            _a[MessageType.login] = function (url) { return _this.handleLogin(url); },
            _a[MessageType.navigation] = function (url) { return _this.handleNavigation(url); },
            _a[MessageType.action] = function (action) { return _this.handleAction(action); },
            _a[MessageType.registration] = function (_) { return _this.handleRegistration(); },
            _a);
        this.actionSubject = new Subject();
        this.navigationSubject = new Subject();
        this.loginSubject = new Subject();
        this.registrationCompletedSubject = new Subject();
        this.action$ = this.actionSubject;
        /**
         * Observable tracking url to navigate to
         */
        this.navigation$ = this.navigationSubject;
        /**
         * Observable tracking url for login
         * Url for login provided by child application
         */
        this.login$ = this.loginSubject;
        /**
         * Observable tracking child registration
         * Emits true if registration was successful, false otherwise
         */
        this.registrationCompleted$ = this
            .registrationCompletedSubject;
        window.addEventListener("message", function (event) { return _this.onMessage(event); });
        this.themeService.themeChanged.subscribe(function () { return _this.postThemeToChildren(); });
    }
    /**
     * Sends message to child about locale
     */
    ChildCommunicationService.prototype.notifyChildAboutLocale = function (country) {
        this.postMessageToChild(MessageType.locale, country);
    };
    /**
     * Sends message to child about language
     */
    ChildCommunicationService.prototype.notifyChildAboutLanguage = function (language) {
        this.postMessageToChild(MessageType.language, language);
    };
    /**
     * Sends message to child about action
     */
    ChildCommunicationService.prototype.notifyChildAboutAction = function (action) {
        this.postMessageToChild(MessageType.action, action);
    };
    /**
     * Sends message to child about navigation
     */
    ChildCommunicationService.prototype.notifyChildAboutNavigation = function (url) {
        this.postMessageToChild(MessageType.navigation, url);
    };
    /**
     * Sends messages to children about current user
     */
    ChildCommunicationService.prototype.postAuthenticationDataToChildren = function () {
        var payload = {
            refresh_token: sessionStorage.getItem("refresh_token"),
            access_token: sessionStorage.getItem("access_token"),
            id_token: sessionStorage.getItem("id_token"),
            refresh_token_expires_at: Number(sessionStorage.getItem("refresh_token_expires_at")),
            access_token_expires_at: Number(sessionStorage.getItem("access_token_expires_at")),
            access_token_stored_at: Number(sessionStorage.getItem("access_token_stored_at")),
            username: sessionStorage.getItem("username"),
            name: sessionStorage.getItem("name"),
            roles: JSON.parse(sessionStorage.getItem("roles")),
        };
        this.postMessageToChild(MessageType.authentication, payload);
    };
    /**
     * Sends messages to children about selected application theme
     */
    ChildCommunicationService.prototype.postThemeToChildren = function () {
        var theme = this.themeService.getCurrentTheme();
        this.postMessageToChild(MessageType.theme, theme);
    };
    /**
     * Sends messages to children about selected language
     */
    ChildCommunicationService.prototype.postLanguageToChildren = function () {
        this.postMessageToChild(MessageType.language, this.translationManagementService.language);
    };
    /**
     * Sends messages to children about selected country
     */
    ChildCommunicationService.prototype.postLocaleToChildren = function () {
        var country = localStorage.getItem("country");
        this.postMessageToChild(MessageType.locale, country);
    };
    /**
     * Sends message to child about redirection from idb
     */
    ChildCommunicationService.prototype.postRedirectedFromLogIn = function (payload) {
        this.postMessageToChild(MessageType.redirectedFromLogIn, payload);
    };
    /**
     * Sends message to children about color scheme
     */
    ChildCommunicationService.prototype.postColorSchemeToChildren = function () {
        var computedStyle = window.getComputedStyle(document.body);
        var productColor = computedStyle.getPropertyValue("--avl-product-color");
        var productHoverColor = computedStyle.getPropertyValue("--avl-product-hover-color");
        var productFocusColor = computedStyle.getPropertyValue("--avl-product-focus-color");
        var colorScheme = {
            "--avl-product-color": productColor,
            "--avl-product-hover-color": productHoverColor,
            "--avl-product-focus-color": productFocusColor,
        };
        this.postMessageToChild(MessageType.colorScheme, colorScheme);
    };
    ChildCommunicationService.prototype.handleAction = function (action) {
        this.actionSubject.next(action);
    };
    ChildCommunicationService.prototype.handleNavigation = function (navigation) {
        this.navigationSubject.next(navigation);
    };
    ChildCommunicationService.prototype.handleLogin = function (login) {
        this.loginSubject.next(login);
    };
    // when child started its registration iframe is loaded and shell gets a message that he can send messages to iframe
    ChildCommunicationService.prototype.handleRegistration = function () {
        this.iframeEl = document.getElementsByTagName("iframe")[0];
        this.postThemeToChildren();
        this.postColorSchemeToChildren();
        this.postLanguageToChildren();
        this.postLocaleToChildren();
        this.registrationCompletedSubject.next(true);
    };
    ChildCommunicationService.prototype.onMessage = function (event) {
        var _a = event.data, payload = _a.payload, messageType = _a.messageType;
        var handlers = __assign(__assign({}, this.handlers), { default: function () { return console.log("Unrecognized message for the child.", event); } });
        (handlers[messageType] || handlers.default)(payload);
    };
    ChildCommunicationService.prototype.postMessageToChild = function (messageType, payload) {
        var _a;
        if (!this.iframeEl) {
            return;
        }
        var message = { messageType: messageType, payload: payload };
        (_a = this.iframeEl.contentWindow) === null || _a === void 0 ? void 0 : _a.postMessage(message, "*");
    };
    ChildCommunicationService.ctorParameters = function () { return [
        { type: TranslationManagementService },
        { type: ThemeService }
    ]; };
    ChildCommunicationService.ɵprov = ɵɵdefineInjectable({ factory: function ChildCommunicationService_Factory() { return new ChildCommunicationService(ɵɵinject(TranslationManagementService), ɵɵinject(ThemeService)); }, token: ChildCommunicationService, providedIn: "root" });
ChildCommunicationService.ɵfac = function ChildCommunicationService_Factory(t) { return new (t || ChildCommunicationService)(ɵngcc0.ɵɵinject(TranslationManagementService), ɵngcc0.ɵɵinject(ThemeService)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChildCommunicationService, [{
        type: Injectable,
        args: [{
                providedIn: "root"
            }]
    }], function () { return [{ type: TranslationManagementService }, { type: ThemeService }]; }, null); })();
    return ChildCommunicationService;
}());

/**
 * List of all types of messages that can be logged.
 */
var LogSeverity;
(function (LogSeverity) {
    LogSeverity[LogSeverity["Debug"] = 0] = "Debug";
    LogSeverity[LogSeverity["Info"] = 1] = "Info";
    LogSeverity[LogSeverity["Warning"] = 2] = "Warning";
    LogSeverity[LogSeverity["Error"] = 3] = "Error";
    LogSeverity[LogSeverity["Fatal"] = 4] = "Fatal";
})(LogSeverity || (LogSeverity = {}));
/**
 * **LogConfig** class is required by the _LoggingModule_.
 *
 * An instance of this class should be passed into _forRoot_ method of _LoggingModule_
 * when importing module in the Angular application.
 * ```
 * import logConfig from 'logging.config.ts;
 * import LoggingModule from '@avl-services/ng-services';
 *  ....
 *  @NgModule({
 *    imports: [
 *      LoggingModule.forRoot(logConfig),
 *      ...
 *    ],
 *    ...
 *  }) export class AppModule {}
 * ```
 */
var LogConfig = /** @class */ (function () {
    /**
     * Creates instance of _LogConfig_ class.
     * @param endpoint API endpoint for logging.
     * @param targetName Name of the database in which logs will be stored
     * @param appName Name of the application that uses the logging service
     * @param version Version of the application that uses the logging service
     * @param autologging Flag that indicates whether logging starts automatically once the user logs in using credential. Default: false
     * @param globalLogLevel Minimum message severity to log. Default: LogSeverity.Info
     * @param debounceTime Time in milliseconds, determines the period of API requests for logging. Default: 30_000 ms
     * @param capacity Log queue capacity. Default: 10
     */
    function LogConfig(endpoint, targetName, appName, version, autologging, globalLogLevel, debounceTime, capacity) {
        if (autologging === void 0) { autologging = false; }
        if (globalLogLevel === void 0) { globalLogLevel = LogSeverity.Info; }
        if (debounceTime === void 0) { debounceTime = 30000; }
        if (capacity === void 0) { capacity = 10; }
        /**
         * Flag that indicates whether logging starts automatically once the user logs in using credential.
         *
         * If true, app requires _AvlAuthService_ instance in _AppModule_ providers array:
         * ```
         * { provide: AvlAuthService, useClass: AvlOidcCodeAuthService }
         * ```
         * If false, user can control logging using the service (_startLogging_, _stopLogging_ methods).
         *
         * - Optional
         * - Default: false
         */
        this.autologging = false;
        /**
         * Minimum message severity to log.
         * - Optional
         * - Default: LogSeverity.Info
         */
        this.globalLogLevel = LogSeverity.Info;
        /**
         * Time in milliseconds, determines the period of API requests for logging.
         * - Optional
         * - Default: 30_000 ms
         */
        this.debounceTime = 30000;
        /**
         * Log queue capacity
         *
         * If reached, API request is sent with all logs in log queue, and queue is cleared out.
         * - Optional
         * - Default: 10
         */
        this.capacity = 10;
        this.endpoint = endpoint;
        this.targetName = targetName;
        this.appName = appName;
        this.version = version;
        this.autologging = autologging;
        this.globalLogLevel = globalLogLevel;
        this.debounceTime = debounceTime;
        this.capacity = capacity;
    }
    return LogConfig;
}());

var LoggingService = /** @class */ (function () {
    /**
     * @ignore
     */
    function LoggingService(http, config, authService) {
        var _this = this;
        var _a;
        this.http = http;
        this.config = config;
        this.authService = authService;
        this.logs = [];
        this.isLogging = false;
        this.debounceTime$ = new Subject();
        this.logs$ = new Subject();
        this.stopLogging$ = new Subject();
        this.postLogs$ = new Subject();
        this.destroyed$ = new Subject();
        this.headers = new HttpHeaders({
            targetName: this.config.targetName,
        });
        if (config.autologging) {
            (_a = this.authService) === null || _a === void 0 ? void 0 : _a.isLoggedIn$.pipe(takeUntil(this.destroyed$)).subscribe(function (isLoggedIn) { return _this.decideOnLogging(isLoggedIn); });
        }
    }
    /**
     * @ignore
     */
    LoggingService.prototype.ngOnDestroy = function () {
        this.postLogs$.complete();
        this.debounceTime$.complete();
        this.logs$.complete();
        this.stopLogging$.next();
        this.stopLogging$.complete();
        this.destroyed$.next();
        this.destroyed$.complete();
    };
    /**
     * Starts periodical logging process.
     *
     * Depends on _debounceTime_ and _capacity_ properties.
     */
    LoggingService.prototype.startLogging = function () {
        var _this = this;
        this.isLogging = true;
        console.log('Start logging');
        this.debounceTime$
            .pipe(takeUntil(this.stopLogging$), switchMap(function (debounceTime) { return _this.periodicalLogging(debounceTime); }))
            .subscribe(function () { return _this.onPostMessages(); });
        this.postLogs$
            .pipe(takeUntil(this.stopLogging$), switchMap(function () { return _this.postMessages(); }))
            .subscribe(function () { return _this.onPostMessages(); });
        this.setLoggingDebounceTime(this.config.debounceTime);
    };
    /**
     * Stops logging process.
     */
    LoggingService.prototype.stopLogging = function () {
        this.isLogging = false;
        console.log('Stop logging');
        this.postLogs();
        this.stopLogging$.next();
    };
    /**
     * Gets all currently queued logs as an observable value.
     * @returns All currently queued logs as an observable value
     */
    LoggingService.prototype.getLogs$ = function () {
        return this.logs$.asObservable();
    };
    /**
     * Logs message with debug severity.
     * @param message Message used for constructing a debug log
     * @param componentName Name of the component which called this method
     */
    LoggingService.prototype.debug = function (message, componentName) {
        if (componentName === void 0) { componentName = ''; }
        this.log(message, LogSeverity.Debug, componentName);
    };
    /**
     * Logs message with info severity.
     * @param message Message used for constructing a info log
     * @param componentName Name of the component which called this method
     */
    LoggingService.prototype.info = function (message, componentName) {
        if (componentName === void 0) { componentName = ''; }
        this.log(message, LogSeverity.Info, componentName);
    };
    /**
     * Logs message with warning severity.
     * @param message Message used for constructing a warning log
     * @param componentName Name of the component which called this method
     */
    LoggingService.prototype.warn = function (message, componentName) {
        if (componentName === void 0) { componentName = ''; }
        this.log(message, LogSeverity.Warning, componentName);
    };
    /**
     * Logs message with error severity.
     * @param message Message used for constructing a error log
     * @param componentName Name of the component which called this method
     */
    LoggingService.prototype.error = function (message, componentName) {
        if (componentName === void 0) { componentName = ''; }
        this.log(message, LogSeverity.Error, componentName);
    };
    /**
     * Logs message with fatal severity.
     * @param message Message used for constructing a fatal log
     * @param componentName Name of the component which called this method
     */
    LoggingService.prototype.fatal = function (message, componentName) {
        if (componentName === void 0) { componentName = ''; }
        this.log(message, LogSeverity.Fatal, componentName);
    };
    /**
     * Setter for debounce time (log period).
     * @param debounceTime Time in milliseconds; determines the period of API requests for logging
     */
    LoggingService.prototype.setLoggingDebounceTime = function (debounceTime) {
        console.log('New debounce time: ', debounceTime);
        this.config.debounceTime = debounceTime;
        this.debounceTime$.next(debounceTime);
    };
    /**
     * Setter for global log level.
     * @param globalLogLevel Minimum message severity to log
     */
    LoggingService.prototype.setGlobalLogLevel = function (globalLogLevel) {
        console.log('New global log level: ', globalLogLevel);
        this.config.globalLogLevel = globalLogLevel;
    };
    /**
     * Setter for log queue capacity.
     * @param capacity Log queue capacity
     */
    LoggingService.prototype.setLogCapacity = function (capacity) {
        console.log('New capacity: ', capacity);
        this.config.capacity = capacity;
    };
    // Logic, private methods
    LoggingService.prototype.log = function (message, severity, componentName) {
        if (!this.isLogging || severity < this.config.globalLogLevel) {
            return;
        }
        this.createAndStoreLog(message, severity, componentName);
        this.dispatchLogs();
        if (this.isFullCapacity()) {
            console.log('Full capacity. Logging...');
            this.postLogs$.next();
        }
    };
    LoggingService.prototype.createAndStoreLog = function (message, severityType, componentName) {
        var timestamp = new Date().toISOString();
        var _a = this.config, appName = _a.appName, version = _a.version;
        var severity = severityType.toString();
        var log = { message: message, severity: severity, timestamp: timestamp, componentName: componentName, appName: appName, version: version };
        this.logs.push(log);
    };
    LoggingService.prototype.isFullCapacity = function () {
        return this.logs.length >= this.config.capacity;
    };
    LoggingService.prototype.clearLogs = function () {
        this.logs = [];
    };
    LoggingService.prototype.onPostMessages = function () {
        this.clearLogs();
        this.dispatchLogs();
        console.log('Logs posted.');
    };
    LoggingService.prototype.postLogs = function () {
        this.postLogs$.next();
    };
    LoggingService.prototype.periodicalLogging = function (period) {
        var _this = this;
        return interval(period).pipe(tap(function () {
            if (!_this.logs.length) {
                _this.dispatchLogs();
                console.log('Empty logs. Nothing to send.');
            }
        }), filter(function () { return !!_this.logs.length; }), tap(function () { return console.log('Time expired. Logging...'); }), switchMap(function () { return _this.postMessages(); }));
    };
    LoggingService.prototype.postMessages = function () {
        return this.http.post(this.config.endpoint, this.logs, {
            headers: this.headers,
        });
    };
    LoggingService.prototype.dispatchLogs = function () {
        this.logs$.next(this.logs);
    };
    LoggingService.prototype.decideOnLogging = function (isLoggedIn) {
        if (isLoggedIn) {
            this.startLogging();
        }
        else {
            this.stopLogging();
        }
    };
    LoggingService.ctorParameters = function () { return [
        { type: HttpClient },
        { type: LogConfig, decorators: [{ type: Inject, args: ['loggingConfig',] }] },
        { type: AvlAuthService, decorators: [{ type: Optional }, { type: Inject, args: [AvlAuthService,] }] }
    ]; };
    LoggingService.ɵprov = ɵɵdefineInjectable({ factory: function LoggingService_Factory() { return new LoggingService(ɵɵinject(HttpClient), ɵɵinject("loggingConfig"), ɵɵinject(AvlAuthService, 8)); }, token: LoggingService, providedIn: "root" });
    LoggingService = __decorate([ __param(1, Inject('loggingConfig')),
        __param(2, Optional()), __param(2, Inject(AvlAuthService))
    ], LoggingService);
LoggingService.ɵfac = function LoggingService_Factory(t) { return new (t || LoggingService)(ɵngcc0.ɵɵinject(ɵngcc5.HttpClient), ɵngcc0.ɵɵinject('loggingConfig'), ɵngcc0.ɵɵinject(AvlAuthService, 8)); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LoggingService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc5.HttpClient }, { type: LogConfig, decorators: [{
                type: Inject,
                args: ['loggingConfig']
            }] }, { type: ɵngcc2.AvlAuthService, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [AvlAuthService]
            }] }]; }, null); })();
    return LoggingService;
}());

var LoggingModule = /** @class */ (function () {
    function LoggingModule(parentModule) {
        if (parentModule) {
            throw new Error('LoggingModule is already loaded. Import it in the AppModule only');
        }
    }
    LoggingModule_1 = LoggingModule;
    LoggingModule.forRoot = function (config) {
        return {
            ngModule: LoggingModule_1,
            providers: [LoggingService, { provide: 'loggingConfig', useValue: config }],
        };
    };
    var LoggingModule_1;
    LoggingModule.ctorParameters = function () { return [
        { type: LoggingModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
    ]; };
    LoggingModule = LoggingModule_1 = __decorate([ __param(0, Optional()), __param(0, SkipSelf())
    ], LoggingModule);
LoggingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LoggingModule });
LoggingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LoggingModule_Factory(t) { return new (t || LoggingModule)(ɵngcc0.ɵɵinject(LoggingModule, 12)); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LoggingModule, [{
        type: NgModule
    }], function () { return [{ type: LoggingModule, decorators: [{
                type: Optional
            }, {
                type: SkipSelf
            }] }]; }, null); })();
    return LoggingModule;
}());

/*
 * Public API Surface of ng-services
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ChildCommunicationService, LogConfig, LogSeverity, LoggingModule, LoggingService, MessageType, ShellCommunicationService, ThemeService, TranslationManagementService };

//# sourceMappingURL=avl-services-ng-services.js.map