(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('@angular/core'), require('@angular/common/http'), require('rxjs/operators'), require('@angular/router'), require('@angular/common'), require('uuid'), require('@avl-services/vanilla-js-services/avl-localization-service/avl-localization-service.api'), require('@ngx-translate/core'), require('@microsoft/signalr')) :
    typeof define === 'function' && define.amd ? define('@avl-services/ng-services', ['exports', 'rxjs', '@angular/core', '@angular/common/http', 'rxjs/operators', '@angular/router', '@angular/common', 'uuid', '@avl-services/vanilla-js-services/avl-localization-service/avl-localization-service.api', '@ngx-translate/core', '@microsoft/signalr'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['avl-services'] = global['avl-services'] || {}, global['avl-services']['ng-services'] = {}), global.rxjs, global.ng.core, global.ng.common.http, global.rxjs.operators, global.ng.router, global.ng.common, global.uuid, null, global['@ngx-translate/core'], global.signalr));
}(this, (function (exports, rxjs, i0, i1, operators, i2, i3, uuid, avlLocalizationService_api, i1$1, signalr) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var i2__namespace = /*#__PURE__*/_interopNamespace(i2);
    var i3__namespace = /*#__PURE__*/_interopNamespace(i3);
    var i1__namespace$1 = /*#__PURE__*/_interopNamespace(i1$1);

    var AvlAuthService = /** @class */ (function () {
        function AvlAuthService() {
            /**
             * User data is held in this property
             */
            this.userSubject = new rxjs.BehaviorSubject(undefined);
            /**
             * Current user as Observable
             */
            this.user$ = this.userSubject.asObservable();
            /**
             * String holding error message in case user couldn't authenticate
             */
            this.errorMessageSubject = new rxjs.BehaviorSubject(undefined);
            /**
             * Error messsage in case failed authentication as Observable
             */
            this.errorMessage$ = this.errorMessageSubject.asObservable();
        }
        Object.defineProperty(AvlAuthService.prototype, "currentUser", {
            /**
             * Currently authenticated user data
             */
            get: function () {
                return this.userSubject.value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AvlAuthService.prototype, "errorMessage", {
            /**
             * Current error message for fail authentication
             * Undefined when user is logged in
             */
            get: function () {
                return this.errorMessageSubject.value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Use to clear error message after user is informed
         */
        AvlAuthService.prototype.clearErrorMessage = function () {
            this.errorMessageSubject.next(undefined);
        };
        return AvlAuthService;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var AUTH_CONFIG = new i0.InjectionToken(undefined);
    var INTERCEPTOR_BASE_PATHS = new i0.InjectionToken(undefined);

    var StorageNames;
    (function (StorageNames) {
        StorageNames["AccessToken"] = "access_token";
        StorageNames["AccessTokenExpiresAt"] = "access_token_expires_at";
        StorageNames["AccessTokenStoredAt"] = "access_token_stored_at";
        StorageNames["RefreshToken"] = "refresh_token";
        StorageNames["RefreshTokenExpiresAt"] = "refresh_token_expires_at";
        StorageNames["IdToken"] = "id_token";
        StorageNames["Roles"] = "roles";
        StorageNames["UserName"] = "username";
        StorageNames["Name"] = "name";
    })(StorageNames || (StorageNames = {}));

    var TokenStorage = /** @class */ (function () {
        function TokenStorage(prefix) {
            if (prefix === void 0) { prefix = ''; }
            this.prefix = '';
            this.parseJson = function (string) {
                if ((string === null || string === void 0 ? void 0 : string.indexOf('undefined')) > -1) {
                    string = string.replace('undefined', null);
                }
                try {
                    return JSON.parse(string);
                }
                catch (e) {
                    console.error(e);
                    return null;
                }
            };
            this.prefix = prefix;
        }
        TokenStorage.prototype.readUser = function () {
            var accessToken = this.getItem(StorageNames.AccessToken);
            return accessToken && accessToken != null ? {
                username: this.getItem(StorageNames.UserName),
                name: this.getItem(StorageNames.Name),
                access_token: accessToken,
                access_token_expires: this.getNumber(StorageNames.AccessTokenExpiresAt),
                access_token_stored: this.getNumber(StorageNames.AccessTokenStoredAt),
                refresh_token: this.getItem(StorageNames.RefreshToken),
                refresh_token_expires: this.getNumber(StorageNames.RefreshTokenExpiresAt),
                id_token: this.getItem(StorageNames.IdToken),
                roles: this.parseJson(this.getItem(StorageNames.Roles))
            } : null;
        };
        TokenStorage.prototype.storeUser = function (user) {
            this.setItem(StorageNames.UserName, user.username);
            this.setItem(StorageNames.Name, user.name);
            this.setItem(StorageNames.AccessToken, user.access_token);
            this.setItem(StorageNames.AccessTokenExpiresAt, "" + user.access_token_expires);
            this.setItem(StorageNames.AccessTokenStoredAt, "" + user.access_token_stored);
            this.setItem(StorageNames.RefreshToken, user.refresh_token);
            this.setItem(StorageNames.RefreshTokenExpiresAt, "" + user.refresh_token_expires);
            this.setItem(StorageNames.IdToken, user.id_token);
            if (user.roles) {
                var rolesStr = JSON.stringify(user.roles);
                sessionStorage.setItem(StorageNames.Roles, "" + rolesStr);
            }
        };
        TokenStorage.prototype.clearUser = function () {
            for (var name in StorageNames) {
                if (StorageNames.hasOwnProperty(name)) {
                    this.removeItem(StorageNames[name]);
                }
            }
        };
        TokenStorage.prototype.getNumber = function (key) {
            return parseInt(this.getItem(key), 10);
        };
        TokenStorage.prototype.getItem = function (key) {
            return sessionStorage.getItem(this.prefix + key);
        };
        TokenStorage.prototype.setItem = function (key, value) {
            sessionStorage.setItem(this.prefix + key, value);
        };
        TokenStorage.prototype.removeItem = function (key) {
            sessionStorage.removeItem(this.prefix + key);
        };
        return TokenStorage;
    }());

    var CryptoHelper = /** @class */ (function () {
        function CryptoHelper() {
        }
        // PKCE HELPER FUNCTIONS
        // Generate a secure random string using the browser crypto functions
        CryptoHelper.prototype.generateRandomString = function (length) {
            var array = new Uint8Array(length);
            window.crypto.getRandomValues(array);
            return Array.from(array, function (dec) { return ('0' + dec.toString(16)).substr(-2); }).join('');
        };
        // Base64-encodes the input string
        CryptoHelper.prototype.base64Encode = function (buffer) {
            // Convert the ArrayBuffer to string using Uint8 array to convert to what btoa accepts.
            // btoa accepts chars only within ascii 0-255 and base64 encodes them.
            return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)));
        };
        // Calculate the SHA256 hash of the input text. 
        // Returns a promise that resolves to base64 encoded string
        CryptoHelper.prototype.sha256 = function (plain) {
            return __awaiter(this, void 0, void 0, function () {
                var encoder, data, buffer;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            encoder = new TextEncoder();
                            data = encoder.encode(plain);
                            return [4 /*yield*/, window.crypto.subtle.digest('SHA-256', data)];
                        case 1:
                            buffer = _a.sent();
                            return [2 /*return*/, this.base64Encode(buffer)];
                    }
                });
            });
        };
        // Base64-decodes the input string
        CryptoHelper.prototype.base64DecodeUnicode = function (str) {
            var base64 = str.replace(/\-/g, '+').replace(/\_/g, '/');
            return decodeURIComponent(atob(base64)
                .split('')
                .map(function (c) { return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2); })
                .join(''));
        };
        return CryptoHelper;
    }());

    var LOGOUT_CONFIG_NOT_SET_ERROR = 'User signed out locally, but logout request towards OIDC server not initiated since logoutUrl is not set in authConfig.';
    var AvlOidcCodeAuthService = /** @class */ (function (_super) {
        __extends(AvlOidcCodeAuthService, _super);
        function AvlOidcCodeAuthService(httpBackend, authConfig, router, loc) {
            var _this = _super.call(this) || this;
            _this.httpBackend = httpBackend;
            _this.authConfig = authConfig;
            _this.router = router;
            _this.loc = loc;
            _this.isLoggedInSubject = new rxjs.BehaviorSubject(undefined);
            /**
             * Observable tracking authenticated state
             * Resolves to true on successful log in, false otherwise
             */
            _this.isLoggedIn$ = _this.isLoggedInSubject
                .asObservable()
                .pipe(operators.skipWhile(function (isLoggedIn) { return isLoggedIn === undefined; }));
            /**
             * Observable tracking if redirected from idb
             * Resolves to true on redirection, false otherwise
             */
            _this.redirectedFromLogIn = new rxjs.BehaviorSubject(undefined);
            _this.emitLoggedIn = function (value) {
                _this.isLoggedInSubject.next(value);
            };
            _this.http = new i1.HttpClient(_this.httpBackend);
            _this.storage = new TokenStorage(_this.authConfig.tokenPrefix);
            _this.cryptoHelper = new CryptoHelper();
            _this.userSubject.pipe(operators.skipWhile(function (value) { return value === undefined; })).subscribe(function (userValue) {
                _this.emitLoggedIn(Boolean(userValue));
            });
            var user = _this.storage.readUser();
            if (user && !_this.isUserInvalid(user)) {
                _this.persistUser(user);
            }
            else if (!_this.currentUser && _this.pkce) {
                // if user is not logged in and pkce exists handle redirect from oidc server if possible
                _this.handleOidcRedirect();
            }
            else {
                _this.clearUser();
                _this.userSubject.next(null);
            }
            _this.redirectedFromLogIn.next(Boolean(_this.currentUser));
            return _this;
        }
        /** @hidden */
        AvlOidcCodeAuthService.prototype.isUserInvalid = function (data) {
            return (!data ||
                data.username == null ||
                data.access_token == null ||
                data.access_token_expires < Date.now());
        };
        Object.defineProperty(AvlOidcCodeAuthService.prototype, "pkce", {
            get: function () {
                return this.storage.getItem('pkce') || undefined;
            },
            set: function (c) {
                if (c) {
                    this.storage.setItem('pkce', c);
                }
                else {
                    this.storage.removeItem('pkce');
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AvlOidcCodeAuthService.prototype, "nonce", {
            get: function () {
                return sessionStorage.getItem('nonce') || undefined;
            },
            set: function (c) {
                if (c) {
                    this.storage.setItem('nonce', c);
                }
                else {
                    this.storage.removeItem('nonce');
                }
            },
            enumerable: false,
            configurable: true
        });
        AvlOidcCodeAuthService.prototype.isAccessTokenValid = function () {
            return Date.now() < this.currentUser.access_token_expires;
        };
        AvlOidcCodeAuthService.prototype.persistUser = function (user) {
            if (user) {
                this.storage.storeUser(user);
                this.userSubject.next(user);
            }
            else {
                this.clearUser();
            }
        };
        AvlOidcCodeAuthService.prototype.clearUser = function () {
            this.storage.clearUser();
            this.userSubject.next(undefined);
        };
        /*
         * Checks if current url is redirect from oidc server and gets access token from the server.
         */
        AvlOidcCodeAuthService.prototype.handleOidcRedirect = function () {
            return __awaiter(this, void 0, void 0, function () {
                var pkce, urlParts, urlHash, first, last, urlPartSplit, query, queryCode, i, nonce, httpOptions, user, error_1;
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            pkce = this.pkce;
                            this.pkce = undefined;
                            urlParts = this.loc.path(true).split('?', 2);
                            if (urlParts.length === 2) {
                                first = urlParts[1].lastIndexOf('#');
                                if (first !== -1) {
                                    last = urlParts[1].lastIndexOf('&');
                                    urlHash = urlParts[1].slice(first, last);
                                    urlPartSplit = urlParts[1].split('#', 2);
                                    urlParts[1] = urlParts[1].split('&').pop();
                                    urlParts[1] = urlPartSplit[0].concat('&').concat(urlParts[1]);
                                }
                            }
                            query = urlParts.length === 2 ? this.parseQueryString(urlParts[1]) : [];
                            for (i = query.length - 1; i >= 0; i--) {
                                if (query[i].key === 'code') {
                                    queryCode = query[i].value;
                                    query = __spreadArray(__spreadArray([], __read(query.slice(0, i))), __read(query.slice(i + 1)));
                                    break;
                                }
                            }
                            if (!(urlParts.length === 2 && queryCode)) return [3 /*break*/, 4];
                            nonce = this.nonce;
                            this.nonce = undefined;
                            httpOptions = {
                                headers: new i1.HttpHeaders({
                                    code: queryCode,
                                    verifier: pkce,
                                    nonce: nonce
                                })
                            };
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.http
                                    .post(this.authConfig.tokenUrl, {}, httpOptions)
                                    .pipe(operators.map(function (token) { return _this.readUserFromToken(token); }))
                                    .toPromise()];
                        case 2:
                            user = _b.sent();
                            this.persistUser(user);
                            return [3 /*break*/, 4];
                        case 3:
                            error_1 = _b.sent();
                            this.errorMessageSubject.next(error_1.message);
                            return [3 /*break*/, 4];
                        case 4:
                            if (urlHash) {
                                this.router.navigateByUrl("" + urlParts[0] + this.reconstructQueryParamString(query) + urlHash, { replaceUrl: true });
                                this.redirectedFromLogIn.next(true);
                            }
                            else {
                                this.router.navigateByUrl("" + urlParts[0] + this.reconstructQueryParamString(query), {
                                    replaceUrl: true
                                });
                                this.redirectedFromLogIn.next(Boolean(this.currentUser));
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        AvlOidcCodeAuthService.prototype.reloadPersistedUserData = function () {
            var _a;
            var user = this.storage.readUser();
            if (((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.access_token) === (user === null || user === void 0 ? void 0 : user.access_token)) {
                return;
            }
            if (this.isUserInvalid(user)) {
                this.clearUser();
            }
            else {
                this.persistUser(user);
            }
        };
        AvlOidcCodeAuthService.prototype.reconstructQueryParamString = function (queryParams) {
            var e_1, _b;
            var s = '?';
            if (queryParams.length === 0) {
                return '';
            }
            try {
                for (var queryParams_1 = __values(queryParams), queryParams_1_1 = queryParams_1.next(); !queryParams_1_1.done; queryParams_1_1 = queryParams_1.next()) {
                    var q = queryParams_1_1.value;
                    if (s === '?') {
                        s += encodeURIComponent(q.key) + "=" + encodeURIComponent(q.value);
                    }
                    else {
                        s += "&" + encodeURIComponent(q.key) + "=" + encodeURIComponent(q.value);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (queryParams_1_1 && !queryParams_1_1.done && (_b = queryParams_1.return)) _b.call(queryParams_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return s;
        };
        AvlOidcCodeAuthService.prototype.readUserFromToken = function (token) {
            var _a;
            var accessTokenClaims = this.readClaimsFromToken(token.accesstoken);
            // Calculate actual expiry date for this machine
            var accessTokenStoredAt = Date.now(); // [ms]
            var accessTokenExpiresAt = accessTokenStoredAt + token.expiresIn * 1000;
            var refreshTokenClaims = this.readClaimsFromToken(token.refreshtoken);
            var refreshTokenExpiresAt = null;
            if (refreshTokenClaims) {
                // If time value is 0 token lasts indefinitely
                var refreshTokenExpiresIn = refreshTokenClaims['exp'] !== 0 ? refreshTokenClaims['exp'] - refreshTokenClaims['iat'] : 0;
                var refreshTokenStoredAt = accessTokenStoredAt;
                refreshTokenExpiresAt =
                    refreshTokenExpiresIn !== 0 ? refreshTokenStoredAt + refreshTokenExpiresIn * 1000 : 0;
            }
            var roles = accessTokenClaims === null || accessTokenClaims === void 0 ? void 0 : accessTokenClaims.roles;
            if (!accessTokenClaims) {
                return null;
            }
            return {
                username: accessTokenClaims.preferred_username,
                name: (_a = accessTokenClaims.name) !== null && _a !== void 0 ? _a : accessTokenClaims.preferred_username,
                access_token: token.accesstoken,
                access_token_expires: accessTokenExpiresAt,
                access_token_stored: accessTokenStoredAt,
                refresh_token: token.refreshtoken,
                refresh_token_expires: refreshTokenExpiresAt,
                id_token: token.idToken,
                roles: roles
            };
        };
        AvlOidcCodeAuthService.prototype.refreshUserIfNeeded = function () {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                var accessTokenExpired;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            accessTokenExpired = ((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.access_token_expires) < Date.now();
                            if (!accessTokenExpired) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.refreshTokens()];
                        case 1:
                            _b.sent();
                            _b.label = 2;
                        case 2: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * If needed, this method can be called to refresh tokens for current user
         * @returns Promise resolved with object containing new tokens
         */
        AvlOidcCodeAuthService.prototype.refreshTokens = function () {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                var refreshTokenValid, httpOptions, user, error_2;
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            refreshTokenValid = ((_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.refresh_token_expires) > Date.now();
                            if (!refreshTokenValid) {
                                this.logout();
                                return [2 /*return*/];
                            }
                            httpOptions = {
                                headers: new i1.HttpHeaders({
                                    grant_type: 'refresh_token',
                                    'refresh-token': this.storage.getItem(StorageNames.RefreshToken)
                                })
                            };
                            if (!this.authConfig.refreshUrl) {
                                throw new Error('refreshUrl missing in AuthConfig');
                            }
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.http
                                    .post(this.authConfig.refreshUrl, {}, httpOptions)
                                    .pipe(operators.map(function (token) { return _this.readUserFromToken(token); }))
                                    .toPromise()];
                        case 2:
                            user = _b.sent();
                            this.persistUser(user);
                            return [3 /*break*/, 4];
                        case 3:
                            error_2 = _b.sent();
                            this.errorMessageSubject.next(error_2.message);
                            throw error_2;
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Login user and redirect after successful authentication.
         * Custom auth services need to provide implementation
         * @param redirectUrl Url to redirect after successful authentication
         */
        AvlOidcCodeAuthService.prototype.login = function (redirectUrl) {
            return __awaiter(this, void 0, void 0, function () {
                var _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            _b = location;
                            return [4 /*yield*/, this.generateLoginUrl(redirectUrl || location.href)];
                        case 1:
                            _b.href = _c.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Log out user and redirect after.
         * Custom auth services need to provide implementation
         * @param redirectUrl Url to redirect after logging out
         */
        AvlOidcCodeAuthService.prototype.logout = function (redirectUrl) {
            var _this = this;
            var logoutUrl = this.authConfig.logoutUrl;
            if (!logoutUrl) {
                console.warn(LOGOUT_CONFIG_NOT_SET_ERROR);
            }
            var headers = new i1.HttpHeaders({ 'refresh-token': this.currentUser.refresh_token });
            this.http
                .post(logoutUrl, {}, { headers: headers })
                .pipe(operators.catchError(function (error) {
                _this.onLogout(redirectUrl);
                throw error;
            }))
                .subscribe(function () { return _this.onLogout(redirectUrl); });
        };
        AvlOidcCodeAuthService.prototype.onLogout = function (redirectUrl) {
            this.clearUser();
            this.redirectIfNeeded(redirectUrl);
        };
        AvlOidcCodeAuthService.prototype.redirectIfNeeded = function (redirectUrl) {
            if (redirectUrl) {
                this.navigateTo(redirectUrl);
            }
            else {
                this.reloadPage();
            }
        };
        AvlOidcCodeAuthService.prototype.reloadPage = function () {
            window.location.reload();
        };
        AvlOidcCodeAuthService.prototype.navigateTo = function (redirectUrl) {
            this.router.navigate([redirectUrl]);
        };
        AvlOidcCodeAuthService.prototype.generateLoginUrl = function (redirectUrl) {
            return __awaiter(this, void 0, void 0, function () {
                var encoder, uint8Array, redirect_b64, nonce, pkce, pkce_hash, url;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            encoder = new TextEncoder();
                            uint8Array = encoder.encode(redirectUrl);
                            redirect_b64 = this.cryptoHelper.base64Encode(uint8Array);
                            nonce = this.cryptoHelper.generateRandomString(16);
                            pkce = this.cryptoHelper.generateRandomString(32);
                            return [4 /*yield*/, this.cryptoHelper.sha256(pkce)];
                        case 1:
                            pkce_hash = _b.sent();
                            // KeyCloak requires this - https://tools.ietf.org/html/rfc7636#appendix-A
                            pkce_hash = pkce_hash.replace(/=/g, '');
                            pkce_hash = pkce_hash.replace(/\+/g, '-');
                            pkce_hash = pkce_hash.replace(/\//g, '_');
                            this.pkce = pkce;
                            this.nonce = nonce;
                            url = this.authConfig.loginUrl;
                            url += '?' + this.authConfig.loginUrlParamRedirect + '=' + encodeURIComponent(redirect_b64);
                            url += '&' + this.authConfig.loginUrlParamChallenge + '=' + encodeURIComponent(pkce_hash);
                            url += '&' + this.authConfig.loginUrlParamNonce + '=' + encodeURIComponent(nonce);
                            return [2 /*return*/, url];
                    }
                });
            });
        };
        AvlOidcCodeAuthService.prototype.readClaimsFromToken = function (token) {
            if (!token.includes('.')) {
                // Token is not a valid JWT token
                return null;
            }
            var tokenParts = token.split('.');
            var claimsString = this.cryptoHelper.base64DecodeUnicode(tokenParts[1]);
            return this.storage.parseJson(claimsString);
        };
        AvlOidcCodeAuthService.prototype.parseQueryString = function (queryString) {
            var e_2, _b;
            if (!queryString.length) {
                return [];
            }
            var queryDict = [];
            var pairs = queryString.split('&');
            try {
                for (var pairs_1 = __values(pairs), pairs_1_1 = pairs_1.next(); !pairs_1_1.done; pairs_1_1 = pairs_1.next()) {
                    var pair = pairs_1_1.value;
                    var index = pair.indexOf('=');
                    var key = void 0;
                    var value = void 0;
                    if (index === -1) {
                        key = pair;
                        value = undefined;
                    }
                    else {
                        key = pair.substr(0, index);
                        value = pair.substr(index + 1);
                    }
                    queryDict.push({
                        key: decodeURIComponent(key),
                        value: decodeURIComponent(value)
                    });
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (pairs_1_1 && !pairs_1_1.done && (_b = pairs_1.return)) _b.call(pairs_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return queryDict;
        };
        AvlOidcCodeAuthService.prototype.readUserFromSessionStorage = function () {
            return this.storage.readUser();
        };
        AvlOidcCodeAuthService.prototype.storeUserToSessionStorage = function (user) {
            this.storage.storeUser(user);
        };
        AvlOidcCodeAuthService.prototype.clearUserFromSessionStorage = function () {
            this.storage.clearUser();
        };
        return AvlOidcCodeAuthService;
    }(AvlAuthService));
    AvlOidcCodeAuthService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: AvlOidcCodeAuthService, deps: [{ token: i1__namespace.HttpBackend }, { token: AUTH_CONFIG }, { token: i2__namespace.Router }, { token: i3__namespace.Location }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AvlOidcCodeAuthService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: AvlOidcCodeAuthService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: AvlOidcCodeAuthService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: i1__namespace.HttpBackend }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [AUTH_CONFIG]
                        }] }, { type: i2__namespace.Router }, { type: i3__namespace.Location }];
        } });

    var AvlTokenInterceptor = /** @class */ (function () {
        function AvlTokenInterceptor(auth, basePaths) {
            this.auth = auth;
            this.basePaths = basePaths;
            for (var i in this.basePaths) {
                if (this.basePaths.hasOwnProperty(i)) {
                    this.basePaths[i] = this.basePaths[i].toLowerCase();
                }
            }
        }
        AvlTokenInterceptor.prototype.intercept = function (req, next) {
            var _this = this;
            if (!this.isUrlInBasePaths(req)) {
                return next.handle(req);
            }
            if (this.auth.currentUser) {
                req = this.setAuthHeader(req);
            }
            return next
                .handle(req)
                .pipe(operators.catchError(function (err) { return _this.handleHttpError(req, next, err); }));
        };
        AvlTokenInterceptor.prototype.handleHttpError = function (req, next, err) {
            var _this = this;
            if (err.status === 401) {
                // Unauthorized, tokens expired
                return rxjs.from(this.auth.refreshTokens()).pipe(operators.switchMap(function (_) { return next.handle(_this.setAuthHeader(req)); }), operators.catchError(function (_) { return rxjs.throwError(err); }));
            }
            return rxjs.throwError(err);
        };
        /** Check if request URL is in provided basePaths
         * @param request Http request instance whose URL is checked.
         */
        AvlTokenInterceptor.prototype.isUrlInBasePaths = function (request) {
            var url = request.url.toLowerCase();
            var path = this.basePaths.find(function (path) { return url.startsWith(path); });
            return Boolean(path);
        };
        /** Sets access token to authorization header of HTTP request
         * @param request HTTP request instance
         * @returns Cloned HTTP with adapted headers
         */
        AvlTokenInterceptor.prototype.setAuthHeader = function (req) {
            var access_token = this.auth.currentUser.access_token;
            var header = "Bearer " + access_token;
            var headers = req.headers.set('Authorization', header);
            return req.clone({ headers: headers });
        };
        return AvlTokenInterceptor;
    }());
    AvlTokenInterceptor.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: AvlTokenInterceptor, deps: [{ token: AvlAuthService }, { token: INTERCEPTOR_BASE_PATHS }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AvlTokenInterceptor.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: AvlTokenInterceptor });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: AvlTokenInterceptor, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: AvlAuthService }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [INTERCEPTOR_BASE_PATHS]
                        }] }];
        } });

    exports.MessageType = void 0;
    (function (MessageType) {
        MessageType["action"] = "action";
        MessageType["colorScheme"] = "colorScheme";
        MessageType["language"] = "language";
        MessageType["locale"] = "locale";
        MessageType["navigation"] = "navigation";
        MessageType["unsavedChanges"] = "unsavedChanges";
        MessageType["registration"] = "registration";
        MessageType["theme"] = "theme";
        MessageType["login"] = "login";
        MessageType["authentication"] = "authentication";
        MessageType["redirectedFromLogIn"] = "redirectedFromLogIn";
        MessageType["user"] = "user";
        MessageType["shellInfo"] = "shellInfo";
    })(exports.MessageType || (exports.MessageType = {}));

    var ShellCommunicationService = /** @class */ (function () {
        function ShellCommunicationService(router, authService) {
            var _a;
            var _this = this;
            this.router = router;
            this.authService = authService;
            this.handlers = (_a = {},
                _a[exports.MessageType.theme] = function (theme) { return _this.handleTheme(theme); },
                _a[exports.MessageType.locale] = function (locale) { return _this.handleLocale(locale); },
                _a[exports.MessageType.language] = function (language) { return _this.handleLanguage(language); },
                _a[exports.MessageType.colorScheme] = function (colorScheme) { return _this.handleColorScheme(colorScheme); },
                _a[exports.MessageType.navigation] = function (url) { return _this.handleNavigation(url); },
                _a[exports.MessageType.action] = function (action) { return _this.handleAction(action); },
                _a[exports.MessageType.authentication] = function (user) { return _this.handleAuthentication(user); },
                _a[exports.MessageType.redirectedFromLogIn] = function (redirected) { return _this.handleRedirectedFromLogIn(redirected); },
                _a[exports.MessageType.shellInfo] = function (shellInfo) { return _this.handleShellInfo(shellInfo); },
                _a);
            this.themeSubject = new rxjs.Subject();
            this.languageSubject = new rxjs.Subject();
            this.actionSubject = new rxjs.Subject();
            this.localeSubject = new rxjs.Subject();
            this.colorSchemeSubject = new rxjs.Subject();
            this.shellInfoSubject = new rxjs.Subject();
            this.shellUrl = '';
            /**
             * Observable tracking theme
             * Emits 'dark' if dark theme selected, 'light' otherwise
             */
            this.theme$ = this.themeSubject;
            /**
             * Observable tracking language
             */
            this.language$ = this.languageSubject;
            this.action$ = this.actionSubject;
            /**
             * Observable tracking locale changes
             */
            this.locale$ = this.localeSubject;
            /**
             * Observable tracking color scheme changes
             */
            this.colorScheme$ = this.colorSchemeSubject;
            /**
             * Observable tracking if redirected from idb
             * Resolves to true on redirection, false otherwise
             */
            this.redirectedFromLogIn = new rxjs.BehaviorSubject(undefined);
            /**
             * Observable tracking shell origin and list of children
             */
            this.shellInfo$ = this.shellInfoSubject;
            /**
             * If current application is inside shell application
             * True if current application is inside shell application, false otherwise.
             */
            this.isChild = window.location !== window.parent.location;
            window.addEventListener('message', function (event) { return _this.onMessage(event); });
            this.id = uuid.v4();
        }
        ShellCommunicationService.prototype.notifyShellAboutAction = function (action) {
            this.postMessageToShell(exports.MessageType.action, action);
        };
        /**
         * Sends message to shell that it needs to navigate to login page
         */
        ShellCommunicationService.prototype.notifyShellAboutLogin = function (url) {
            this.postMessageToShell(exports.MessageType.login, url);
        };
        /**
         * Sends message containing information about unsaved changes in a form to shell
         */
        ShellCommunicationService.prototype.notifyShellAboutUnsavedChanges = function (formDirty) {
            this.postMessageToShell(exports.MessageType.unsavedChanges, formDirty);
        };
        /**
         * Sends message to shell that it needs to navigate to @url
         */
        ShellCommunicationService.prototype.notifyShellAboutNavigation = function (url) {
            this.postMessageToShell(exports.MessageType.navigation, url);
        };
        /**
         * Sends registration message to shell
         */
        ShellCommunicationService.prototype.registerToShell = function () {
            this.postMessageToShell(exports.MessageType.registration, this.id);
        };
        /**
         * Send updated user data to shell
         */
        ShellCommunicationService.prototype.updateUserToShell = function () {
            var user = this.authService.readUserFromSessionStorage();
            this.postMessageToShell(exports.MessageType.user, user);
        };
        ShellCommunicationService.prototype.onMessage = function (event) {
            // if the app is used as a child in iframe, it should only accept messages
            // comming from shell using shell origin
            if (this.shellUrl && this.shellUrl != event.origin) {
                return;
            }
            var _a = event.data, payload = _a.payload, messageType = _a.messageType;
            var handlers = Object.assign(Object.assign({}, this.handlers), { default: function () { return console.log('Unrecognized message for the child.', event); } });
            (handlers[messageType] || handlers.default)(payload);
        };
        ShellCommunicationService.prototype.postMessageToShell = function (messageType, payload) {
            var message = { messageType: messageType, payload: payload };
            // send to shellUrl targetOrigin as soon it is awailable (shell must provide it after registration)
            if (this.shellUrl) {
                window.parent.window.postMessage(message, this.shellUrl);
            }
            else if (document.referrer && message.messageType === exports.MessageType.registration) {
                var url = new URL(document.referrer);
                window.parent.window.postMessage(message, url.origin);
            }
        };
        ShellCommunicationService.prototype.handleColorScheme = function (colorScheme) {
            this.colorSchemeSubject.next(colorScheme);
        };
        ShellCommunicationService.prototype.handleLanguage = function (language) {
            this.languageSubject.next(language);
        };
        ShellCommunicationService.prototype.handleLocale = function (locale) {
            this.localeSubject.next(locale);
        };
        ShellCommunicationService.prototype.handleTheme = function (theme) {
            this.themeSubject.next(theme);
        };
        ShellCommunicationService.prototype.handleNavigation = function (url) {
            this.router.navigateByUrl(url);
        };
        ShellCommunicationService.prototype.handleAction = function (action) {
            this.actionSubject.next(action);
        };
        ShellCommunicationService.prototype.handleAuthentication = function (user) {
            if (user === null || user === void 0 ? void 0 : user.access_token) {
                this.authService.storeUserToSessionStorage(user);
            }
            else {
                this.authService.clearUserFromSessionStorage();
            }
            this.authService.reloadPersistedUserData();
        };
        ShellCommunicationService.prototype.handleRedirectedFromLogIn = function (redirected) {
            this.redirectedFromLogIn.next(redirected);
        };
        ShellCommunicationService.prototype.handleShellInfo = function (shellInfo) {
            if (shellInfo) {
                this.shellUrl = new URL(shellInfo.url).origin;
            }
            this.shellInfoSubject.next(shellInfo);
            this.shellInfo = shellInfo;
        };
        return ShellCommunicationService;
    }());
    ShellCommunicationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: ShellCommunicationService, deps: [{ token: i2__namespace.Router }, { token: AvlAuthService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ShellCommunicationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: ShellCommunicationService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: ShellCommunicationService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root'
                    }]
            }], ctorParameters: function () { return [{ type: i2__namespace.Router }, { type: AvlAuthService }]; } });

    var NgxTranslateTranslationService = /** @class */ (function () {
        function NgxTranslateTranslationService(translateService) {
            this.translateService = translateService;
        }
        Object.defineProperty(NgxTranslateTranslationService.prototype, "language", {
            get: function () {
                return this.translateService.currentLang;
            },
            enumerable: false,
            configurable: true
        });
        NgxTranslateTranslationService.prototype.translate = function (key, interpolateParams) {
            return this.translateService.get(key, interpolateParams).toPromise();
        };
        return NgxTranslateTranslationService;
    }());
    NgxTranslateTranslationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: NgxTranslateTranslationService, deps: [{ token: i1__namespace$1.TranslateService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    NgxTranslateTranslationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: NgxTranslateTranslationService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: NgxTranslateTranslationService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$1.TranslateService }]; } });

    var TranslationManagementService = /** @class */ (function () {
        function TranslationManagementService(translateService, translationService) {
            this.translateService = translateService;
            this.translationService = translationService;
            this.languages = [
                { code: 'en', label: 'English' },
                { code: 'hr', label: 'Croatian' }
            ];
        }
        TranslationManagementService.prototype.initializeTranslations = function () {
            var _this = this;
            return function () {
                AvlLocalizationService.translationService = _this.translationService;
                var lang = localStorage.getItem('lang');
                if (lang == null) {
                    lang = _this.languages[0].code;
                    localStorage.setItem('lang', lang);
                }
                return _this.translateService.use(lang).toPromise();
            };
        };
        Object.defineProperty(TranslationManagementService.prototype, "language", {
            get: function () {
                return localStorage.getItem('lang');
            },
            enumerable: false,
            configurable: true
        });
        TranslationManagementService.prototype.changeLanguage = function (lang) {
            var oldLang = localStorage.getItem('lang');
            if (!oldLang || oldLang !== lang) {
                localStorage.setItem('lang', lang);
                location.reload();
            }
        };
        return TranslationManagementService;
    }());
    TranslationManagementService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: TranslationManagementService, deps: [{ token: i1__namespace$1.TranslateService }, { token: NgxTranslateTranslationService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TranslationManagementService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: TranslationManagementService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: TranslationManagementService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root'
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$1.TranslateService }, { type: NgxTranslateTranslationService }]; } });

    var ThemeService = /** @class */ (function () {
        function ThemeService() {
            this.themeChangedSubject = new rxjs.Subject();
            this.themeChanged = this.themeChangedSubject.asObservable();
            this.changeTheme();
        }
        Object.defineProperty(ThemeService.prototype, "isDarkTheme", {
            /**
             * Determines whether theme is dark or not
             */
            get: function () {
                if (this._isDarkTheme == null) {
                    this._isDarkTheme = localStorage.getItem('theme') === 'dark' || false;
                }
                return this._isDarkTheme;
            },
            /**
             * Sets the dark theme to true or false
             * @param isDark boolean that sets theme to dark if true; light if false
             */
            set: function (isDark) {
                this._isDarkTheme = isDark;
                localStorage.setItem('theme', isDark === true ? 'dark' : 'light');
                this.themeChangedSubject.next(this.getCurrentTheme());
                this.changeTheme();
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Gets current theme string
         * @returns string 'dark' or 'light'
         */
        ThemeService.prototype.getCurrentTheme = function () {
            return this.isDarkTheme ? 'dark' : 'light';
        };
        ThemeService.prototype.changeTheme = function () {
            document.body.setAttribute('theme', this.getCurrentTheme());
        };
        return ThemeService;
    }());
    ThemeService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: ThemeService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ThemeService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: ThemeService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: ThemeService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root'
                    }]
            }], ctorParameters: function () { return []; } });

    var ChildCommunicationService = /** @class */ (function () {
        function ChildCommunicationService(translationManagementService, themeService, authService) {
            var _b;
            var _this = this;
            this.translationManagementService = translationManagementService;
            this.themeService = themeService;
            this.authService = authService;
            this.handlers = (_b = {},
                _b[exports.MessageType.login] = function (url) { return _this.handleLogin(url); },
                _b[exports.MessageType.navigation] = function (url) { return _this.handleNavigation(url); },
                _b[exports.MessageType.action] = function (action) { return _this.handleAction(action); },
                _b[exports.MessageType.registration] = function (_) { return _this.handleRegistration(); },
                _b[exports.MessageType.user] = function (user) { return _this.handleUser(user); },
                _b[exports.MessageType.unsavedChanges] = function (formDirty) { return _this.handleUnsavedChanges(formDirty); },
                _b);
            this.actionSubject = new rxjs.Subject();
            this.navigationSubject = new rxjs.Subject();
            this.loginSubject = new rxjs.Subject();
            this.registrationCompletedSubject = new rxjs.Subject();
            this.unsavedChangesSubject = new rxjs.BehaviorSubject(false);
            this.action$ = this.actionSubject;
            /**
             * Observable tracking url to navigate to
             */
            this.navigation$ = this.navigationSubject;
            /**
             * Observable tracking url for login
             * Url for login provided by child application
             */
            this.login$ = this.loginSubject;
            /**
             * Observable tracking if there are unsaved changes in a form
             */
            this.unsavedChanges$ = this.unsavedChangesSubject.asObservable();
            /**
             * Observable tracking child registration
             * Emits true if registration was successful, false otherwise
             */
            this.registrationCompleted$ = this.registrationCompletedSubject;
            window.addEventListener('message', function (event) { return _this.onMessage(event); });
            this.themeService.themeChanged.subscribe(function () { return _this.postThemeToChildren(); });
        }
        /**
         * Sends the new value to the unsaved changes observer
         * @param value Value to send to the observer
         */
        ChildCommunicationService.prototype.handleUnsavedChanges = function (formDirty) {
            this.unsavedChangesSubject.next(formDirty);
        };
        /**
         * Sends message to child about locale
         */
        ChildCommunicationService.prototype.notifyChildAboutLocale = function (locale) {
            this.postMessageToChild(exports.MessageType.locale, locale);
        };
        /**
         * Sends message to child about language
         */
        ChildCommunicationService.prototype.notifyChildAboutLanguage = function (language) {
            this.postMessageToChild(exports.MessageType.language, language);
        };
        /**
         * Sends message to child about action
         */
        ChildCommunicationService.prototype.notifyChildAboutAction = function (action) {
            this.postMessageToChild(exports.MessageType.action, action);
        };
        /**
         * Sends message to child about navigation
         */
        ChildCommunicationService.prototype.notifyChildAboutNavigation = function (url) {
            this.postMessageToChild(exports.MessageType.navigation, url);
        };
        /**
         * Sends messages to children about current user
         */
        ChildCommunicationService.prototype.postAuthenticationDataToChildren = function () {
            var payload = this.authService.readUserFromSessionStorage();
            this.postMessageToChild(exports.MessageType.authentication, payload);
        };
        /**
         * Sends messages to children about selected application theme
         */
        ChildCommunicationService.prototype.postThemeToChildren = function () {
            var theme = this.themeService.getCurrentTheme();
            this.postMessageToChild(exports.MessageType.theme, theme);
        };
        /**
         * Sends messages to children about selected language
         */
        ChildCommunicationService.prototype.postLanguageToChildren = function () {
            this.postMessageToChild(exports.MessageType.language, this.translationManagementService.language);
        };
        /**
         * Sends messages to children about selected locale
         */
        ChildCommunicationService.prototype.postLocaleToChildren = function () {
            var country = localStorage.getItem('country');
            var dateTimeFormat = localStorage.getItem('dateTimeFormat');
            var decimalSeparator = localStorage.getItem('decimalSeparator');
            this.postMessageToChild(exports.MessageType.locale, {
                country: country,
                dateTimeFormat: dateTimeFormat,
                decimalSeparator: decimalSeparator
            });
        };
        /**
         * Sends message to child about redirection from idb
         */
        ChildCommunicationService.prototype.postRedirectedFromLogIn = function (payload) {
            this.postMessageToChild(exports.MessageType.redirectedFromLogIn, payload);
        };
        /**
         * Sends message to child about shell url (origin/solution/app name) and list of children
         */
        ChildCommunicationService.prototype.postShellInfoToChildren = function (payload) {
            this.postMessageToChild(exports.MessageType.shellInfo, payload);
        };
        /**
         * Sends message to children about color scheme
         */
        ChildCommunicationService.prototype.postColorSchemeToChildren = function () {
            var computedStyle = window.getComputedStyle(document.body);
            var productColor = computedStyle.getPropertyValue('--avl-product-color');
            var productHoverColor = computedStyle.getPropertyValue('--avl-product-hover-color');
            var productFocusColor = computedStyle.getPropertyValue('--avl-product-focus-color');
            var colorScheme = {
                '--avl-product-color': productColor,
                '--avl-product-hover-color': productHoverColor,
                '--avl-product-focus-color': productFocusColor
            };
            this.postMessageToChild(exports.MessageType.colorScheme, colorScheme);
        };
        ChildCommunicationService.prototype.handleAction = function (action) {
            this.actionSubject.next(action);
        };
        ChildCommunicationService.prototype.handleNavigation = function (navigation) {
            this.handleUnsavedChanges(false);
            this.navigationSubject.next(navigation);
        };
        ChildCommunicationService.prototype.handleLogin = function (login) {
            this.loginSubject.next(login);
        };
        // when child started its registration iframe is loaded and shell gets a message that he can send messages to iframe
        ChildCommunicationService.prototype.handleRegistration = function () {
            this.iframeEl = document.getElementsByTagName('iframe')[0];
            this.postThemeToChildren();
            this.postColorSchemeToChildren();
            this.postLanguageToChildren();
            this.postLocaleToChildren();
            this.registrationCompletedSubject.next(true);
        };
        ChildCommunicationService.prototype.onMessage = function (event) {
            var _b = event.data, payload = _b.payload, messageType = _b.messageType;
            if (messageType !== exports.MessageType.registration && !this.iframeEl) {
                return;
            }
            if (this.iframeEl) {
                // ignore messages that are not from iframe
                var url = new URL(this.iframeEl.src);
                if (url.origin !== event.origin) {
                    return;
                }
            }
            var handlers = Object.assign(Object.assign({}, this.handlers), { default: function () { return console.log('Unrecognized message for the shell.', event); } });
            (handlers[messageType] || handlers.default)(payload);
        };
        ChildCommunicationService.prototype.postMessageToChild = function (messageType, payload) {
            var _a;
            if (!this.iframeEl) {
                return;
            }
            var message = { messageType: messageType, payload: payload };
            var url = new URL(this.iframeEl.src);
            (_a = this.iframeEl.contentWindow) === null || _a === void 0 ? void 0 : _a.postMessage(message, url.origin);
        };
        // when child updates user data, it has to reflect in user data in shell
        ChildCommunicationService.prototype.handleUser = function (user) {
            var _a;
            if (user && (user === null || user === void 0 ? void 0 : user.access_token) !== ((_a = this.authService.currentUser) === null || _a === void 0 ? void 0 : _a.access_token)) {
                this.authService.storeUserToSessionStorage(user);
                this.authService.reloadPersistedUserData();
            }
            else if (user === null && this.authService.isUserInvalid(this.authService.currentUser)) {
                this.authService.clearUserFromSessionStorage();
                this.authService.reloadPersistedUserData();
            }
        };
        return ChildCommunicationService;
    }());
    ChildCommunicationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: ChildCommunicationService, deps: [{ token: TranslationManagementService }, { token: ThemeService }, { token: AvlAuthService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ChildCommunicationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: ChildCommunicationService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: ChildCommunicationService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root'
                    }]
            }], ctorParameters: function () { return [{ type: TranslationManagementService }, { type: ThemeService }, { type: AvlAuthService }]; } });

    /**
     * List of all types of messages that can be logged.
     */
    exports.LogSeverity = void 0;
    (function (LogSeverity) {
        LogSeverity[LogSeverity["Debug"] = 0] = "Debug";
        LogSeverity[LogSeverity["Info"] = 1] = "Info";
        LogSeverity[LogSeverity["Warning"] = 2] = "Warning";
        LogSeverity[LogSeverity["Error"] = 3] = "Error";
        LogSeverity[LogSeverity["Fatal"] = 4] = "Fatal";
    })(exports.LogSeverity || (exports.LogSeverity = {}));
    /**
     * **LogConfig** class is required by the _LoggingModule_.
     *
     * An instance of this class should be passed into _forRoot_ method of _LoggingModule_
     * when importing module in the Angular application.
     * ```
     * import logConfig from 'logging.config.ts;
     * import LoggingModule from '@avl-services/ng-services';
     *  ....
     *  @NgModule({
     *    imports: [
     *      LoggingModule.forRoot(logConfig),
     *      ...
     *    ],
     *    ...
     *  }) export class AppModule {}
     * ```
     */
    var LogConfig = /** @class */ (function () {
        /**
         * Creates instance of _LogConfig_ class.
         * @param endpoint API endpoint for logging.
         * @param targetName Name of the database in which logs will be stored
         * @param appName Name of the application that uses the logging service
         * @param version Version of the application that uses the logging service
         * @param autologging Flag that indicates whether logging starts automatically once the user logs in using credential. Default: false
         * @param globalLogLevel Minimum message severity to log. Default: LogSeverity.Info
         * @param debounceTime Time in milliseconds, determines the period of API requests for logging. Default: 30_000 ms
         * @param capacity Log queue capacity. Default: 10
         */
        function LogConfig(endpoint, targetName, appName, version, autologging, globalLogLevel, debounceTime, capacity) {
            if (autologging === void 0) { autologging = false; }
            if (globalLogLevel === void 0) { globalLogLevel = exports.LogSeverity.Info; }
            if (debounceTime === void 0) { debounceTime = 30000; }
            if (capacity === void 0) { capacity = 10; }
            /**
             * Flag that indicates whether logging starts automatically once the user logs in using credential.
             *
             * If true, app requires _AvlAuthService_ instance in _AppModule_ providers array:
             * ```
             * { provide: AvlAuthService, useClass: AvlOidcCodeAuthService }
             * ```
             * If false, user can control logging using the service (_startLogging_, _stopLogging_ methods).
             *
             * - Optional
             * - Default: false
             */
            this.autologging = false;
            /**
             * Minimum message severity to log.
             * - Optional
             * - Default: LogSeverity.Info
             */
            this.globalLogLevel = exports.LogSeverity.Info;
            /**
             * Time in milliseconds, determines the period of API requests for logging.
             * - Optional
             * - Default: 30_000 ms
             */
            this.debounceTime = 30000;
            /**
             * Log queue capacity
             *
             * If reached, API request is sent with all logs in log queue, and queue is cleared out.
             * - Optional
             * - Default: 10
             */
            this.capacity = 10;
            this.endpoint = endpoint;
            this.targetName = targetName;
            this.appName = appName;
            this.version = version;
            this.autologging = autologging;
            this.globalLogLevel = globalLogLevel;
            this.debounceTime = debounceTime;
            this.capacity = capacity;
        }
        return LogConfig;
    }());

    var LoggingService = /** @class */ (function () {
        /**
         * @ignore
         */
        function LoggingService(http, config, authService) {
            var _this = this;
            var _a;
            this.http = http;
            this.config = config;
            this.authService = authService;
            this.logs = [];
            this.isLogging = false;
            this.debounceTime$ = new rxjs.Subject();
            this.logs$ = new rxjs.Subject();
            this.stopLogging$ = new rxjs.Subject();
            this.postLogs$ = new rxjs.Subject();
            this.destroyed$ = new rxjs.Subject();
            this.headers = new i1.HttpHeaders({
                targetName: this.config.targetName,
            });
            if (config.autologging) {
                (_a = this.authService) === null || _a === void 0 ? void 0 : _a.isLoggedIn$.pipe(operators.takeUntil(this.destroyed$)).subscribe(function (isLoggedIn) { return _this.decideOnLogging(isLoggedIn); });
            }
        }
        /**
         * @ignore
         */
        LoggingService.prototype.ngOnDestroy = function () {
            this.postLogs$.complete();
            this.debounceTime$.complete();
            this.logs$.complete();
            this.stopLogging$.next();
            this.stopLogging$.complete();
            this.destroyed$.next();
            this.destroyed$.complete();
        };
        /**
         * Starts periodical logging process.
         *
         * Depends on _debounceTime_ and _capacity_ properties.
         */
        LoggingService.prototype.startLogging = function () {
            var _this = this;
            this.isLogging = true;
            this.debounceTime$
                .pipe(operators.takeUntil(this.stopLogging$), operators.switchMap(function (debounceTime) { return _this.periodicalLogging(debounceTime); }))
                .subscribe(function () { return _this.onPostMessages(); });
            this.postLogs$
                .pipe(operators.takeUntil(this.stopLogging$), operators.switchMap(function () { return _this.postMessages(); }))
                .subscribe(function () { return _this.onPostMessages(); });
            this.setLoggingDebounceTime(this.config.debounceTime);
        };
        /**
         * Stops logging process.
         */
        LoggingService.prototype.stopLogging = function () {
            this.isLogging = false;
            this.postLogs();
            this.stopLogging$.next();
        };
        /**
         * Gets all currently queued logs as an observable value.
         * @returns All currently queued logs as an observable value
         */
        LoggingService.prototype.getLogs$ = function () {
            return this.logs$.asObservable();
        };
        /**
         * Logs message with debug severity.
         * @param message Message used for constructing a debug log
         * @param componentName Name of the component which called this method
         */
        LoggingService.prototype.debug = function (message, componentName) {
            if (componentName === void 0) { componentName = ''; }
            this.log(message, exports.LogSeverity.Debug, componentName);
        };
        /**
         * Logs message with info severity.
         * @param message Message used for constructing a info log
         * @param componentName Name of the component which called this method
         */
        LoggingService.prototype.info = function (message, componentName) {
            if (componentName === void 0) { componentName = ''; }
            this.log(message, exports.LogSeverity.Info, componentName);
        };
        /**
         * Logs message with warning severity.
         * @param message Message used for constructing a warning log
         * @param componentName Name of the component which called this method
         */
        LoggingService.prototype.warn = function (message, componentName) {
            if (componentName === void 0) { componentName = ''; }
            this.log(message, exports.LogSeverity.Warning, componentName);
        };
        /**
         * Logs message with error severity.
         * @param message Message used for constructing a error log
         * @param componentName Name of the component which called this method
         */
        LoggingService.prototype.error = function (message, componentName) {
            if (componentName === void 0) { componentName = ''; }
            this.log(message, exports.LogSeverity.Error, componentName);
        };
        /**
         * Logs message with fatal severity.
         * @param message Message used for constructing a fatal log
         * @param componentName Name of the component which called this method
         */
        LoggingService.prototype.fatal = function (message, componentName) {
            if (componentName === void 0) { componentName = ''; }
            this.log(message, exports.LogSeverity.Fatal, componentName);
        };
        /**
         * Setter for debounce time (log period).
         * @param debounceTime Time in milliseconds; determines the period of API requests for logging
         */
        LoggingService.prototype.setLoggingDebounceTime = function (debounceTime) {
            this.config.debounceTime = debounceTime;
            this.debounceTime$.next(debounceTime);
        };
        /**
         * Setter for global log level.
         * @param globalLogLevel Minimum message severity to log
         */
        LoggingService.prototype.setGlobalLogLevel = function (globalLogLevel) {
            this.config.globalLogLevel = globalLogLevel;
        };
        /**
         * Setter for log queue capacity.
         * @param capacity Log queue capacity
         */
        LoggingService.prototype.setLogCapacity = function (capacity) {
            this.config.capacity = capacity;
        };
        // Logic, private methods
        LoggingService.prototype.log = function (message, severity, componentName) {
            if (!this.isLogging || severity < this.config.globalLogLevel) {
                return;
            }
            this.createAndStoreLog(message, severity, componentName);
            this.dispatchLogs();
            if (this.isFullCapacity()) {
                this.postLogs$.next();
            }
        };
        LoggingService.prototype.createAndStoreLog = function (message, severityType, componentName) {
            var timestamp = new Date().toISOString();
            var _b = this.config, appName = _b.appName, version = _b.version;
            var severity = severityType.toString();
            var log = { message: message, severity: severity, timestamp: timestamp, componentName: componentName, appName: appName, version: version };
            this.logs.push(log);
        };
        LoggingService.prototype.isFullCapacity = function () {
            return this.logs.length >= this.config.capacity;
        };
        LoggingService.prototype.clearLogs = function () {
            this.logs = [];
        };
        LoggingService.prototype.onPostMessages = function () {
            this.clearLogs();
            this.dispatchLogs();
        };
        LoggingService.prototype.postLogs = function () {
            this.postLogs$.next();
        };
        LoggingService.prototype.periodicalLogging = function (period) {
            var _this = this;
            return rxjs.interval(period).pipe(operators.tap(function () {
                if (!_this.logs.length) {
                    _this.dispatchLogs();
                }
            }), operators.filter(function () { return !!_this.logs.length; }), operators.switchMap(function () { return _this.postMessages(); }));
        };
        LoggingService.prototype.postMessages = function () {
            return this.http.post(this.config.endpoint, this.logs, {
                headers: this.headers,
            });
        };
        LoggingService.prototype.dispatchLogs = function () {
            this.logs$.next(this.logs);
        };
        LoggingService.prototype.decideOnLogging = function (isLoggedIn) {
            if (isLoggedIn) {
                this.startLogging();
            }
            else {
                this.stopLogging();
            }
        };
        return LoggingService;
    }());
    LoggingService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: LoggingService, deps: [{ token: i1__namespace.HttpClient }, { token: 'loggingConfig' }, { token: AvlAuthService, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    LoggingService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: LoggingService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: LoggingService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: i1__namespace.HttpClient }, { type: LogConfig, decorators: [{
                            type: i0.Inject,
                            args: ['loggingConfig']
                        }] }, { type: AvlAuthService, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [AvlAuthService]
                        }] }];
        } });

    var LoggingModule = /** @class */ (function () {
        function LoggingModule(parentModule) {
            if (parentModule) {
                throw new Error('LoggingModule is already loaded. Import it in the AppModule only');
            }
        }
        LoggingModule.forRoot = function (config) {
            return {
                ngModule: LoggingModule,
                providers: [LoggingService, { provide: 'loggingConfig', useValue: config }],
            };
        };
        return LoggingModule;
    }());
    LoggingModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: LoggingModule, deps: [{ token: LoggingModule, optional: true, skipSelf: true }], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    LoggingModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: LoggingModule });
    LoggingModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: LoggingModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: LoggingModule, decorators: [{
                type: i0.NgModule
            }], ctorParameters: function () {
            return [{ type: LoggingModule, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.SkipSelf
                        }] }];
        } });

    var NotificationService = /** @class */ (function () {
        function NotificationService() {
            this.hubConnections = [];
            this.notification = new rxjs.Subject();
            /**
             * Observable which emits newly arrived notifications.
             */
            this.notification$ = this.notification;
        }
        /**
         * Builds and starts signalR hub connection with the server.
         * If connection already exists and is not connected, restarts the connection.
         * @param endpoint server endpoint
         * @param options options of the connection
         */
        NotificationService.prototype.startConnection = function (endpoint, options) {
            var _this = this;
            var connection = this.getConnectionByID(options.connectionID);
            if (!connection) {
                connection = this.buildConnection(endpoint, options);
            }
            if (connection.state === signalr.HubConnectionState.Connected) {
                return;
            }
            connection
                .start()
                .then(function () { return _this.startNotifications(connection, options.metadata); })
                .catch(function () { return console.warn('Notification service: Failed to establish connection.'); });
        };
        /**
         * Stops connection with the server
         * @param connectionID connection identifier
         */
        NotificationService.prototype.stopConnection = function (connectionID) {
            var connection = this.getConnectionByID(connectionID);
            if (!connection) {
                return;
            }
            connection.off('transferNotification');
            connection.stop();
        };
        /**
         * Removes connection entirely
         * @param connectionID connection identifier
         */
        NotificationService.prototype.removeConnection = function (connectionID) {
            this.stopConnection(connectionID);
            var index = this.hubConnections.findIndex(function (connection) { return connection.id === connectionID; });
            if (index !== -1) {
                this.hubConnections.splice(index, 1);
            }
        };
        /**
         * Updates notifications metadata for specific connection. Notifies server about it.
         * @param connectionID connection identifier
         * @param metadata notification metadata, (e.g language)
         */
        NotificationService.prototype.updateNotifications = function (connectionID, metadata) {
            var connection = this.getConnectionByID(connectionID);
            if (!connection) {
                return;
            }
            this.startNotifications(connection, metadata);
        };
        // Private methods
        NotificationService.prototype.startNotifications = function (connection, metadata) {
            connection.invoke('startNotifications', metadata);
        };
        NotificationService.prototype.getConnectionByID = function (connectionID) {
            var _a;
            var index = this.hubConnections.findIndex(function (connection) { return connection.id === connectionID; });
            return (_a = this.hubConnections[index]) === null || _a === void 0 ? void 0 : _a.connection;
        };
        NotificationService.prototype.buildConnection = function (endpoint, options) {
            var _this = this;
            var hubConnection = new signalr.HubConnectionBuilder()
                .configureLogging(signalr.LogLevel.None)
                .withUrl(endpoint, { accessTokenFactory: function () { return options.accessToken; } })
                .withAutomaticReconnect()
                .build();
            hubConnection.onreconnected(function () { return _this.startNotifications(hubConnection, options.metadata); });
            hubConnection.on('transferNotification', function (notification) {
                _this.notification.next(notification);
            });
            this.hubConnections.push({
                id: options.connectionID,
                connection: hubConnection
            });
            return hubConnection;
        };
        return NotificationService;
    }());
    NotificationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: NotificationService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    NotificationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: NotificationService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: NotificationService, decorators: [{
                type: i0.Injectable
            }] });

    var UPLOAD_SERVICE = new i0.InjectionToken('UPLOAD_SERVICE');

    var UploadService = /** @class */ (function () {
        function UploadService(httpClient) {
            this.httpClient = httpClient;
        }
        UploadService.prototype.downloadFile = function (url, progressCallback, completeCallback, failCallback) {
            var req = this.httpClient.get(url, { reportProgress: true, responseType: 'blob', observe: 'events' })
                .pipe(operators.map(function (event) {
                if (event.type === i1.HttpEventType.DownloadProgress) {
                    progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback(event);
                }
                if (event.type === i1.HttpEventType.Response && event.body != null) {
                    completeCallback === null || completeCallback === void 0 ? void 0 : completeCallback(event.body);
                }
            }), operators.catchError(function (err) {
                var response = err.error instanceof Event ? err.error.target.response : err.error;
                if (failCallback) {
                    failCallback({
                        status: err.status,
                        response: response
                    });
                }
                return rxjs.of(null);
            }));
            var subscription = req.subscribe();
            return subscription.unsubscribe.bind(subscription);
        };
        UploadService.prototype.uploadFile = function (file, target, progressCallback, completeCallback, failCallback) {
            var formData = new FormData();
            formData.append('file', file.file);
            var uploadReq = this.httpClient.post(target, formData, { reportProgress: true, observe: 'events' })
                .pipe(operators.map(function (event) {
                if (event.type === i1.HttpEventType.UploadProgress) {
                    progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback(event);
                }
                if (event.type === i1.HttpEventType.Response) {
                    if (event.body != null && event.body.downloadUrl) {
                        completeCallback === null || completeCallback === void 0 ? void 0 : completeCallback(event.body.downloadUrl);
                    }
                    else {
                        completeCallback === null || completeCallback === void 0 ? void 0 : completeCallback();
                    }
                }
            }), operators.catchError(function (err, caught) {
                var response = err.error instanceof Event ? err.error.target.response : err.error;
                if (failCallback) {
                    failCallback({
                        status: err.status,
                        response: response
                    });
                }
                return rxjs.of(null);
            }));
            var subscription = uploadReq.subscribe();
            return subscription.unsubscribe.bind(subscription);
        };
        return UploadService;
    }());
    UploadService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UploadService, deps: [{ token: i1__namespace.HttpClient }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UploadService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UploadService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UploadService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace.HttpClient }]; } });

    var UnsavedChangesShellService = /** @class */ (function () {
        function UnsavedChangesShellService() {
            /**
             * Boolean value for opening and closing of the unsaved changes warning dialog
             */
            this.isDialogOpen = false;
            /**
             * Boolean value indicating if there are unsaved changes in the application
             */
            this.hasUnsavedChanges = false;
            /**
             * If current application is inside shell application
             * True if current application is inside shell application, false otherwise.
             */
            this.isChild = window.location !== window.parent.location;
            /**
             * Subject tracking if the user can navigate in application, default value is true
             */
            this.canNavigateSubject = new rxjs.BehaviorSubject(true);
            this.preventRefresh();
        }
        /**
         * Called when user clicks the 'Leave' button, allows navigation and closes the dialog
         */
        UnsavedChangesShellService.prototype.onProceed = function () {
            this.hasUnsavedChanges = false;
            this.canNavigateSubject.next(true);
            this.closeDialog();
        };
        /**
         * Called when user clicks the 'Stay' button, keeps the state, doesn't allow navigation
         * and closes the dialog
         */
        UnsavedChangesShellService.prototype.onAbort = function () {
            this.canNavigateSubject.next(false);
            this.closeDialog();
        };
        UnsavedChangesShellService.prototype.preventRefresh = function () {
            var _this = this;
            window.onbeforeunload = function (event) {
                if (_this.hasUnsavedChanges) {
                    if (_this.isChild && !_this.isDialogOpen) {
                        event.preventDefault();
                    }
                    else if (!_this.isChild) {
                        event.returnValue = true;
                    }
                }
                else {
                    event.preventDefault();
                }
            };
        };
        /**
         * Opens the unsaved changes warning dialog
         */
        UnsavedChangesShellService.prototype.openDialog = function () {
            this.isDialogOpen = true;
        };
        /**
         * Closes the unsaved changes warning dialog
         */
        UnsavedChangesShellService.prototype.closeDialog = function () {
            this.isDialogOpen = false;
        };
        return UnsavedChangesShellService;
    }());
    UnsavedChangesShellService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesShellService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UnsavedChangesShellService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesShellService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesShellService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return []; } });

    var UnsavedChangesService = /** @class */ (function (_super) {
        __extends(UnsavedChangesService, _super);
        function UnsavedChangesService(shellCommunicationService) {
            var _this = _super.call(this) || this;
            _this.shellCommunicationService = shellCommunicationService;
            /**
             * Boolean value for opening and closing of the unsaved changes warning dialog
             */
            _this.isDialogOpen = false;
            _this.formArray = [];
            return _this;
        }
        /**
         * Adds the form to the form array and notifies shell if there are any unsaved changes in forms
         * @param form Form to be registered
         */
        UnsavedChangesService.prototype.registerForm = function (form) {
            var _this = this;
            this.formArray.push(form);
            form.valueChanges.pipe(operators.debounceTime(300)).subscribe(function () {
                _super.prototype.hasUnsavedChanges = _this.isAnyFormDirty();
                _this.shellCommunicationService.notifyShellAboutUnsavedChanges(_this.isAnyFormDirty());
            });
        };
        /**
         * Removes the form from the form array and notifies shell and child
         * @hidden
         * @param form Form to be unregistered
         */
        UnsavedChangesService.prototype.unregisterForm = function (form) {
            this.formArray.splice(this.formArray.indexOf(form), 1);
            _super.prototype.hasUnsavedChanges = this.isAnyFormDirty();
            this.shellCommunicationService.notifyShellAboutUnsavedChanges(this.isAnyFormDirty());
        };
        /**
         * @hidden
         * @returns Array of forms registered to the service
         */
        UnsavedChangesService.prototype.getRegisteredForms = function () {
            return this.formArray;
        };
        /**
         * Method checking if there are unsaved changes in any of the forms
         * @returns Boolean value indicating is there a 'dirty' form
         */
        UnsavedChangesService.prototype.isAnyFormDirty = function () {
            return this.formArray.some(function (form) {
                if (!form) {
                    return false;
                }
                var formGroupValues = Object.values(form.value);
                return formGroupValues.some(function (value) { return Boolean(value); });
            });
        };
        /**
         * Updates observers, closes the unsaved changes dialog, allows the user to navigate away
         * and notifies shell
         */
        UnsavedChangesService.prototype.onProceed = function () {
            _super.prototype.onProceed.call(this);
            this.shellCommunicationService.notifyShellAboutUnsavedChanges(false);
        };
        /**
         * Updates observers, closes the unsaved changes dialog and keeps the user on the same page
         */
        UnsavedChangesService.prototype.onAbort = function () {
            _super.prototype.onAbort.call(this);
        };
        return UnsavedChangesService;
    }(UnsavedChangesShellService));
    UnsavedChangesService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesService, deps: [{ token: ShellCommunicationService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UnsavedChangesService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: ShellCommunicationService }]; } });

    var UnsavedChangesDirective = /** @class */ (function () {
        function UnsavedChangesDirective(unsavedChangesService) {
            this.unsavedChangesService = unsavedChangesService;
        }
        UnsavedChangesDirective.prototype.ngOnInit = function () {
            this.unsavedChangesService.registerForm(this.formGroup);
        };
        UnsavedChangesDirective.prototype.ngOnDestroy = function () {
            this.unsavedChangesService.unregisterForm(this.formGroup);
        };
        UnsavedChangesDirective.prototype.ngOnChanges = function (changes) {
            if (changes.formGroup.previousValue !== changes.formGroup.currentValue && changes.formGroup.firstChange === false) {
                this.unsavedChangesService.unregisterForm(this.formGroup);
                this.unsavedChangesService.registerForm(changes.formGroup.currentValue);
            }
            if (this.formGroup === undefined) {
                throw new Error("Attribute 'formGroup' is required");
            }
        };
        return UnsavedChangesDirective;
    }());
    UnsavedChangesDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesDirective, deps: [{ token: UnsavedChangesService }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    UnsavedChangesDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.3", type: UnsavedChangesDirective, selector: "form[detectUnsavedChanges]", inputs: { formGroup: "formGroup" }, usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'form[detectUnsavedChanges]'
                    }]
            }], ctorParameters: function () { return [{ type: UnsavedChangesService }]; }, propDecorators: { formGroup: [{
                    type: i0.Input
                }] } });

    var UnsavedChangesGuard = /** @class */ (function () {
        function UnsavedChangesGuard(unsavedChangesService) {
            this.unsavedChangesService = unsavedChangesService;
        }
        UnsavedChangesGuard.prototype.canDeactivate = function () {
            if (this.unsavedChangesService.isAnyFormDirty()) {
                this.unsavedChangesService.openDialog();
                return this.unsavedChangesService.canNavigateSubject.pipe(operators.skip(1));
            }
            else {
                return true;
            }
        };
        return UnsavedChangesGuard;
    }());
    UnsavedChangesGuard.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesGuard, deps: [{ token: UnsavedChangesService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    UnsavedChangesGuard.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesGuard, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesGuard, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return [{ type: UnsavedChangesService }]; } });

    var UnsavedChangesModule = /** @class */ (function () {
        function UnsavedChangesModule() {
        }
        UnsavedChangesModule.forRoot = function () {
            return {
                ngModule: UnsavedChangesModule,
                providers: [UnsavedChangesGuard, UnsavedChangesShellService, UnsavedChangesService]
            };
        };
        return UnsavedChangesModule;
    }());
    UnsavedChangesModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    UnsavedChangesModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesModule, declarations: [UnsavedChangesDirective], exports: [UnsavedChangesDirective] });
    UnsavedChangesModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.3", ngImport: i0__namespace, type: UnsavedChangesModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [UnsavedChangesDirective],
                        exports: [UnsavedChangesDirective]
                    }]
            }] });

    /*
     * Public API Surface of ng-services
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AUTH_CONFIG = AUTH_CONFIG;
    exports.AvlAuthService = AvlAuthService;
    exports.AvlOidcCodeAuthService = AvlOidcCodeAuthService;
    exports.AvlTokenInterceptor = AvlTokenInterceptor;
    exports.ChildCommunicationService = ChildCommunicationService;
    exports.INTERCEPTOR_BASE_PATHS = INTERCEPTOR_BASE_PATHS;
    exports.LogConfig = LogConfig;
    exports.LoggingModule = LoggingModule;
    exports.LoggingService = LoggingService;
    exports.NgxTranslateTranslationService = NgxTranslateTranslationService;
    exports.NotificationService = NotificationService;
    exports.ShellCommunicationService = ShellCommunicationService;
    exports.ThemeService = ThemeService;
    exports.TranslationManagementService = TranslationManagementService;
    exports.UPLOAD_SERVICE = UPLOAD_SERVICE;
    exports.UnsavedChangesDirective = UnsavedChangesDirective;
    exports.UnsavedChangesGuard = UnsavedChangesGuard;
    exports.UnsavedChangesModule = UnsavedChangesModule;
    exports.UnsavedChangesService = UnsavedChangesService;
    exports.UnsavedChangesShellService = UnsavedChangesShellService;
    exports.UploadService = UploadService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=avl-services-ng-services.umd.js.map
