(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms'), require('@avl-services/ng-services'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@avl-controls/ng-binders', ['exports', '@angular/core', '@angular/forms', '@avl-services/ng-services', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['avl-controls'] = global['avl-controls'] || {}, global['avl-controls']['ng-binders'] = {}), global.ng.core, global.ng.forms, global.ngServices, global.ng.common));
}(this, (function (exports, i0, forms, ngServices, common) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);

    var AvlBreadcrumbDirective = /** @class */ (function () {
        function AvlBreadcrumbDirective() {
            this.itemClicked = new i0.EventEmitter();
        }
        AvlBreadcrumbDirective.prototype.itemClickedListener = function (e) {
            this.itemClicked.emit(e.detail.item);
        };
        return AvlBreadcrumbDirective;
    }());
    AvlBreadcrumbDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlBreadcrumbDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlBreadcrumbDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlBreadcrumbDirective, selector: "avl-breadcrumb", outputs: { itemClicked: "itemClicked" }, host: { listeners: { "item-clicked": "itemClickedListener($event)" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlBreadcrumbDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-breadcrumb'
                    }]
            }], propDecorators: { itemClicked: [{
                    type: i0.Output
                }], itemClickedListener: [{
                    type: i0.HostListener,
                    args: ['item-clicked', ['$event']]
                }] } });

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    /**
     * Maps Polymer 'changed' events to Angular 'change' events so it can be used in 2-way binding.
     * HostListener can't be used because when a polymer control has a default value polymer will emit a changed event
     * which will overwrite the value in the bound angular variable. So the event listener is added after the constructor
     * so the default value changed event will be skipped.
     * TODO: There is still a problem if the bound variable is not set. If the default changed event is skipped the variable
     * will not get the default value so the control and the variable will have missmatching values.
     */
    function addEventListenerForEmittingChangedEvents(elementRef, polymerEventName, angularEventEmmiter) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                Promise.resolve().then(function () {
                    var nativeElement = elementRef.nativeElement;
                    return nativeElement.addEventListener(polymerEventName, function (e) {
                        angularEventEmmiter.emit(e.detail.value);
                    });
                });
                return [2 /*return*/];
            });
        });
    }

    var AvlCheckboxDirective = /** @class */ (function () {
        function AvlCheckboxDirective(elementRef) {
            this.indeterminateChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'indeterminate-changed', this.indeterminateChange);
        }
        return AvlCheckboxDirective;
    }());
    AvlCheckboxDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlCheckboxDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlCheckboxDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlCheckboxDirective, selector: "avl-checkbox", outputs: { indeterminateChange: "indeterminateChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlCheckboxDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-checkbox'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { indeterminateChange: [{
                    type: i0.Output
                }] } });

    /** Directive for controls implementing [AvlControl]. */
    var AvlControlDirective = /** @class */ (function () {
        function AvlControlDirective(elementRef) {
            this.disabledChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'disabled-changed', this.disabledChange);
        }
        return AvlControlDirective;
    }());
    AvlControlDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlControlDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlControlDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlControlDirective, selector: "avl-breadcrumb,avl-context-menu,avl-header-bar,avl-menu-button,avl-user-info", outputs: { disabledChange: "disabledChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlControlDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-breadcrumb,avl-context-menu,avl-header-bar,avl-menu-button,avl-user-info'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { disabledChange: [{
                    type: i0.Output
                }] } });

    /** Directive for controls implementing [AvlInteractionControl]. */
    var AvlInteractionControlDirective = /** @class */ (function (_super) {
        __extends(AvlInteractionControlDirective, _super);
        function AvlInteractionControlDirective(elementRef) {
            var _this = _super.call(this, elementRef) || this;
            _this.focusedChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'focused-changed', _this.focusedChange);
            return _this;
        }
        return AvlInteractionControlDirective;
    }(AvlControlDirective));
    AvlInteractionControlDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlInteractionControlDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlInteractionControlDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlInteractionControlDirective, selector: "avl-button,avl-icon-button,avl-item,avl-search-bar,avl-radio-button,avl-upload,avl-snackbar", outputs: { focusedChange: "focusedChange" }, usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlInteractionControlDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-button,avl-icon-button,avl-item,avl-search-bar,avl-radio-button,avl-upload,avl-snackbar'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { focusedChange: [{
                    type: i0.Output
                }] } });

    var AvlComboBoxDirective = /** @class */ (function (_super) {
        __extends(AvlComboBoxDirective, _super);
        function AvlComboBoxDirective(elementRef, renderer) {
            var _this = _super.call(this, elementRef) || this;
            _this.elementRef = elementRef;
            _this.renderer = renderer;
            _this.invalidChange = new i0.EventEmitter();
            _this.valueChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'invalid-changed', _this.focusedChange);
            addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', _this.valueChange);
            return _this;
        }
        Object.defineProperty(AvlComboBoxDirective.prototype, "readonly", {
            // Angular writes readonly attributes to a readOnly property,
            // because that's how it's called on the native input element.
            set: function (value) {
                this.elementRef.nativeElement.readonly = value;
            },
            enumerable: false,
            configurable: true
        });
        AvlComboBoxDirective.prototype.valueChanged = function (e) {
            if (this.onChangeCallback && this.isAllowNewValues()) {
                this.onChangeCallback(e.detail.value);
            }
        };
        AvlComboBoxDirective.prototype.selectedValueChanged = function (e) {
            if (this.onChangeCallback && !this.isAllowNewValues()) {
                this.onChangeCallback(e.detail.value);
            }
        };
        AvlComboBoxDirective.prototype.writeValue = function (value) {
            var property = this.isAllowNewValues() ? 'value' : 'selectedValue';
            this.renderer.setProperty(this.elementRef.nativeElement, property, value);
        };
        AvlComboBoxDirective.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        // Since avl-combo-box doesn't have validate-on-leave, there's no touching
        AvlComboBoxDirective.prototype.registerOnTouched = function (fn) { };
        AvlComboBoxDirective.prototype.setDisabledState = function (isDisabled) {
            this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
        };
        AvlComboBoxDirective.prototype.isAllowNewValues = function () {
            return (this.elementRef.nativeElement && this.elementRef.nativeElement.allowNewValues === true);
        };
        //#region Validator
        AvlComboBoxDirective.prototype.validate = function (control) {
            var formControl = this.elementRef.nativeElement;
            if (formControl.invalid) {
                return { invalid: formControl.errorMessage };
            }
            else {
                return null;
            }
        };
        return AvlComboBoxDirective;
    }(AvlInteractionControlDirective));
    AvlComboBoxDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlComboBoxDirective, deps: [{ token: i0__namespace.ElementRef }, { token: i0__namespace.Renderer2 }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlComboBoxDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlComboBoxDirective, selector: "avl-combo-box", inputs: { readonly: "readonly" }, outputs: { invalidChange: "invalidChange", valueChange: "valueChange" }, host: { listeners: { "value-changed": "valueChanged($event)", "selected-value-changed": "selectedValueChanged($event)" } }, providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AvlComboBoxDirective; }), multi: true },
            { provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AvlComboBoxDirective; }), multi: true }], usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlComboBoxDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-combo-box',
                        providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AvlComboBoxDirective; }), multi: true },
                            { provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AvlComboBoxDirective; }), multi: true }]
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.Renderer2 }]; }, propDecorators: { invalidChange: [{
                    type: i0.Output
                }], valueChange: [{
                    type: i0.Output
                }], readonly: [{
                    type: i0.Input
                }], valueChanged: [{
                    type: i0.HostListener,
                    args: ['value-changed', ['$event']]
                }], selectedValueChanged: [{
                    type: i0.HostListener,
                    args: ['selected-value-changed', ['$event']]
                }] } });

    var AvlOverflowMenuDirective = /** @class */ (function () {
        function AvlOverflowMenuDirective(elementRef) {
            this.itemClicked = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'item-clicked', this.itemClicked);
        }
        return AvlOverflowMenuDirective;
    }());
    AvlOverflowMenuDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlOverflowMenuDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlOverflowMenuDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlOverflowMenuDirective, selector: "avl-overflow-menu", outputs: { itemClicked: "itemClicked" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlOverflowMenuDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-overflow-menu'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { itemClicked: [{
                    type: i0.Output
                }] } });

    var AvlSearchBarDirective = /** @class */ (function () {
        function AvlSearchBarDirective(elementRef) {
            this.queryChange = new i0.EventEmitter();
            this.openChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'query-changed', this.queryChange);
            addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChange);
        }
        return AvlSearchBarDirective;
    }());
    AvlSearchBarDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlSearchBarDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlSearchBarDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlSearchBarDirective, selector: "avl-search-bar", outputs: { queryChange: "queryChange", openChange: "openChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlSearchBarDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-search-bar'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { queryChange: [{
                    type: i0.Output
                }], openChange: [{
                    type: i0.Output
                }] } });

    var AvlTextareaDirective = /** @class */ (function () {
        function AvlTextareaDirective(elementRef) {
            this.valueChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
        }
        return AvlTextareaDirective;
    }());
    AvlTextareaDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlTextareaDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlTextareaDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlTextareaDirective, selector: "avl-textarea", outputs: { valueChange: "valueChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlTextareaDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-textarea'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { valueChange: [{
                    type: i0.Output
                }] } });

    var AvlDateDirective = /** @class */ (function () {
        function AvlDateDirective(elementRef) {
            this.valueChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
        }
        return AvlDateDirective;
    }());
    AvlDateDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlDateDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlDateDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlDateDirective, selector: "avl-date", outputs: { valueChange: "valueChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlDateDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-date'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { valueChange: [{
                    type: i0.Output
                }] } });

    var AvlSideSheetDirective = /** @class */ (function () {
        function AvlSideSheetDirective(elementRef) {
            this.openChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChange);
        }
        return AvlSideSheetDirective;
    }());
    AvlSideSheetDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlSideSheetDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlSideSheetDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlSideSheetDirective, selector: "avl-side-sheet", outputs: { openChange: "openChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlSideSheetDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-side-sheet'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { openChange: [{
                    type: i0.Output
                }] } });

    var AvlTextfieldDirective = /** @class */ (function () {
        function AvlTextfieldDirective(elementRef) {
            this.valueChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
        }
        return AvlTextfieldDirective;
    }());
    AvlTextfieldDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlTextfieldDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlTextfieldDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlTextfieldDirective, selector: "avl-textfield", outputs: { valueChange: "valueChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlTextfieldDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-textfield'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { valueChange: [{
                    type: i0.Output
                }] } });

    var AvlTimespanDirective = /** @class */ (function () {
        function AvlTimespanDirective(elementRef) {
            this.valueChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
        }
        return AvlTimespanDirective;
    }());
    AvlTimespanDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlTimespanDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlTimespanDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlTimespanDirective, selector: "avl-timespan", outputs: { valueChange: "valueChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlTimespanDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-timespan'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { valueChange: [{
                    type: i0.Output
                }] } });

    var AvlUploadDirective = /** @class */ (function () {
        function AvlUploadDirective(element, uploadService) {
            this.element = element;
            this.uploadService = uploadService;
            this.uploadComplete = new i0.EventEmitter();
            this.uploadAbort = new i0.EventEmitter();
            this.uploadFail = new i0.EventEmitter();
            this.uploadStart = new i0.EventEmitter();
            this.filesChanged = new i0.EventEmitter();
            this.fileRejected = new i0.EventEmitter();
            this.menuItemClicked = new i0.EventEmitter();
            this.downloadFail = new i0.EventEmitter();
            this.downloadAbort = new i0.EventEmitter();
        }
        AvlUploadDirective.prototype.ngOnInit = function () {
            var element = this.element.nativeElement;
            element.uploadService = this.uploadService;
        };
        AvlUploadDirective.prototype.uploadCompleteHandler = function (e) {
            this.uploadComplete.emit(e.detail.value);
        };
        AvlUploadDirective.prototype.uploadCanceledHandler = function (e) {
            this.uploadAbort.emit(e.detail.value);
        };
        AvlUploadDirective.prototype.uploadStartedHandler = function (e) {
            this.uploadStart.emit(e.detail.value);
        };
        AvlUploadDirective.prototype.uploadFailedHandler = function (e) {
            this.uploadFail.emit(e.detail);
        };
        AvlUploadDirective.prototype.filesChangedHandler = function (e) {
            this.filesChanged.emit(e.detail.value);
        };
        AvlUploadDirective.prototype.fileRejectedHandler = function (e) {
            this.fileRejected.emit(e.detail.value);
        };
        AvlUploadDirective.prototype.menuItemClickedHandler = function (e) {
            this.menuItemClicked.emit(e.detail);
        };
        AvlUploadDirective.prototype.downloadFailedHandler = function (e) {
            this.downloadFail.emit(e.detail);
        };
        AvlUploadDirective.prototype.downloadCanceledHandler = function (e) {
            this.downloadAbort.emit(e.detail.value);
        };
        return AvlUploadDirective;
    }());
    AvlUploadDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlUploadDirective, deps: [{ token: i0__namespace.ElementRef }, { token: ngServices.UPLOAD_SERVICE }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlUploadDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlUploadDirective, selector: "avl-upload", outputs: { uploadComplete: "uploadComplete", uploadAbort: "uploadAbort", uploadFail: "uploadFail", uploadStart: "uploadStart", filesChanged: "filesChanged", fileRejected: "fileRejected", menuItemClicked: "menuItemClicked", downloadFail: "downloadFail", downloadAbort: "downloadAbort" }, host: { listeners: { "upload-complete": "uploadCompleteHandler($event)", "upload-abort": "uploadCanceledHandler($event)", "upload-start": "uploadStartedHandler($event)", "upload-fail": "uploadFailedHandler($event)", "files-changed": "filesChangedHandler($event)", "file-rejected": "fileRejectedHandler($event)", "menu-item-clicked": "menuItemClickedHandler($event)", "download-fail": "downloadFailedHandler($event)", "download-abort": "downloadCanceledHandler($event)" } }, providers: [{ provide: ngServices.UPLOAD_SERVICE, useClass: ngServices.UploadService }], ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlUploadDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-upload',
                        providers: [{ provide: ngServices.UPLOAD_SERVICE, useClass: ngServices.UploadService }]
                    }]
            }], ctorParameters: function () {
            return [{ type: i0__namespace.ElementRef }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [ngServices.UPLOAD_SERVICE]
                        }] }];
        }, propDecorators: { uploadComplete: [{
                    type: i0.Output
                }], uploadAbort: [{
                    type: i0.Output
                }], uploadFail: [{
                    type: i0.Output
                }], uploadStart: [{
                    type: i0.Output
                }], filesChanged: [{
                    type: i0.Output
                }], fileRejected: [{
                    type: i0.Output
                }], menuItemClicked: [{
                    type: i0.Output
                }], downloadFail: [{
                    type: i0.Output
                }], downloadAbort: [{
                    type: i0.Output
                }], uploadCompleteHandler: [{
                    type: i0.HostListener,
                    args: ['upload-complete', ['$event']]
                }], uploadCanceledHandler: [{
                    type: i0.HostListener,
                    args: ['upload-abort', ['$event']]
                }], uploadStartedHandler: [{
                    type: i0.HostListener,
                    args: ['upload-start', ['$event']]
                }], uploadFailedHandler: [{
                    type: i0.HostListener,
                    args: ['upload-fail', ['$event']]
                }], filesChangedHandler: [{
                    type: i0.HostListener,
                    args: ['files-changed', ['$event']]
                }], fileRejectedHandler: [{
                    type: i0.HostListener,
                    args: ['file-rejected', ['$event']]
                }], menuItemClickedHandler: [{
                    type: i0.HostListener,
                    args: ['menu-item-clicked', ['$event']]
                }], downloadFailedHandler: [{
                    type: i0.HostListener,
                    args: ['download-fail', ['$event']]
                }], downloadCanceledHandler: [{
                    type: i0.HostListener,
                    args: ['download-abort', ['$event']]
                }] } });

    var AvlTabBarDirective = /** @class */ (function () {
        function AvlTabBarDirective(el) {
            var _this = this;
            this.el = el;
            this.selectedIndexChange = new i0.EventEmitter();
            this.selectedValueChange = new i0.EventEmitter();
            this.tabBar = this.el.nativeElement;
            Promise.resolve().then(function () {
                _this.setEventListeners(el.nativeElement);
            });
        }
        AvlTabBarDirective.prototype.setEventListeners = function (el) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    el.addEventListener('selected-value-changed', function (event) {
                        Promise.resolve().then(function () {
                            _this.selectedValueChange.emit(event.detail.value);
                        });
                    });
                    el.addEventListener('selected-index-changed', function (event) {
                        Promise.resolve().then(function () {
                            _this.selectedIndexChange.emit(event.detail.value);
                        });
                    });
                    return [2 /*return*/];
                });
            });
        };
        AvlTabBarDirective.prototype.setTab = function (index, value) {
            var tabs = this.tabBar.tabs;
            for (var prop in value) {
                if (value.hasOwnProperty(prop)) {
                    tabs[index][prop] = value[prop];
                    this.tabBar.notifyPath("tabs." + index + "." + prop);
                }
            }
        };
        return AvlTabBarDirective;
    }());
    AvlTabBarDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlTabBarDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlTabBarDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlTabBarDirective, selector: "avl-tab-bar", outputs: { selectedIndexChange: "selectedIndexChange", selectedValueChange: "selectedValueChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlTabBarDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-tab-bar',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { selectedIndexChange: [{
                    type: i0.Output
                }], selectedValueChange: [{
                    type: i0.Output
                }] } });

    var AvlDropdownDirective = /** @class */ (function () {
        function AvlDropdownDirective(elementRef) {
            this.openChanged = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChanged);
        }
        return AvlDropdownDirective;
    }());
    AvlDropdownDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlDropdownDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlDropdownDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlDropdownDirective, selector: "avl-dropdown", outputs: { openChanged: "openChanged" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlDropdownDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-dropdown'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { openChanged: [{
                    type: i0.Output
                }] } });

    var AvlTimeDirective = /** @class */ (function () {
        function AvlTimeDirective(elementRef) {
            this.valueChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
        }
        return AvlTimeDirective;
    }());
    AvlTimeDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlTimeDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlTimeDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlTimeDirective, selector: "avl-time", outputs: { valueChange: "valueChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlTimeDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-time'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { valueChange: [{
                    type: i0.Output
                }] } });

    var AvlListDirective = /** @class */ (function (_super) {
        __extends(AvlListDirective, _super);
        function AvlListDirective(elementRef, renderer) {
            var _this = _super.call(this, elementRef) || this;
            _this.elementRef = elementRef;
            _this.renderer = renderer;
            _this.invalidChange = new i0.EventEmitter();
            _this.overflowMenuItemClicked = new i0.EventEmitter();
            _this.rightCheckboxChanged = new i0.EventEmitter();
            _this.activeRowChanged = new i0.EventEmitter();
            _this.rowReordered = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'invalid-changed', _this.focusedChange);
            return _this;
        }
        Object.defineProperty(AvlListDirective.prototype, "readonly", {
            // Angular writes readonly attributes to a readOnly property,
            // because that's how it's called on the native input element.
            set: function (value) {
                this.elementRef.nativeElement.readonly = value;
            },
            enumerable: false,
            configurable: true
        });
        AvlListDirective.prototype.selectedValueChanged = function (e) {
            if (this.onChangeCallback && !this.isMulti()) {
                this.onChangeCallback(e.detail.value);
            }
        };
        AvlListDirective.prototype.selectedValuesChanged = function (e) {
            if (this.onChangeCallback && this.isMulti()) {
                this.onChangeCallback(e.detail.value);
            }
        };
        AvlListDirective.prototype.overflowMenuItemClickListener = function (e) {
            this.overflowMenuItemClicked.emit(e.detail);
        };
        AvlListDirective.prototype.rightCheckboxChangeListener = function (e) {
            this.rightCheckboxChanged.emit(e.detail);
        };
        AvlListDirective.prototype.activatedRowChangeListener = function (e) {
            this.activeRowChanged.emit(e.detail.value);
        };
        AvlListDirective.prototype.rowReorderedListener = function (e) {
            this.rowReordered.emit(e.detail);
        };
        AvlListDirective.prototype.writeValue = function (value) {
            var property = this.isMulti() ? 'selectedValues' : 'selectedValue';
            this.renderer.setProperty(this.elementRef.nativeElement, property, value);
        };
        AvlListDirective.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        // Since avl-list doesn't have validate-on-leave, there's no touching
        AvlListDirective.prototype.registerOnTouched = function (fn) { };
        AvlListDirective.prototype.setDisabledState = function (isDisabled) {
            this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
        };
        AvlListDirective.prototype.isMulti = function () {
            return (this.elementRef.nativeElement && this.elementRef.nativeElement.multi === true);
        };
        //#region Validator
        AvlListDirective.prototype.validate = function (control) {
            var formControl = this.elementRef.nativeElement;
            if (formControl.invalid) {
                return { invalid: formControl.errorMessage };
            }
            else {
                return null;
            }
        };
        return AvlListDirective;
    }(AvlInteractionControlDirective));
    AvlListDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlListDirective, deps: [{ token: i0__namespace.ElementRef }, { token: i0__namespace.Renderer2 }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlListDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlListDirective, selector: "avl-list", inputs: { readonly: "readonly" }, outputs: { invalidChange: "invalidChange", overflowMenuItemClicked: "overflowMenuItemClicked", rightCheckboxChanged: "rightCheckboxChanged", activeRowChanged: "activeRowChanged", rowReordered: "rowReordered" }, host: { listeners: { "selected-value-changed": "selectedValueChanged($event)", "selected-values-changed": "selectedValuesChanged($event)", "overflow-menu-item-clicked": "overflowMenuItemClickListener($event)", "right-checkbox-changed": "rightCheckboxChangeListener($event)", "active-row-changed": "activatedRowChangeListener($event)", "row-reordered": "rowReorderedListener($event)" } }, providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AvlListDirective; }), multi: true },
            { provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AvlListDirective; }), multi: true }], usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlListDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-list',
                        providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AvlListDirective; }), multi: true },
                            { provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AvlListDirective; }), multi: true }]
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.Renderer2 }]; }, propDecorators: { invalidChange: [{
                    type: i0.Output
                }], overflowMenuItemClicked: [{
                    type: i0.Output
                }], rightCheckboxChanged: [{
                    type: i0.Output
                }], activeRowChanged: [{
                    type: i0.Output
                }], rowReordered: [{
                    type: i0.Output
                }], readonly: [{
                    type: i0.Input
                }], selectedValueChanged: [{
                    type: i0.HostListener,
                    args: ['selected-value-changed', ['$event']]
                }], selectedValuesChanged: [{
                    type: i0.HostListener,
                    args: ['selected-values-changed', ['$event']]
                }], overflowMenuItemClickListener: [{
                    type: i0.HostListener,
                    args: ['overflow-menu-item-clicked', ['$event']]
                }], rightCheckboxChangeListener: [{
                    type: i0.HostListener,
                    args: ['right-checkbox-changed', ['$event']]
                }], activatedRowChangeListener: [{
                    type: i0.HostListener,
                    args: ['active-row-changed', ['$event']]
                }], rowReorderedListener: [{
                    type: i0.HostListener,
                    args: ['row-reordered', ['$event']]
                }] } });

    var AvlContextMenuDirective = /** @class */ (function () {
        function AvlContextMenuDirective() {
            this.itemClicked = new i0.EventEmitter();
        }
        AvlContextMenuDirective.prototype.itemClickedListener = function (e) {
            this.itemClicked.emit(e.detail.value);
        };
        return AvlContextMenuDirective;
    }());
    AvlContextMenuDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlContextMenuDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlContextMenuDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlContextMenuDirective, selector: "avl-context-menu", outputs: { itemClicked: "itemClicked" }, host: { listeners: { "item-clicked": "itemClickedListener($event)" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlContextMenuDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-context-menu'
                    }]
            }], propDecorators: { itemClicked: [{
                    type: i0.Output
                }], itemClickedListener: [{
                    type: i0.HostListener,
                    args: ['item-clicked', ['$event']]
                }] } });

    var AvlNumberfieldDirective = /** @class */ (function () {
        function AvlNumberfieldDirective(elementRef) {
            this.valueChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
        }
        return AvlNumberfieldDirective;
    }());
    AvlNumberfieldDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlNumberfieldDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlNumberfieldDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlNumberfieldDirective, selector: "avl-numberfield", outputs: { valueChange: "valueChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlNumberfieldDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-numberfield'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { valueChange: [{
                    type: i0.Output
                }] } });

    var AvlIconButtonDirective = /** @class */ (function () {
        function AvlIconButtonDirective(elementRef) {
            this.badgeChange = new i0.EventEmitter();
            this.badgeValueChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'badge-changed', this.badgeChange);
            addEventListenerForEmittingChangedEvents(elementRef, 'badge-value-changed', this.badgeValueChange);
        }
        return AvlIconButtonDirective;
    }());
    AvlIconButtonDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlIconButtonDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlIconButtonDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlIconButtonDirective, selector: "avl-icon-button", outputs: { badgeChange: "badgeChange", badgeValueChange: "badgeValueChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlIconButtonDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-icon-button'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { badgeChange: [{
                    type: i0.Output
                }], badgeValueChange: [{
                    type: i0.Output
                }] } });

    var AvlDatatableDirective = /** @class */ (function () {
        function AvlDatatableDirective(elementRef) {
            this.buttonClick = new i0.EventEmitter();
            this.overflowMenuItemClick = new i0.EventEmitter();
            this.linkClick = new i0.EventEmitter();
            this.pageSizeChange = new i0.EventEmitter();
            this.selectedPageChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'page-size-changed', this.pageSizeChange);
            addEventListenerForEmittingChangedEvents(elementRef, 'selected-page-changed', this.selectedPageChange);
        }
        AvlDatatableDirective.prototype.buttonClickListener = function (e) {
            this.buttonClick.emit(e.detail);
        };
        AvlDatatableDirective.prototype.overflowMenuItemClickListener = function (e) {
            this.overflowMenuItemClick.emit(e.detail);
        };
        AvlDatatableDirective.prototype.linkClickListener = function (e) {
            this.linkClick.emit(e.detail);
        };
        return AvlDatatableDirective;
    }());
    AvlDatatableDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlDatatableDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlDatatableDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlDatatableDirective, selector: "avl-datatable", outputs: { buttonClick: "buttonClick", overflowMenuItemClick: "overflowMenuItemClick", linkClick: "linkClick", pageSizeChange: "pageSizeChange", selectedPageChange: "selectedPageChange" }, host: { listeners: { "button-click": "buttonClickListener($event)", "overflow-menu-item-click": "overflowMenuItemClickListener($event)", "link-click": "linkClickListener($event)" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlDatatableDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-datatable'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { buttonClick: [{
                    type: i0.Output
                }], overflowMenuItemClick: [{
                    type: i0.Output
                }], linkClick: [{
                    type: i0.Output
                }], pageSizeChange: [{
                    type: i0.Output
                }], selectedPageChange: [{
                    type: i0.Output
                }], buttonClickListener: [{
                    type: i0.HostListener,
                    args: ['button-click', ['$event']]
                }], overflowMenuItemClickListener: [{
                    type: i0.HostListener,
                    args: ['overflow-menu-item-click', ['$event']]
                }], linkClickListener: [{
                    type: i0.HostListener,
                    args: ['link-click', ['$event']]
                }] } });

    var AvlSnackbarDirective = /** @class */ (function () {
        function AvlSnackbarDirective() {
            this.buttonClicked = new i0.EventEmitter();
            this.displayedChange = new i0.EventEmitter();
        }
        AvlSnackbarDirective.prototype.buttonClickedHandler = function (e) {
            this.buttonClicked.emit(e.detail.value);
        };
        AvlSnackbarDirective.prototype.displayedChangeHandler = function (e) {
            this.displayedChange.emit(e.detail.value);
        };
        return AvlSnackbarDirective;
    }());
    AvlSnackbarDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlSnackbarDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlSnackbarDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlSnackbarDirective, selector: "avl-snackbar", outputs: { buttonClicked: "buttonClicked", displayedChange: "displayedChange" }, host: { listeners: { "button-clicked": "buttonClickedHandler($event)", "displayed-changed": "displayedChangeHandler($event)" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlSnackbarDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-snackbar'
                    }]
            }], propDecorators: { buttonClicked: [{
                    type: i0.Output
                }], displayedChange: [{
                    type: i0.Output
                }], buttonClickedHandler: [{
                    type: i0.HostListener,
                    args: ['button-clicked', ['$event']]
                }], displayedChangeHandler: [{
                    type: i0.HostListener,
                    args: ['displayed-changed', ['$event']]
                }] } });

    var AvlStepProgressDirective = /** @class */ (function () {
        function AvlStepProgressDirective(elementRef) {
            this.activeChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'active-changed', this.activeChange);
        }
        return AvlStepProgressDirective;
    }());
    AvlStepProgressDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlStepProgressDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlStepProgressDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlStepProgressDirective, selector: "avl-step-progress", outputs: { activeChange: "activeChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlStepProgressDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-step-progress'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { activeChange: [{
                    type: i0.Output
                }] } });

    /** Directive for controls implementing [AvlCheckableControl]. */
    var AvlCheckableControlDirective = /** @class */ (function () {
        function AvlCheckableControlDirective(elementRef) {
            this.checkedChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'checked-changed', this.checkedChange);
        }
        return AvlCheckableControlDirective;
    }());
    AvlCheckableControlDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlCheckableControlDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlCheckableControlDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlCheckableControlDirective, selector: "avl-checkbox,avl-radio-button, avl-icon-toggle, avl-switch", outputs: { checkedChange: "checkedChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlCheckableControlDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-checkbox,avl-radio-button, avl-icon-toggle, avl-switch'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { checkedChange: [{
                    type: i0.Output
                }] } });

    /** Directive for controls implementing [AvlMultiSelectControl]. */
    var AvlMultiSelectControlDirective = /** @class */ (function () {
        function AvlMultiSelectControlDirective(elementRef) {
            this.selectedIndexesChange = new i0.EventEmitter();
            this.selectedValuesChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'selected-indexes-changed', this.selectedIndexesChange);
            addEventListenerForEmittingChangedEvents(elementRef, 'selected-values-changed', this.selectedValuesChange);
        }
        return AvlMultiSelectControlDirective;
    }());
    AvlMultiSelectControlDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlMultiSelectControlDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlMultiSelectControlDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlMultiSelectControlDirective, selector: "avl-datatable,avl-list,avl-chip-list, avl-chip-input", outputs: { selectedIndexesChange: "selectedIndexesChange", selectedValuesChange: "selectedValuesChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlMultiSelectControlDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-datatable,avl-list,avl-chip-list, avl-chip-input'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { selectedIndexesChange: [{
                    type: i0.Output
                }], selectedValuesChange: [{
                    type: i0.Output
                }] } });

    /** Directive for controls implementing [AvlSingleSelectControl]. */
    var AvlSingleSelectControlDirective = /** @class */ (function () {
        function AvlSingleSelectControlDirective(elementRef) {
            this.selectedIndexChange = new i0.EventEmitter();
            this.selectedValueChange = new i0.EventEmitter();
            addEventListenerForEmittingChangedEvents(elementRef, 'selected-index-changed', this.selectedIndexChange);
            addEventListenerForEmittingChangedEvents(elementRef, 'selected-value-changed', this.selectedValueChange);
        }
        return AvlSingleSelectControlDirective;
    }());
    AvlSingleSelectControlDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlSingleSelectControlDirective, deps: [{ token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlSingleSelectControlDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlSingleSelectControlDirective, selector: "avl-datatable,avl-dropdown,avl-list,avl-radio-group,avl-app-switcher,avl-chip-list,avl-combo-box", outputs: { selectedIndexChange: "selectedIndexChange", selectedValueChange: "selectedValueChange" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlSingleSelectControlDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-datatable,avl-dropdown,avl-list,avl-radio-group,avl-app-switcher,avl-chip-list,avl-combo-box'
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }]; }, propDecorators: { selectedIndexChange: [{
                    type: i0.Output
                }], selectedValueChange: [{
                    type: i0.Output
                }] } });

    // Defines which property is used as the 'value' for the ControlValueAccessor
    var valuePropertyNameMap = {
        // TODO: is there a nameof function is typescript?
        'avl-checkbox': 'checked',
        'avl-date': 'value',
        'avl-dropdown': 'selectedValue',
        'avl-time': 'value',
        'avl-numberfield': 'value',
        'avl-radio-group': 'selectedValue',
        'avl-slider': 'value',
        'avl-textarea': 'value',
        'avl-textfield': 'value',
        'avl-timespan': 'value',
        'avl-chip-list': 'selectedValue',
        'avl-chip-input': 'selectedValues',
        'avl-upload': 'files',
        'avl-search-bar': 'query',
        'avl-icon-toggle': 'checked',
        'avl-switch': 'checked'
    };
    /** Directive for controls implementing [AvlFormControl]. */
    var AvlFormControlDirective = /** @class */ (function (_super) {
        __extends(AvlFormControlDirective, _super);
        function AvlFormControlDirective(elementRef, renderer) {
            var _this = _super.call(this, elementRef) || this;
            _this.elementRef = elementRef;
            _this.renderer = renderer;
            _this.writeValueAlreadyCalled = false;
            //#endregion
            //#region AvlFormControl
            // tslint:disable-next-line:member-ordering
            _this.invalidChange = new i0.EventEmitter();
            var controlTag = _this.elementRef.nativeElement.tagName.toLowerCase();
            _this.valuePropertyName = valuePropertyNameMap[controlTag];
            return _this;
        }
        Object.defineProperty(AvlFormControlDirective.prototype, "readonly", {
            // Angular writes readonly attributes to a readOnly property,
            // because that's how it's called on the native input element.
            set: function (value) {
                if (typeof value === 'boolean') {
                    this.elementRef.nativeElement.readonly = value;
                }
                else {
                    this.elementRef.nativeElement.readonly = value != null;
                }
            },
            enumerable: false,
            configurable: true
        });
        AvlFormControlDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.unlistenPropertyChangedEvent =
                this.renderer.listen(this.elementRef.nativeElement, this.toKebabCase(this.valuePropertyName) + "-changed", function (e) {
                    if (_this.onChangeCallback) {
                        _this.onChangeCallback(e.detail.value);
                    }
                });
        };
        AvlFormControlDirective.prototype.ngOnDestroy = function () {
            if (this.unlistenPropertyChangedEvent) {
                this.unlistenPropertyChangedEvent();
            }
        };
        AvlFormControlDirective.prototype.writeValue = function (value) {
            // Because of a bug in Angular writeValue sometimes gets called with a null before being called with the real value,
            // so the null is discarded.
            // TODO: remove when issue is fixed: https://github.com/angular/angular/issues/14988
            if (!this.writeValueAlreadyCalled && value == null) {
                this.writeValueAlreadyCalled = true;
                return;
            }
            this.renderer.setProperty(this.elementRef.nativeElement, this.valuePropertyName, value);
            this.writeValueAlreadyCalled = true;
        };
        AvlFormControlDirective.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        AvlFormControlDirective.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        AvlFormControlDirective.prototype.setDisabledState = function (isDisabled) {
            this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
        };
        AvlFormControlDirective.prototype.onBlur = function () {
            if (this.onTouchedCallback) {
                this.onTouchedCallback();
            }
        };
        AvlFormControlDirective.prototype.onFocusedChanged = function (focused) {
            if (!focused && this.onTouchedCallback) {
                this.onTouchedCallback();
            }
        };
        AvlFormControlDirective.prototype.toKebabCase = function (camelCaseString) {
            return camelCaseString.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
        };
        AvlFormControlDirective.prototype.invalidChanged = function (e) {
            this.invalidChange.emit(e.detail.value);
            // Trigger validation
            if (this.onChangeCallback) {
                this.onChangeCallback(this.elementRef.nativeElement[this.valuePropertyName]);
            }
        };
        //#endregion
        //#region Validator
        AvlFormControlDirective.prototype.validate = function (control) {
            var formControl = this.elementRef.nativeElement;
            if (formControl.invalid) {
                return { invalid: formControl.errorMessage };
            }
            else {
                return null;
            }
        };
        return AvlFormControlDirective;
    }(AvlInteractionControlDirective));
    AvlFormControlDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlFormControlDirective, deps: [{ token: i0__namespace.ElementRef }, { token: i0__namespace.Renderer2 }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    AvlFormControlDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlFormControlDirective, selector: "avl-date,avl-dropdown,avl-time,avl-icon-toggle,avl-numberfield,avl-radio-group,avl-slider,avl-textarea,avl-textfield,avl-timespan,avl-checkbox,avl-switch,avl-chip-list,avl-upload,avl-search-bar,avl-chip-input", inputs: { readonly: "readonly" }, outputs: { invalidChange: "invalidChange" }, host: { listeners: { "blur": "onBlur()", "focused-changed": "onFocusedChanged($event.detail.value)", "invalid-changed": "invalidChanged($event)" } }, providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AvlFormControlDirective; }), multi: true },
            { provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AvlFormControlDirective; }), multi: true }], usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlFormControlDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'avl-date,avl-dropdown,avl-time,avl-icon-toggle,avl-numberfield,avl-radio-group,avl-slider,avl-textarea,avl-textfield,avl-timespan,avl-checkbox,avl-switch,avl-chip-list,avl-upload,avl-search-bar,avl-chip-input',
                        providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AvlFormControlDirective; }), multi: true },
                            { provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AvlFormControlDirective; }), multi: true }]
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.Renderer2 }]; }, propDecorators: { readonly: [{
                    type: i0.Input
                }], onBlur: [{
                    type: i0.HostListener,
                    args: ['blur']
                }], onFocusedChanged: [{
                    type: i0.HostListener,
                    args: ['focused-changed', ['$event.detail.value']]
                }], invalidChange: [{
                    type: i0.Output
                }], invalidChanged: [{
                    type: i0.HostListener,
                    args: ['invalid-changed', ['$event']]
                }] } });

    var binders = [
        AvlBreadcrumbDirective,
        AvlOverflowMenuDirective,
        AvlSearchBarDirective,
        AvlTextareaDirective,
        AvlDateDirective,
        AvlSideSheetDirective,
        AvlTextfieldDirective,
        AvlTimespanDirective,
        AvlCheckableControlDirective,
        AvlControlDirective,
        AvlFormControlDirective,
        AvlInteractionControlDirective,
        AvlMultiSelectControlDirective,
        AvlSingleSelectControlDirective,
        AvlDropdownDirective,
        AvlTimeDirective,
        AvlListDirective,
        AvlUploadDirective,
        AvlContextMenuDirective,
        AvlNumberfieldDirective,
        AvlCheckboxDirective,
        AvlDatatableDirective,
        AvlComboBoxDirective,
        AvlTabBarDirective,
        AvlSnackbarDirective,
        AvlStepProgressDirective,
        AvlIconButtonDirective,
    ];
    var AvlNgBindersModule = /** @class */ (function () {
        function AvlNgBindersModule() {
        }
        return AvlNgBindersModule;
    }());
    AvlNgBindersModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlNgBindersModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    AvlNgBindersModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlNgBindersModule, declarations: [AvlBreadcrumbDirective,
            AvlOverflowMenuDirective,
            AvlSearchBarDirective,
            AvlTextareaDirective,
            AvlDateDirective,
            AvlSideSheetDirective,
            AvlTextfieldDirective,
            AvlTimespanDirective,
            AvlCheckableControlDirective,
            AvlControlDirective,
            AvlFormControlDirective,
            AvlInteractionControlDirective,
            AvlMultiSelectControlDirective,
            AvlSingleSelectControlDirective,
            AvlDropdownDirective,
            AvlTimeDirective,
            AvlListDirective,
            AvlUploadDirective,
            AvlContextMenuDirective,
            AvlNumberfieldDirective,
            AvlCheckboxDirective,
            AvlDatatableDirective,
            AvlComboBoxDirective,
            AvlTabBarDirective,
            AvlSnackbarDirective,
            AvlStepProgressDirective,
            AvlIconButtonDirective], imports: [common.CommonModule,
            forms.FormsModule], exports: [AvlBreadcrumbDirective,
            AvlOverflowMenuDirective,
            AvlSearchBarDirective,
            AvlTextareaDirective,
            AvlDateDirective,
            AvlSideSheetDirective,
            AvlTextfieldDirective,
            AvlTimespanDirective,
            AvlCheckableControlDirective,
            AvlControlDirective,
            AvlFormControlDirective,
            AvlInteractionControlDirective,
            AvlMultiSelectControlDirective,
            AvlSingleSelectControlDirective,
            AvlDropdownDirective,
            AvlTimeDirective,
            AvlListDirective,
            AvlUploadDirective,
            AvlContextMenuDirective,
            AvlNumberfieldDirective,
            AvlCheckboxDirective,
            AvlDatatableDirective,
            AvlComboBoxDirective,
            AvlTabBarDirective,
            AvlSnackbarDirective,
            AvlStepProgressDirective,
            AvlIconButtonDirective] });
    AvlNgBindersModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlNgBindersModule, imports: [[
                common.CommonModule,
                forms.FormsModule
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0__namespace, type: AvlNgBindersModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule
                        ],
                        declarations: __spreadArray([], __read(binders)),
                        exports: __spreadArray([], __read(binders))
                    }]
            }] });

    /*
     * Public API Surface of ng-binders
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AvlBreadcrumbDirective = AvlBreadcrumbDirective;
    exports.AvlCheckableControlDirective = AvlCheckableControlDirective;
    exports.AvlCheckboxDirective = AvlCheckboxDirective;
    exports.AvlComboBoxDirective = AvlComboBoxDirective;
    exports.AvlContextMenuDirective = AvlContextMenuDirective;
    exports.AvlControlDirective = AvlControlDirective;
    exports.AvlDatatableDirective = AvlDatatableDirective;
    exports.AvlDateDirective = AvlDateDirective;
    exports.AvlDropdownDirective = AvlDropdownDirective;
    exports.AvlFormControlDirective = AvlFormControlDirective;
    exports.AvlIconButtonDirective = AvlIconButtonDirective;
    exports.AvlInteractionControlDirective = AvlInteractionControlDirective;
    exports.AvlListDirective = AvlListDirective;
    exports.AvlMultiSelectControlDirective = AvlMultiSelectControlDirective;
    exports.AvlNgBindersModule = AvlNgBindersModule;
    exports.AvlNumberfieldDirective = AvlNumberfieldDirective;
    exports.AvlOverflowMenuDirective = AvlOverflowMenuDirective;
    exports.AvlSearchBarDirective = AvlSearchBarDirective;
    exports.AvlSideSheetDirective = AvlSideSheetDirective;
    exports.AvlSingleSelectControlDirective = AvlSingleSelectControlDirective;
    exports.AvlSnackbarDirective = AvlSnackbarDirective;
    exports.AvlStepProgressDirective = AvlStepProgressDirective;
    exports.AvlTabBarDirective = AvlTabBarDirective;
    exports.AvlTextareaDirective = AvlTextareaDirective;
    exports.AvlTextfieldDirective = AvlTextfieldDirective;
    exports.AvlTimeDirective = AvlTimeDirective;
    exports.AvlTimespanDirective = AvlTimespanDirective;
    exports.AvlUploadDirective = AvlUploadDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=avl-controls-ng-binders.umd.js.map
