import { __decorate, __metadata, __awaiter, __param } from 'tslib';
import { EventEmitter, Output, HostListener, Directive, ElementRef, Renderer2, Input, forwardRef, InjectionToken, Inject, Injectable, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS, FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { HttpEventType, HttpClient } from '@angular/common/http';
import { map, catchError } from 'rxjs/operators';
import { Observable } from 'rxjs';
import { TranslateService } from '@ngx-translate/core';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common/http';
import * as ɵngcc2 from '@ngx-translate/core';
let AvlBreadcrumbDirective = class AvlBreadcrumbDirective {
    constructor() {
        this.itemClicked = new EventEmitter();
    }
    itemClickedListener(e) {
        this.itemClicked.emit(e.detail.item);
    }
};
AvlBreadcrumbDirective.ɵfac = function AvlBreadcrumbDirective_Factory(t) { return new (t || AvlBreadcrumbDirective)(); };
AvlBreadcrumbDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlBreadcrumbDirective, selectors: [["avl-breadcrumb"]], hostBindings: function AvlBreadcrumbDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("item-clicked", function AvlBreadcrumbDirective_item_clicked_HostBindingHandler($event) { return ctx.itemClickedListener($event); });
    } }, outputs: { itemClicked: "itemClicked" } });
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlBreadcrumbDirective.prototype, "itemClicked", void 0);
__decorate([
    HostListener('item-clicked', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlBreadcrumbDirective.prototype, "itemClickedListener", null);

/**
 * Maps Polymer 'changed' events to Angular 'change' events so it can be used in 2-way binding.
 * HostListener can't be used because when a polymer control has a default value polymer will emit a changed event
 * which will overwrite the value in the bound angular variable. So the event listener is added after the constructor
 * so the default value changed event will be skipped.
 * TODO: There is still a problem if the bound variable is not set. If the default changed event is skipped the variable
 * will not get the default value so the control and the variable will have missmatching values.
 */
function addEventListenerForEmittingChangedEvents(elementRef, polymerEventName, angularEventEmmiter) {
    return __awaiter(this, void 0, void 0, function* () {
        Promise.resolve().then(() => {
            const nativeElement = elementRef.nativeElement;
            return nativeElement.addEventListener(polymerEventName, (e) => {
                angularEventEmmiter.emit(e.detail.value);
            });
        });
    });
}

let AvlCheckboxDirective = class AvlCheckboxDirective {
    constructor(elementRef) {
        this.indeterminateChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'indeterminate-changed', this.indeterminateChange);
    }
};
AvlCheckboxDirective.ɵfac = function AvlCheckboxDirective_Factory(t) { return new (t || AvlCheckboxDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlCheckboxDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlCheckboxDirective, selectors: [["avl-checkbox"]], outputs: { indeterminateChange: "indeterminateChange" } });
AvlCheckboxDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlCheckboxDirective.prototype, "indeterminateChange", void 0);
AvlCheckboxDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlCheckboxDirective);

/** Directive for controls implementing [AvlControl]. */
let AvlControlDirective = class AvlControlDirective {
    constructor(elementRef) {
        this.disabledChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'disabled-changed', this.disabledChange);
    }
};
AvlControlDirective.ɵfac = function AvlControlDirective_Factory(t) { return new (t || AvlControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlControlDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlControlDirective, selectors: [["avl-breadcrumb"], ["avl-context-menu"], ["avl-header-bar"], ["avl-menu-button"], ["avl-user-info"]], outputs: { disabledChange: "disabledChange" } });
AvlControlDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlControlDirective.prototype, "disabledChange", void 0);
AvlControlDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlControlDirective);

/** Directive for controls implementing [AvlInteractionControl]. */
let AvlInteractionControlDirective = class AvlInteractionControlDirective extends AvlControlDirective {
    constructor(elementRef) {
        super(elementRef);
        this.focusedChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'focused-changed', this.focusedChange);
    }
};
AvlInteractionControlDirective.ɵfac = function AvlInteractionControlDirective_Factory(t) { return new (t || AvlInteractionControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlInteractionControlDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlInteractionControlDirective, selectors: [["avl-button"], ["avl-icon-button"], ["avl-item"], ["avl-search-bar"], ["avl-radio-button"], ["avl-upload"], ["avl-snackbar"]], outputs: { focusedChange: "focusedChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
AvlInteractionControlDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlInteractionControlDirective.prototype, "focusedChange", void 0);
AvlInteractionControlDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlInteractionControlDirective);

var AvlComboBoxDirective_1;
let AvlComboBoxDirective = AvlComboBoxDirective_1 = class AvlComboBoxDirective extends AvlInteractionControlDirective {
    constructor(elementRef, renderer) {
        super(elementRef);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.invalidChange = new EventEmitter();
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'invalid-changed', this.focusedChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
    // Angular writes readonly attributes to a readOnly property,
    // because that's how it's called on the native input element.
    set readonly(value) {
        this.elementRef.nativeElement.readonly = value;
    }
    valueChanged(e) {
        if (this.onChangeCallback && this.isAllowNewValues()) {
            this.onChangeCallback(e.detail.value);
        }
    }
    selectedValueChanged(e) {
        if (this.onChangeCallback && !this.isAllowNewValues()) {
            this.onChangeCallback(e.detail.value);
        }
    }
    writeValue(value) {
        const property = this.isAllowNewValues() ? 'value' : 'selectedValue';
        this.renderer.setProperty(this.elementRef.nativeElement, property, value);
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // Since avl-combo-box doesn't have validate-on-leave, there's no touching
    registerOnTouched(fn) { }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    }
    isAllowNewValues() {
        return (this.elementRef.nativeElement && this.elementRef.nativeElement.allowNewValues === true);
    }
    //#region Validator
    validate(control) {
        const formControl = this.elementRef.nativeElement;
        if (formControl.invalid) {
            return { invalid: formControl.errorMessage };
        }
        else {
            return null;
        }
    }
};
AvlComboBoxDirective.ɵfac = function AvlComboBoxDirective_Factory(t) { return new (t || AvlComboBoxDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
AvlComboBoxDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlComboBoxDirective, selectors: [["avl-combo-box"]], hostBindings: function AvlComboBoxDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("value-changed", function AvlComboBoxDirective_value_changed_HostBindingHandler($event) { return ctx.valueChanged($event); })("selected-value-changed", function AvlComboBoxDirective_selected_value_changed_HostBindingHandler($event) { return ctx.selectedValueChanged($event); });
    } }, inputs: { readonly: "readonly" }, outputs: { invalidChange: "invalidChange", valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlComboBoxDirective_1), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlComboBoxDirective_1), multi: true }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
AvlComboBoxDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlComboBoxDirective.prototype, "invalidChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlComboBoxDirective.prototype, "valueChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], AvlComboBoxDirective.prototype, "readonly", null);
__decorate([
    HostListener('value-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlComboBoxDirective.prototype, "valueChanged", null);
__decorate([
    HostListener('selected-value-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlComboBoxDirective.prototype, "selectedValueChanged", null);
AvlComboBoxDirective = AvlComboBoxDirective_1 = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], AvlComboBoxDirective);

let AvlOverflowMenuDirective = class AvlOverflowMenuDirective {
    constructor(elementRef) {
        this.itemClicked = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'item-clicked', this.itemClicked);
    }
};
AvlOverflowMenuDirective.ɵfac = function AvlOverflowMenuDirective_Factory(t) { return new (t || AvlOverflowMenuDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlOverflowMenuDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlOverflowMenuDirective, selectors: [["avl-overflow-menu"]], outputs: { itemClicked: "itemClicked" } });
AvlOverflowMenuDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlOverflowMenuDirective.prototype, "itemClicked", void 0);
AvlOverflowMenuDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlOverflowMenuDirective);

let AvlSearchBarDirective = class AvlSearchBarDirective {
    constructor(elementRef) {
        this.queryChange = new EventEmitter();
        this.openChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'query-changed', this.queryChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChange);
    }
};
AvlSearchBarDirective.ɵfac = function AvlSearchBarDirective_Factory(t) { return new (t || AvlSearchBarDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlSearchBarDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlSearchBarDirective, selectors: [["avl-search-bar"]], outputs: { queryChange: "queryChange", openChange: "openChange" } });
AvlSearchBarDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlSearchBarDirective.prototype, "queryChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlSearchBarDirective.prototype, "openChange", void 0);
AvlSearchBarDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlSearchBarDirective);

let AvlTextareaDirective = class AvlTextareaDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
};
AvlTextareaDirective.ɵfac = function AvlTextareaDirective_Factory(t) { return new (t || AvlTextareaDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlTextareaDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlTextareaDirective, selectors: [["avl-textarea"]], outputs: { valueChange: "valueChange" } });
AvlTextareaDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlTextareaDirective.prototype, "valueChange", void 0);
AvlTextareaDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlTextareaDirective);

let AvlDateDirective = class AvlDateDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
};
AvlDateDirective.ɵfac = function AvlDateDirective_Factory(t) { return new (t || AvlDateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlDateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlDateDirective, selectors: [["avl-date"]], outputs: { valueChange: "valueChange" } });
AvlDateDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlDateDirective.prototype, "valueChange", void 0);
AvlDateDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlDateDirective);

let AvlSideSheetDirective = class AvlSideSheetDirective {
    constructor(elementRef) {
        this.openChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChange);
    }
};
AvlSideSheetDirective.ɵfac = function AvlSideSheetDirective_Factory(t) { return new (t || AvlSideSheetDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlSideSheetDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlSideSheetDirective, selectors: [["avl-side-sheet"]], outputs: { openChange: "openChange" } });
AvlSideSheetDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlSideSheetDirective.prototype, "openChange", void 0);
AvlSideSheetDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlSideSheetDirective);

let AvlTextfieldDirective = class AvlTextfieldDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
};
AvlTextfieldDirective.ɵfac = function AvlTextfieldDirective_Factory(t) { return new (t || AvlTextfieldDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlTextfieldDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlTextfieldDirective, selectors: [["avl-textfield"]], outputs: { valueChange: "valueChange" } });
AvlTextfieldDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlTextfieldDirective.prototype, "valueChange", void 0);
AvlTextfieldDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlTextfieldDirective);

let AvlTimespanDirective = class AvlTimespanDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
};
AvlTimespanDirective.ɵfac = function AvlTimespanDirective_Factory(t) { return new (t || AvlTimespanDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlTimespanDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlTimespanDirective, selectors: [["avl-timespan"]], outputs: { valueChange: "valueChange" } });
AvlTimespanDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlTimespanDirective.prototype, "valueChange", void 0);
AvlTimespanDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlTimespanDirective);

const UPLOAD_SERVICE = new InjectionToken('UPLOAD_SERVICE');

let AvlUploadDirective = class AvlUploadDirective {
    constructor(element, uploadService) {
        this.element = element;
        this.uploadService = uploadService;
        this.uploadComplete = new EventEmitter();
        this.uploadAbort = new EventEmitter();
        this.uploadFail = new EventEmitter();
        this.uploadStart = new EventEmitter();
        this.filesChanged = new EventEmitter();
        this.fileRejected = new EventEmitter();
        this.menuItemClicked = new EventEmitter();
    }
    ngOnInit() {
        const element = this.element.nativeElement;
        element.uploadService = this.uploadService;
    }
    uploadCompleteHandler(e) {
        this.uploadComplete.emit(e.detail.value);
    }
    uploadCanceledHandler(e) {
        this.uploadAbort.emit(e.detail.value);
    }
    uploadStartedHandler(e) {
        this.uploadStart.emit(e.detail.value);
    }
    uploadFailedHandler(e) {
        this.uploadFail.emit(e.detail);
    }
    filesChangedHandler(e) {
        this.filesChanged.emit(e.detail.value);
    }
    fileRejectedHandler(e) {
        this.fileRejected.emit(e.detail.value);
    }
    menuItemClickedHandler(e) {
        this.menuItemClicked.emit(e.detail);
    }
};
AvlUploadDirective.ɵfac = function AvlUploadDirective_Factory(t) { return new (t || AvlUploadDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(UPLOAD_SERVICE)); };
AvlUploadDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlUploadDirective, selectors: [["avl-upload"]], hostBindings: function AvlUploadDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("upload-complete", function AvlUploadDirective_upload_complete_HostBindingHandler($event) { return ctx.uploadCompleteHandler($event); })("upload-abort", function AvlUploadDirective_upload_abort_HostBindingHandler($event) { return ctx.uploadCanceledHandler($event); })("upload-start", function AvlUploadDirective_upload_start_HostBindingHandler($event) { return ctx.uploadStartedHandler($event); })("upload-fail", function AvlUploadDirective_upload_fail_HostBindingHandler($event) { return ctx.uploadFailedHandler($event); })("files-changed", function AvlUploadDirective_files_changed_HostBindingHandler($event) { return ctx.filesChangedHandler($event); })("file-rejected", function AvlUploadDirective_file_rejected_HostBindingHandler($event) { return ctx.fileRejectedHandler($event); })("menu-item-clicked", function AvlUploadDirective_menu_item_clicked_HostBindingHandler($event) { return ctx.menuItemClickedHandler($event); });
    } }, outputs: { uploadComplete: "uploadComplete", uploadAbort: "uploadAbort", uploadFail: "uploadFail", uploadStart: "uploadStart", filesChanged: "filesChanged", fileRejected: "fileRejected", menuItemClicked: "menuItemClicked" } });
AvlUploadDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [UPLOAD_SERVICE,] }] }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "uploadComplete", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "uploadAbort", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "uploadFail", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "uploadStart", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "filesChanged", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "fileRejected", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "menuItemClicked", void 0);
__decorate([
    HostListener('upload-complete', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "uploadCompleteHandler", null);
__decorate([
    HostListener('upload-abort', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "uploadCanceledHandler", null);
__decorate([
    HostListener('upload-start', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "uploadStartedHandler", null);
__decorate([
    HostListener('upload-fail', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "uploadFailedHandler", null);
__decorate([
    HostListener('files-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "filesChangedHandler", null);
__decorate([
    HostListener('file-rejected', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "fileRejectedHandler", null);
__decorate([
    HostListener('menu-item-clicked', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "menuItemClickedHandler", null);
AvlUploadDirective = __decorate([ __param(1, Inject(UPLOAD_SERVICE)),
    __metadata("design:paramtypes", [ElementRef, Object])
], AvlUploadDirective);

let AvlTabBarDirective = class AvlTabBarDirective {
    constructor(el) {
        this.el = el;
        this.selectedIndexChange = new EventEmitter();
        this.selectedValueChange = new EventEmitter();
        this.tabBar = this.el.nativeElement;
        Promise.resolve().then(() => {
            this.setEventListeners(el.nativeElement);
        });
    }
    setEventListeners(el) {
        return __awaiter(this, void 0, void 0, function* () {
            el.addEventListener('selected-value-changed', (event) => {
                Promise.resolve().then(() => {
                    this.selectedValueChange.emit(event.detail.value);
                });
            });
            el.addEventListener('selected-index-changed', (event) => {
                Promise.resolve().then(() => {
                    this.selectedIndexChange.emit(event.detail.value);
                });
            });
        });
    }
    setTab(index, value) {
        const tabs = this.tabBar.tabs;
        for (const prop in value) {
            if (value.hasOwnProperty(prop)) {
                tabs[index][prop] = value[prop];
                this.tabBar.notifyPath(`tabs.${index}.${prop}`);
            }
        }
    }
};
AvlTabBarDirective.ɵfac = function AvlTabBarDirective_Factory(t) { return new (t || AvlTabBarDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlTabBarDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlTabBarDirective, selectors: [["avl-tab-bar"]], outputs: { selectedIndexChange: "selectedIndexChange", selectedValueChange: "selectedValueChange" } });
AvlTabBarDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlTabBarDirective.prototype, "selectedIndexChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlTabBarDirective.prototype, "selectedValueChange", void 0);
AvlTabBarDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlTabBarDirective);

let AvlDropdownDirective = class AvlDropdownDirective {
    constructor(elementRef) {
        this.openChanged = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChanged);
    }
};
AvlDropdownDirective.ɵfac = function AvlDropdownDirective_Factory(t) { return new (t || AvlDropdownDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlDropdownDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlDropdownDirective, selectors: [["avl-dropdown"]], outputs: { openChanged: "openChanged" } });
AvlDropdownDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlDropdownDirective.prototype, "openChanged", void 0);
AvlDropdownDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlDropdownDirective);

let AvlTimeDirective = class AvlTimeDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
};
AvlTimeDirective.ɵfac = function AvlTimeDirective_Factory(t) { return new (t || AvlTimeDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlTimeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlTimeDirective, selectors: [["avl-time"]], outputs: { valueChange: "valueChange" } });
AvlTimeDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlTimeDirective.prototype, "valueChange", void 0);
AvlTimeDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlTimeDirective);

var AvlListDirective_1;
let AvlListDirective = AvlListDirective_1 = class AvlListDirective extends AvlInteractionControlDirective {
    constructor(elementRef, renderer) {
        super(elementRef);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.invalidChange = new EventEmitter();
        this.overflowMenuItemClicked = new EventEmitter();
        this.rightCheckboxChanged = new EventEmitter();
        this.activeRowChanged = new EventEmitter();
        this.rowReordered = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'invalid-changed', this.focusedChange);
    }
    // Angular writes readonly attributes to a readOnly property,
    // because that's how it's called on the native input element.
    set readonly(value) {
        this.elementRef.nativeElement.readonly = value;
    }
    selectedValueChanged(e) {
        if (this.onChangeCallback && !this.isMulti()) {
            this.onChangeCallback(e.detail.value);
        }
    }
    selectedValuesChanged(e) {
        if (this.onChangeCallback && this.isMulti()) {
            this.onChangeCallback(e.detail.value);
        }
    }
    overflowMenuItemClickListener(e) {
        this.overflowMenuItemClicked.emit(e.detail);
    }
    rightCheckboxChangeListener(e) {
        this.rightCheckboxChanged.emit(e.detail);
    }
    activatedRowChangeListener(e) {
        this.activeRowChanged.emit(e.detail.value);
    }
    rowReorderedListener(e) {
        this.rowReordered.emit(e.detail);
    }
    writeValue(value) {
        const property = this.isMulti() ? 'selectedValues' : 'selectedValue';
        this.renderer.setProperty(this.elementRef.nativeElement, property, value);
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // Since avl-list doesn't have validate-on-leave, there's no touching
    registerOnTouched(fn) { }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    }
    isMulti() {
        return (this.elementRef.nativeElement && this.elementRef.nativeElement.multi === true);
    }
    //#region Validator
    validate(control) {
        const formControl = this.elementRef.nativeElement;
        if (formControl.invalid) {
            return { invalid: formControl.errorMessage };
        }
        else {
            return null;
        }
    }
};
AvlListDirective.ɵfac = function AvlListDirective_Factory(t) { return new (t || AvlListDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
AvlListDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlListDirective, selectors: [["avl-list"]], hostBindings: function AvlListDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("selected-value-changed", function AvlListDirective_selected_value_changed_HostBindingHandler($event) { return ctx.selectedValueChanged($event); })("selected-values-changed", function AvlListDirective_selected_values_changed_HostBindingHandler($event) { return ctx.selectedValuesChanged($event); })("overflow-menu-item-clicked", function AvlListDirective_overflow_menu_item_clicked_HostBindingHandler($event) { return ctx.overflowMenuItemClickListener($event); })("right-checkbox-changed", function AvlListDirective_right_checkbox_changed_HostBindingHandler($event) { return ctx.rightCheckboxChangeListener($event); })("active-row-changed", function AvlListDirective_active_row_changed_HostBindingHandler($event) { return ctx.activatedRowChangeListener($event); })("row-reordered", function AvlListDirective_row_reordered_HostBindingHandler($event) { return ctx.rowReorderedListener($event); });
    } }, inputs: { readonly: "readonly" }, outputs: { invalidChange: "invalidChange", overflowMenuItemClicked: "overflowMenuItemClicked", rightCheckboxChanged: "rightCheckboxChanged", activeRowChanged: "activeRowChanged", rowReordered: "rowReordered" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlListDirective_1), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlListDirective_1), multi: true }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
AvlListDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlListDirective.prototype, "invalidChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlListDirective.prototype, "overflowMenuItemClicked", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlListDirective.prototype, "rightCheckboxChanged", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlListDirective.prototype, "activeRowChanged", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlListDirective.prototype, "rowReordered", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], AvlListDirective.prototype, "readonly", null);
__decorate([
    HostListener('selected-value-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlListDirective.prototype, "selectedValueChanged", null);
__decorate([
    HostListener('selected-values-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlListDirective.prototype, "selectedValuesChanged", null);
__decorate([
    HostListener('overflow-menu-item-clicked', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlListDirective.prototype, "overflowMenuItemClickListener", null);
__decorate([
    HostListener('right-checkbox-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlListDirective.prototype, "rightCheckboxChangeListener", null);
__decorate([
    HostListener('active-row-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlListDirective.prototype, "activatedRowChangeListener", null);
__decorate([
    HostListener('row-reordered', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlListDirective.prototype, "rowReorderedListener", null);
AvlListDirective = AvlListDirective_1 = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], AvlListDirective);

let AvlContextMenuDirective = class AvlContextMenuDirective {
    constructor() {
        this.itemClicked = new EventEmitter();
    }
    itemClickedListener(e) {
        this.itemClicked.emit(e.detail.value);
    }
};
AvlContextMenuDirective.ɵfac = function AvlContextMenuDirective_Factory(t) { return new (t || AvlContextMenuDirective)(); };
AvlContextMenuDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlContextMenuDirective, selectors: [["avl-context-menu"]], hostBindings: function AvlContextMenuDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("item-clicked", function AvlContextMenuDirective_item_clicked_HostBindingHandler($event) { return ctx.itemClickedListener($event); });
    } }, outputs: { itemClicked: "itemClicked" } });
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlContextMenuDirective.prototype, "itemClicked", void 0);
__decorate([
    HostListener('item-clicked', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlContextMenuDirective.prototype, "itemClickedListener", null);

let AvlNumberfieldDirective = class AvlNumberfieldDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
};
AvlNumberfieldDirective.ɵfac = function AvlNumberfieldDirective_Factory(t) { return new (t || AvlNumberfieldDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlNumberfieldDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlNumberfieldDirective, selectors: [["avl-numberfield"]], outputs: { valueChange: "valueChange" } });
AvlNumberfieldDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlNumberfieldDirective.prototype, "valueChange", void 0);
AvlNumberfieldDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlNumberfieldDirective);

let AvlIconButtonDirective = class AvlIconButtonDirective {
    constructor(elementRef) {
        this.badgeChange = new EventEmitter();
        this.badgeValueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'badge-changed', this.badgeChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'badge-value-changed', this.badgeValueChange);
    }
};
AvlIconButtonDirective.ɵfac = function AvlIconButtonDirective_Factory(t) { return new (t || AvlIconButtonDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlIconButtonDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlIconButtonDirective, selectors: [["avl-icon-button"]], outputs: { badgeChange: "badgeChange", badgeValueChange: "badgeValueChange" } });
AvlIconButtonDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlIconButtonDirective.prototype, "badgeChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlIconButtonDirective.prototype, "badgeValueChange", void 0);
AvlIconButtonDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlIconButtonDirective);

let AvlDatatableDirective = class AvlDatatableDirective {
    constructor(elementRef) {
        this.buttonClick = new EventEmitter();
        this.overflowMenuItemClick = new EventEmitter();
        this.linkClick = new EventEmitter();
        this.pageSizeChange = new EventEmitter();
        this.selectedPageChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'page-size-changed', this.pageSizeChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-page-changed', this.selectedPageChange);
    }
    buttonClickListener(e) {
        this.buttonClick.emit(e.detail);
    }
    overflowMenuItemClickListener(e) {
        this.overflowMenuItemClick.emit(e.detail);
    }
    linkClickListener(e) {
        this.linkClick.emit(e.detail);
    }
};
AvlDatatableDirective.ɵfac = function AvlDatatableDirective_Factory(t) { return new (t || AvlDatatableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlDatatableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlDatatableDirective, selectors: [["avl-datatable"]], hostBindings: function AvlDatatableDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("button-click", function AvlDatatableDirective_button_click_HostBindingHandler($event) { return ctx.buttonClickListener($event); })("overflow-menu-item-click", function AvlDatatableDirective_overflow_menu_item_click_HostBindingHandler($event) { return ctx.overflowMenuItemClickListener($event); })("link-click", function AvlDatatableDirective_link_click_HostBindingHandler($event) { return ctx.linkClickListener($event); });
    } }, outputs: { buttonClick: "buttonClick", overflowMenuItemClick: "overflowMenuItemClick", linkClick: "linkClick", pageSizeChange: "pageSizeChange", selectedPageChange: "selectedPageChange" } });
AvlDatatableDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlDatatableDirective.prototype, "buttonClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlDatatableDirective.prototype, "overflowMenuItemClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlDatatableDirective.prototype, "linkClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlDatatableDirective.prototype, "pageSizeChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlDatatableDirective.prototype, "selectedPageChange", void 0);
__decorate([
    HostListener('button-click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlDatatableDirective.prototype, "buttonClickListener", null);
__decorate([
    HostListener('overflow-menu-item-click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlDatatableDirective.prototype, "overflowMenuItemClickListener", null);
__decorate([
    HostListener('link-click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlDatatableDirective.prototype, "linkClickListener", null);
AvlDatatableDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlDatatableDirective);

let AvlSnackbarDirective = class AvlSnackbarDirective {
    constructor() {
        this.buttonClicked = new EventEmitter();
        this.displayedChange = new EventEmitter();
    }
    buttonClickedHandler(e) {
        this.buttonClicked.emit(e.detail.value);
    }
    displayedChangeHandler(e) {
        this.displayedChange.emit(e.detail.value);
    }
};
AvlSnackbarDirective.ɵfac = function AvlSnackbarDirective_Factory(t) { return new (t || AvlSnackbarDirective)(); };
AvlSnackbarDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlSnackbarDirective, selectors: [["avl-snackbar"]], hostBindings: function AvlSnackbarDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("button-clicked", function AvlSnackbarDirective_button_clicked_HostBindingHandler($event) { return ctx.buttonClickedHandler($event); })("displayed-changed", function AvlSnackbarDirective_displayed_changed_HostBindingHandler($event) { return ctx.displayedChangeHandler($event); });
    } }, outputs: { buttonClicked: "buttonClicked", displayedChange: "displayedChange" } });
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlSnackbarDirective.prototype, "buttonClicked", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlSnackbarDirective.prototype, "displayedChange", void 0);
__decorate([
    HostListener('button-clicked', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlSnackbarDirective.prototype, "buttonClickedHandler", null);
__decorate([
    HostListener('displayed-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlSnackbarDirective.prototype, "displayedChangeHandler", null);

/** Directive for controls implementing [AvlCheckableControl]. */
let AvlCheckableControlDirective = class AvlCheckableControlDirective {
    constructor(elementRef) {
        this.checkedChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'checked-changed', this.checkedChange);
    }
};
AvlCheckableControlDirective.ɵfac = function AvlCheckableControlDirective_Factory(t) { return new (t || AvlCheckableControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlCheckableControlDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlCheckableControlDirective, selectors: [["avl-checkbox"], ["avl-radio-button"], ["avl-icon-toggle"], ["avl-switch"]], outputs: { checkedChange: "checkedChange" } });
AvlCheckableControlDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlCheckableControlDirective.prototype, "checkedChange", void 0);
AvlCheckableControlDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlCheckableControlDirective);

/** Directive for controls implementing [AvlMultiSelectControl]. */
let AvlMultiSelectControlDirective = class AvlMultiSelectControlDirective {
    constructor(elementRef) {
        this.selectedIndexesChange = new EventEmitter();
        this.selectedValuesChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-indexes-changed', this.selectedIndexesChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-values-changed', this.selectedValuesChange);
    }
};
AvlMultiSelectControlDirective.ɵfac = function AvlMultiSelectControlDirective_Factory(t) { return new (t || AvlMultiSelectControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlMultiSelectControlDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlMultiSelectControlDirective, selectors: [["avl-datatable"], ["avl-list"], ["avl-chip-list"], ["avl-chip-input"]], outputs: { selectedIndexesChange: "selectedIndexesChange", selectedValuesChange: "selectedValuesChange" } });
AvlMultiSelectControlDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlMultiSelectControlDirective.prototype, "selectedIndexesChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlMultiSelectControlDirective.prototype, "selectedValuesChange", void 0);
AvlMultiSelectControlDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlMultiSelectControlDirective);

/** Directive for controls implementing [AvlSingleSelectControl]. */
let AvlSingleSelectControlDirective = class AvlSingleSelectControlDirective {
    constructor(elementRef) {
        this.selectedIndexChange = new EventEmitter();
        this.selectedValueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-index-changed', this.selectedIndexChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-value-changed', this.selectedValueChange);
    }
};
AvlSingleSelectControlDirective.ɵfac = function AvlSingleSelectControlDirective_Factory(t) { return new (t || AvlSingleSelectControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlSingleSelectControlDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlSingleSelectControlDirective, selectors: [["avl-datatable"], ["avl-dropdown"], ["avl-list"], ["avl-radio-group"], ["avl-app-switcher"], ["avl-chip-list"], ["avl-combo-box"]], outputs: { selectedIndexChange: "selectedIndexChange", selectedValueChange: "selectedValueChange" } });
AvlSingleSelectControlDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlSingleSelectControlDirective.prototype, "selectedIndexChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlSingleSelectControlDirective.prototype, "selectedValueChange", void 0);
AvlSingleSelectControlDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlSingleSelectControlDirective);

var AvlFormControlDirective_1;
// Defines which property is used as the 'value' for the ControlValueAccessor
const valuePropertyNameMap = {
    // TODO: is there a nameof function is typescript?
    'avl-checkbox': 'checked',
    'avl-date': 'value',
    'avl-dropdown': 'selectedValue',
    'avl-time': 'value',
    'avl-numberfield': 'value',
    'avl-radio-group': 'selectedValue',
    'avl-slider': 'value',
    'avl-textarea': 'value',
    'avl-textfield': 'value',
    'avl-timespan': 'value',
    'avl-chip-list': 'selectedValue',
    'avl-chip-input': 'selectedValues',
    'avl-upload': 'files',
    'avl-search-bar': 'query',
    'avl-icon-toggle': 'checked',
    'avl-switch': 'checked'
};
/** Directive for controls implementing [AvlFormControl]. */
let AvlFormControlDirective = AvlFormControlDirective_1 = class AvlFormControlDirective extends AvlInteractionControlDirective {
    constructor(elementRef, renderer) {
        super(elementRef);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.writeValueAlreadyCalled = false;
        //#endregion
        //#region AvlFormControl
        // tslint:disable-next-line:member-ordering
        this.invalidChange = new EventEmitter();
        const controlTag = this.elementRef.nativeElement.tagName.toLowerCase();
        this.valuePropertyName = valuePropertyNameMap[controlTag];
    }
    // Angular writes readonly attributes to a readOnly property,
    // because that's how it's called on the native input element.
    set readonly(value) {
        if (typeof value === 'boolean') {
            this.elementRef.nativeElement.readonly = value;
        }
        else {
            this.elementRef.nativeElement.readonly = value != null;
        }
    }
    ngOnInit() {
        this.unlistenPropertyChangedEvent =
            this.renderer.listen(this.elementRef.nativeElement, `${this.toKebabCase(this.valuePropertyName)}-changed`, (e) => {
                if (this.onChangeCallback) {
                    this.onChangeCallback(e.detail.value);
                }
            });
    }
    ngOnDestroy() {
        if (this.unlistenPropertyChangedEvent) {
            this.unlistenPropertyChangedEvent();
        }
    }
    writeValue(value) {
        // Because of a bug in Angular writeValue sometimes gets called with a null before being called with the real value,
        // so the null is discarded.
        // TODO: remove when issue is fixed: https://github.com/angular/angular/issues/14988
        if (!this.writeValueAlreadyCalled && value == null) {
            this.writeValueAlreadyCalled = true;
            return;
        }
        this.renderer.setProperty(this.elementRef.nativeElement, this.valuePropertyName, value);
        this.writeValueAlreadyCalled = true;
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    }
    onBlur() {
        if (this.onTouchedCallback) {
            this.onTouchedCallback();
        }
    }
    onFocusedChanged(focused) {
        if (!focused && this.onTouchedCallback) {
            this.onTouchedCallback();
        }
    }
    toKebabCase(camelCaseString) {
        return camelCaseString.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    }
    invalidChanged(e) {
        this.invalidChange.emit(e.detail.value);
        // Trigger validation
        if (this.onChangeCallback) {
            this.onChangeCallback(this.elementRef.nativeElement[this.valuePropertyName]);
        }
    }
    //#endregion
    //#region Validator
    validate(control) {
        const formControl = this.elementRef.nativeElement;
        if (formControl.invalid) {
            return { invalid: formControl.errorMessage };
        }
        else {
            return null;
        }
    }
};
AvlFormControlDirective.ɵfac = function AvlFormControlDirective_Factory(t) { return new (t || AvlFormControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
AvlFormControlDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlFormControlDirective, selectors: [["avl-date"], ["avl-dropdown"], ["avl-time"], ["avl-icon-toggle"], ["avl-numberfield"], ["avl-radio-group"], ["avl-slider"], ["avl-textarea"], ["avl-textfield"], ["avl-timespan"], ["avl-checkbox"], ["avl-switch"], ["avl-chip-list"], ["avl-upload"], ["avl-search-bar"], ["avl-chip-input"]], hostBindings: function AvlFormControlDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("blur", function AvlFormControlDirective_blur_HostBindingHandler() { return ctx.onBlur(); })("focused-changed", function AvlFormControlDirective_focused_changed_HostBindingHandler($event) { return ctx.onFocusedChanged($event.detail.value); })("invalid-changed", function AvlFormControlDirective_invalid_changed_HostBindingHandler($event) { return ctx.invalidChanged($event); });
    } }, inputs: { readonly: "readonly" }, outputs: { invalidChange: "invalidChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlFormControlDirective_1), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlFormControlDirective_1), multi: true }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
AvlFormControlDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], AvlFormControlDirective.prototype, "readonly", null);
__decorate([
    HostListener('blur'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], AvlFormControlDirective.prototype, "onBlur", null);
__decorate([
    HostListener('focused-changed', ['$event.detail.value']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], AvlFormControlDirective.prototype, "onFocusedChanged", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlFormControlDirective.prototype, "invalidChange", void 0);
__decorate([
    HostListener('invalid-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlFormControlDirective.prototype, "invalidChanged", null);
AvlFormControlDirective = AvlFormControlDirective_1 = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
], AvlFormControlDirective);

let UploadService = class UploadService {
    constructor(httpClient) {
        this.httpClient = httpClient;
    }
    downloadFile(url) {
        return this.httpClient.get(url, { responseType: "blob" }).toPromise();
    }
    uploadFile(file, target, progressCallback, completeCallback, failCallback) {
        const formData = new FormData();
        formData.append('file', file.file);
        const uploadReq = this.httpClient.post(target, formData, { reportProgress: true, observe: 'events' })
            .pipe(map(event => {
            if (event.type === HttpEventType.UploadProgress && progressCallback) {
                progressCallback(event);
            }
            if (event.type === HttpEventType.Response) {
                if (completeCallback && event.body != null && event.body.downloadUrl) {
                    completeCallback(event.body.downloadUrl);
                }
                else if (completeCallback)
                    completeCallback();
            }
        }), catchError((err, caught) => {
            const response = err.error instanceof Event ? err.error.target.response : err.error;
            if (failCallback)
                failCallback({
                    status: err.status,
                    response: response
                });
            return new Observable(null);
        }));
        const subscription = uploadReq.subscribe();
        return subscription.unsubscribe.bind(subscription);
    }
};
UploadService.ɵfac = function UploadService_Factory(t) { return new (t || UploadService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient)); };
UploadService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: UploadService, factory: UploadService.ɵfac });
UploadService.ctorParameters = () => [
    { type: HttpClient }
];
UploadService = __decorate([ __metadata("design:paramtypes", [HttpClient])
], UploadService);

let AvlStepProgressDirective = class AvlStepProgressDirective {
    constructor(elementRef) {
        this.activeChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'active-changed', this.activeChange);
    }
};
AvlStepProgressDirective.ɵfac = function AvlStepProgressDirective_Factory(t) { return new (t || AvlStepProgressDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlStepProgressDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlStepProgressDirective, selectors: [["avl-step-progress"]], outputs: { activeChange: "activeChange" } });
AvlStepProgressDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlStepProgressDirective.prototype, "activeChange", void 0);
AvlStepProgressDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
], AvlStepProgressDirective);

const binders = [
    AvlBreadcrumbDirective,
    AvlOverflowMenuDirective,
    AvlSearchBarDirective,
    AvlTextareaDirective,
    AvlDateDirective,
    AvlSideSheetDirective,
    AvlTextfieldDirective,
    AvlTimespanDirective,
    AvlCheckableControlDirective,
    AvlControlDirective,
    AvlFormControlDirective,
    AvlInteractionControlDirective,
    AvlMultiSelectControlDirective,
    AvlSingleSelectControlDirective,
    AvlDropdownDirective,
    AvlTimeDirective,
    AvlListDirective,
    AvlUploadDirective,
    AvlContextMenuDirective,
    AvlNumberfieldDirective,
    AvlCheckboxDirective,
    AvlDatatableDirective,
    AvlComboBoxDirective,
    AvlTabBarDirective,
    AvlSnackbarDirective,
    AvlStepProgressDirective,
    AvlIconButtonDirective,
];
let AvlNgBindersModule = class AvlNgBindersModule {
};
AvlNgBindersModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AvlNgBindersModule });
AvlNgBindersModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AvlNgBindersModule_Factory(t) { return new (t || AvlNgBindersModule)(); }, providers: [
        { provide: UPLOAD_SERVICE, useClass: UploadService }
    ], imports: [[
            CommonModule,
            FormsModule
        ]] });

let NgxTranslateTranslationService = class NgxTranslateTranslationService {
    constructor(translateService) {
        this.translateService = translateService;
    }
    get language() {
        return this.translateService.currentLang;
    }
    translate(key, interpolateParams) {
        return this.translateService.get(key, interpolateParams).toPromise();
    }
};
NgxTranslateTranslationService.ɵfac = function NgxTranslateTranslationService_Factory(t) { return new (t || NgxTranslateTranslationService)(ɵngcc0.ɵɵinject(ɵngcc2.TranslateService)); };
NgxTranslateTranslationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NgxTranslateTranslationService, factory: NgxTranslateTranslationService.ɵfac });
NgxTranslateTranslationService.ctorParameters = () => [
    { type: TranslateService }
];
NgxTranslateTranslationService = __decorate([ __metadata("design:paramtypes", [TranslateService])
], NgxTranslateTranslationService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlBreadcrumbDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-breadcrumb'
            }]
    }], function () { return []; }, { itemClicked: [{
            type: Output
        }], itemClickedListener: [{
            type: HostListener,
            args: ['item-clicked', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlCheckboxDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-checkbox'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { indeterminateChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlControlDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-breadcrumb,avl-context-menu,avl-header-bar,avl-menu-button,avl-user-info'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { disabledChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlInteractionControlDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-button,avl-icon-button,avl-item,avl-search-bar,avl-radio-button,avl-upload,avl-snackbar'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { focusedChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlComboBoxDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-combo-box',
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlComboBoxDirective_1), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlComboBoxDirective_1), multi: true }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { invalidChange: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], readonly: [{
            type: Input
        }], valueChanged: [{
            type: HostListener,
            args: ['value-changed', ['$event']]
        }], selectedValueChanged: [{
            type: HostListener,
            args: ['selected-value-changed', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlOverflowMenuDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-overflow-menu'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { itemClicked: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlSearchBarDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-search-bar'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { queryChange: [{
            type: Output
        }], openChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlTextareaDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-textarea'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { valueChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlDateDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-date'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { valueChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlSideSheetDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-side-sheet'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { openChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlTextfieldDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-textfield'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { valueChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlTimespanDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-timespan'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { valueChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlUploadDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-upload'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [UPLOAD_SERVICE]
            }] }]; }, { uploadComplete: [{
            type: Output
        }], uploadAbort: [{
            type: Output
        }], uploadFail: [{
            type: Output
        }], uploadStart: [{
            type: Output
        }], filesChanged: [{
            type: Output
        }], fileRejected: [{
            type: Output
        }], menuItemClicked: [{
            type: Output
        }], uploadCompleteHandler: [{
            type: HostListener,
            args: ['upload-complete', ['$event']]
        }], uploadCanceledHandler: [{
            type: HostListener,
            args: ['upload-abort', ['$event']]
        }], uploadStartedHandler: [{
            type: HostListener,
            args: ['upload-start', ['$event']]
        }], uploadFailedHandler: [{
            type: HostListener,
            args: ['upload-fail', ['$event']]
        }], filesChangedHandler: [{
            type: HostListener,
            args: ['files-changed', ['$event']]
        }], fileRejectedHandler: [{
            type: HostListener,
            args: ['file-rejected', ['$event']]
        }], menuItemClickedHandler: [{
            type: HostListener,
            args: ['menu-item-clicked', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlTabBarDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-tab-bar'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { selectedIndexChange: [{
            type: Output
        }], selectedValueChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlDropdownDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-dropdown'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { openChanged: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlTimeDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-time'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { valueChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlListDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-list',
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlListDirective_1), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlListDirective_1), multi: true }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { invalidChange: [{
            type: Output
        }], overflowMenuItemClicked: [{
            type: Output
        }], rightCheckboxChanged: [{
            type: Output
        }], activeRowChanged: [{
            type: Output
        }], rowReordered: [{
            type: Output
        }], readonly: [{
            type: Input
        }], selectedValueChanged: [{
            type: HostListener,
            args: ['selected-value-changed', ['$event']]
        }], selectedValuesChanged: [{
            type: HostListener,
            args: ['selected-values-changed', ['$event']]
        }], overflowMenuItemClickListener: [{
            type: HostListener,
            args: ['overflow-menu-item-clicked', ['$event']]
        }], rightCheckboxChangeListener: [{
            type: HostListener,
            args: ['right-checkbox-changed', ['$event']]
        }], activatedRowChangeListener: [{
            type: HostListener,
            args: ['active-row-changed', ['$event']]
        }], rowReorderedListener: [{
            type: HostListener,
            args: ['row-reordered', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlContextMenuDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-context-menu'
            }]
    }], function () { return []; }, { itemClicked: [{
            type: Output
        }], itemClickedListener: [{
            type: HostListener,
            args: ['item-clicked', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlNumberfieldDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-numberfield'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { valueChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlIconButtonDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-icon-button'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { badgeChange: [{
            type: Output
        }], badgeValueChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlDatatableDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-datatable'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { buttonClick: [{
            type: Output
        }], overflowMenuItemClick: [{
            type: Output
        }], linkClick: [{
            type: Output
        }], pageSizeChange: [{
            type: Output
        }], selectedPageChange: [{
            type: Output
        }], buttonClickListener: [{
            type: HostListener,
            args: ['button-click', ['$event']]
        }], overflowMenuItemClickListener: [{
            type: HostListener,
            args: ['overflow-menu-item-click', ['$event']]
        }], linkClickListener: [{
            type: HostListener,
            args: ['link-click', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlSnackbarDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-snackbar'
            }]
    }], function () { return []; }, { buttonClicked: [{
            type: Output
        }], displayedChange: [{
            type: Output
        }], buttonClickedHandler: [{
            type: HostListener,
            args: ['button-clicked', ['$event']]
        }], displayedChangeHandler: [{
            type: HostListener,
            args: ['displayed-changed', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlCheckableControlDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-checkbox,avl-radio-button, avl-icon-toggle, avl-switch'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { checkedChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlMultiSelectControlDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-datatable,avl-list,avl-chip-list, avl-chip-input'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { selectedIndexesChange: [{
            type: Output
        }], selectedValuesChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlSingleSelectControlDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-datatable,avl-dropdown,avl-list,avl-radio-group,avl-app-switcher,avl-chip-list,avl-combo-box'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { selectedIndexChange: [{
            type: Output
        }], selectedValueChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlFormControlDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-date,avl-dropdown,avl-time,avl-icon-toggle,avl-numberfield,avl-radio-group,avl-slider,avl-textarea,avl-textfield,avl-timespan,avl-checkbox,avl-switch,avl-chip-list,avl-upload,avl-search-bar,avl-chip-input',
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlFormControlDirective_1), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlFormControlDirective_1), multi: true }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { invalidChange: [{
            type: Output
        }], readonly: [{
            type: Input
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }], onFocusedChanged: [{
            type: HostListener,
            args: ['focused-changed', ['$event.detail.value']]
        }], invalidChanged: [{
            type: HostListener,
            args: ['invalid-changed', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UploadService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.HttpClient }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlStepProgressDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-step-progress'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { activeChange: [{
            type: Output
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AvlNgBindersModule, { declarations: function () { return [AvlBreadcrumbDirective,
        AvlOverflowMenuDirective,
        AvlSearchBarDirective,
        AvlTextareaDirective,
        AvlDateDirective,
        AvlSideSheetDirective,
        AvlTextfieldDirective,
        AvlTimespanDirective,
        AvlCheckableControlDirective,
        AvlControlDirective,
        AvlFormControlDirective,
        AvlInteractionControlDirective,
        AvlMultiSelectControlDirective,
        AvlSingleSelectControlDirective,
        AvlDropdownDirective,
        AvlTimeDirective,
        AvlListDirective,
        AvlUploadDirective,
        AvlContextMenuDirective,
        AvlNumberfieldDirective,
        AvlCheckboxDirective,
        AvlDatatableDirective,
        AvlComboBoxDirective,
        AvlTabBarDirective,
        AvlSnackbarDirective,
        AvlStepProgressDirective,
        AvlIconButtonDirective]; }, imports: function () { return [CommonModule,
        FormsModule]; }, exports: function () { return [AvlBreadcrumbDirective,
        AvlOverflowMenuDirective,
        AvlSearchBarDirective,
        AvlTextareaDirective,
        AvlDateDirective,
        AvlSideSheetDirective,
        AvlTextfieldDirective,
        AvlTimespanDirective,
        AvlCheckableControlDirective,
        AvlControlDirective,
        AvlFormControlDirective,
        AvlInteractionControlDirective,
        AvlMultiSelectControlDirective,
        AvlSingleSelectControlDirective,
        AvlDropdownDirective,
        AvlTimeDirective,
        AvlListDirective,
        AvlUploadDirective,
        AvlContextMenuDirective,
        AvlNumberfieldDirective,
        AvlCheckboxDirective,
        AvlDatatableDirective,
        AvlComboBoxDirective,
        AvlTabBarDirective,
        AvlSnackbarDirective,
        AvlStepProgressDirective,
        AvlIconButtonDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlNgBindersModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule
                ],
                declarations: [
                    ...binders
                ],
                exports: [
                    ...binders
                ],
                providers: [
                    { provide: UPLOAD_SERVICE, useClass: UploadService }
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxTranslateTranslationService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc2.TranslateService }]; }, null); })();

/*
 * Public API Surface of ng-binders
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AvlBreadcrumbDirective, AvlCheckableControlDirective, AvlCheckboxDirective, AvlComboBoxDirective, AvlContextMenuDirective, AvlControlDirective, AvlDatatableDirective, AvlDateDirective, AvlDropdownDirective, AvlFormControlDirective, AvlIconButtonDirective, AvlInteractionControlDirective, AvlListDirective, AvlMultiSelectControlDirective, AvlNgBindersModule, AvlNumberfieldDirective, AvlOverflowMenuDirective, AvlSearchBarDirective, AvlSideSheetDirective, AvlSingleSelectControlDirective, AvlSnackbarDirective, AvlTabBarDirective, AvlTextareaDirective, AvlTextfieldDirective, AvlTimeDirective, AvlTimespanDirective, AvlUploadDirective, NgxTranslateTranslationService, UPLOAD_SERVICE, UploadService, AvlStepProgressDirective as ɵa };

//# sourceMappingURL=avl-controls-ng-binders.js.map