import * as i0 from '@angular/core';
import { EventEmitter, Directive, Output, HostListener, forwardRef, Input, Inject, NgModule } from '@angular/core';
import { __awaiter } from 'tslib';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS, FormsModule } from '@angular/forms';
import { UPLOAD_SERVICE, UploadService } from '@avl-services/ng-services';
import { CommonModule } from '@angular/common';

class AvlBreadcrumbDirective {
    constructor() {
        this.itemClicked = new EventEmitter();
    }
    itemClickedListener(e) {
        this.itemClicked.emit(e.detail.item);
    }
}
AvlBreadcrumbDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlBreadcrumbDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
AvlBreadcrumbDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlBreadcrumbDirective, selector: "avl-breadcrumb", outputs: { itemClicked: "itemClicked" }, host: { listeners: { "item-clicked": "itemClickedListener($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlBreadcrumbDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-breadcrumb'
                }]
        }], propDecorators: { itemClicked: [{
                type: Output
            }], itemClickedListener: [{
                type: HostListener,
                args: ['item-clicked', ['$event']]
            }] } });

/**
 * Maps Polymer 'changed' events to Angular 'change' events so it can be used in 2-way binding.
 * HostListener can't be used because when a polymer control has a default value polymer will emit a changed event
 * which will overwrite the value in the bound angular variable. So the event listener is added after the constructor
 * so the default value changed event will be skipped.
 * TODO: There is still a problem if the bound variable is not set. If the default changed event is skipped the variable
 * will not get the default value so the control and the variable will have missmatching values.
 */
function addEventListenerForEmittingChangedEvents(elementRef, polymerEventName, angularEventEmmiter) {
    return __awaiter(this, void 0, void 0, function* () {
        Promise.resolve().then(() => {
            const nativeElement = elementRef.nativeElement;
            return nativeElement.addEventListener(polymerEventName, (e) => {
                angularEventEmmiter.emit(e.detail.value);
            });
        });
    });
}

class AvlCheckboxDirective {
    constructor(elementRef) {
        this.indeterminateChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'indeterminate-changed', this.indeterminateChange);
    }
}
AvlCheckboxDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlCheckboxDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlCheckboxDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlCheckboxDirective, selector: "avl-checkbox", outputs: { indeterminateChange: "indeterminateChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlCheckboxDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-checkbox'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { indeterminateChange: [{
                type: Output
            }] } });

/** Directive for controls implementing [AvlControl]. */
class AvlControlDirective {
    constructor(elementRef) {
        this.disabledChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'disabled-changed', this.disabledChange);
    }
}
AvlControlDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlControlDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlControlDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlControlDirective, selector: "avl-breadcrumb,avl-context-menu,avl-header-bar,avl-menu-button,avl-user-info", outputs: { disabledChange: "disabledChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlControlDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-breadcrumb,avl-context-menu,avl-header-bar,avl-menu-button,avl-user-info'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { disabledChange: [{
                type: Output
            }] } });

/** Directive for controls implementing [AvlInteractionControl]. */
class AvlInteractionControlDirective extends AvlControlDirective {
    constructor(elementRef) {
        super(elementRef);
        this.focusedChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'focused-changed', this.focusedChange);
    }
}
AvlInteractionControlDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlInteractionControlDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlInteractionControlDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlInteractionControlDirective, selector: "avl-button,avl-icon-button,avl-item,avl-search-bar,avl-radio-button,avl-upload,avl-snackbar", outputs: { focusedChange: "focusedChange" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlInteractionControlDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-button,avl-icon-button,avl-item,avl-search-bar,avl-radio-button,avl-upload,avl-snackbar'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { focusedChange: [{
                type: Output
            }] } });

class AvlComboBoxDirective extends AvlInteractionControlDirective {
    constructor(elementRef, renderer) {
        super(elementRef);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.invalidChange = new EventEmitter();
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'invalid-changed', this.focusedChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
    // Angular writes readonly attributes to a readOnly property,
    // because that's how it's called on the native input element.
    set readonly(value) {
        this.elementRef.nativeElement.readonly = value;
    }
    valueChanged(e) {
        if (this.onChangeCallback && this.isAllowNewValues()) {
            this.onChangeCallback(e.detail.value);
        }
    }
    selectedValueChanged(e) {
        if (this.onChangeCallback && !this.isAllowNewValues()) {
            this.onChangeCallback(e.detail.value);
        }
    }
    writeValue(value) {
        const property = this.isAllowNewValues() ? 'value' : 'selectedValue';
        this.renderer.setProperty(this.elementRef.nativeElement, property, value);
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // Since avl-combo-box doesn't have validate-on-leave, there's no touching
    registerOnTouched(fn) { }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    }
    isAllowNewValues() {
        return (this.elementRef.nativeElement && this.elementRef.nativeElement.allowNewValues === true);
    }
    //#region Validator
    validate(control) {
        const formControl = this.elementRef.nativeElement;
        if (formControl.invalid) {
            return { invalid: formControl.errorMessage };
        }
        else {
            return null;
        }
    }
}
AvlComboBoxDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlComboBoxDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
AvlComboBoxDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlComboBoxDirective, selector: "avl-combo-box", inputs: { readonly: "readonly" }, outputs: { invalidChange: "invalidChange", valueChange: "valueChange" }, host: { listeners: { "value-changed": "valueChanged($event)", "selected-value-changed": "selectedValueChanged($event)" } }, providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlComboBoxDirective), multi: true },
        { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlComboBoxDirective), multi: true }], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlComboBoxDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-combo-box',
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlComboBoxDirective), multi: true },
                        { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlComboBoxDirective), multi: true }]
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { invalidChange: [{
                type: Output
            }], valueChange: [{
                type: Output
            }], readonly: [{
                type: Input
            }], valueChanged: [{
                type: HostListener,
                args: ['value-changed', ['$event']]
            }], selectedValueChanged: [{
                type: HostListener,
                args: ['selected-value-changed', ['$event']]
            }] } });

class AvlOverflowMenuDirective {
    constructor(elementRef) {
        this.itemClicked = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'item-clicked', this.itemClicked);
    }
}
AvlOverflowMenuDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlOverflowMenuDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlOverflowMenuDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlOverflowMenuDirective, selector: "avl-overflow-menu", outputs: { itemClicked: "itemClicked" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlOverflowMenuDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-overflow-menu'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { itemClicked: [{
                type: Output
            }] } });

class AvlSearchBarDirective {
    constructor(elementRef) {
        this.queryChange = new EventEmitter();
        this.openChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'query-changed', this.queryChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChange);
    }
}
AvlSearchBarDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlSearchBarDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlSearchBarDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlSearchBarDirective, selector: "avl-search-bar", outputs: { queryChange: "queryChange", openChange: "openChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlSearchBarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-search-bar'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { queryChange: [{
                type: Output
            }], openChange: [{
                type: Output
            }] } });

class AvlTextareaDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
}
AvlTextareaDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlTextareaDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlTextareaDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlTextareaDirective, selector: "avl-textarea", outputs: { valueChange: "valueChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlTextareaDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-textarea'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { valueChange: [{
                type: Output
            }] } });

class AvlDateDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
}
AvlDateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlDateDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlDateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlDateDirective, selector: "avl-date", outputs: { valueChange: "valueChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlDateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-date'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { valueChange: [{
                type: Output
            }] } });

class AvlSideSheetDirective {
    constructor(elementRef) {
        this.openChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChange);
    }
}
AvlSideSheetDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlSideSheetDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlSideSheetDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlSideSheetDirective, selector: "avl-side-sheet", outputs: { openChange: "openChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlSideSheetDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-side-sheet'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { openChange: [{
                type: Output
            }] } });

class AvlTextfieldDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
}
AvlTextfieldDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlTextfieldDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlTextfieldDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlTextfieldDirective, selector: "avl-textfield", outputs: { valueChange: "valueChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlTextfieldDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-textfield'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { valueChange: [{
                type: Output
            }] } });

class AvlTimespanDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
}
AvlTimespanDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlTimespanDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlTimespanDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlTimespanDirective, selector: "avl-timespan", outputs: { valueChange: "valueChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlTimespanDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-timespan'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { valueChange: [{
                type: Output
            }] } });

class AvlUploadDirective {
    constructor(element, uploadService) {
        this.element = element;
        this.uploadService = uploadService;
        this.uploadComplete = new EventEmitter();
        this.uploadAbort = new EventEmitter();
        this.uploadFail = new EventEmitter();
        this.uploadStart = new EventEmitter();
        this.filesChanged = new EventEmitter();
        this.fileRejected = new EventEmitter();
        this.menuItemClicked = new EventEmitter();
        this.downloadFail = new EventEmitter();
        this.downloadAbort = new EventEmitter();
    }
    ngOnInit() {
        const element = this.element.nativeElement;
        element.uploadService = this.uploadService;
    }
    uploadCompleteHandler(e) {
        this.uploadComplete.emit(e.detail.value);
    }
    uploadCanceledHandler(e) {
        this.uploadAbort.emit(e.detail.value);
    }
    uploadStartedHandler(e) {
        this.uploadStart.emit(e.detail.value);
    }
    uploadFailedHandler(e) {
        this.uploadFail.emit(e.detail);
    }
    filesChangedHandler(e) {
        this.filesChanged.emit(e.detail.value);
    }
    fileRejectedHandler(e) {
        this.fileRejected.emit(e.detail.value);
    }
    menuItemClickedHandler(e) {
        this.menuItemClicked.emit(e.detail);
    }
    downloadFailedHandler(e) {
        this.downloadFail.emit(e.detail);
    }
    downloadCanceledHandler(e) {
        this.downloadAbort.emit(e.detail.value);
    }
}
AvlUploadDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlUploadDirective, deps: [{ token: i0.ElementRef }, { token: UPLOAD_SERVICE }], target: i0.ɵɵFactoryTarget.Directive });
AvlUploadDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlUploadDirective, selector: "avl-upload", outputs: { uploadComplete: "uploadComplete", uploadAbort: "uploadAbort", uploadFail: "uploadFail", uploadStart: "uploadStart", filesChanged: "filesChanged", fileRejected: "fileRejected", menuItemClicked: "menuItemClicked", downloadFail: "downloadFail", downloadAbort: "downloadAbort" }, host: { listeners: { "upload-complete": "uploadCompleteHandler($event)", "upload-abort": "uploadCanceledHandler($event)", "upload-start": "uploadStartedHandler($event)", "upload-fail": "uploadFailedHandler($event)", "files-changed": "filesChangedHandler($event)", "file-rejected": "fileRejectedHandler($event)", "menu-item-clicked": "menuItemClickedHandler($event)", "download-fail": "downloadFailedHandler($event)", "download-abort": "downloadCanceledHandler($event)" } }, providers: [{ provide: UPLOAD_SERVICE, useClass: UploadService }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlUploadDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-upload',
                    providers: [{ provide: UPLOAD_SERVICE, useClass: UploadService }]
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [UPLOAD_SERVICE]
                }] }]; }, propDecorators: { uploadComplete: [{
                type: Output
            }], uploadAbort: [{
                type: Output
            }], uploadFail: [{
                type: Output
            }], uploadStart: [{
                type: Output
            }], filesChanged: [{
                type: Output
            }], fileRejected: [{
                type: Output
            }], menuItemClicked: [{
                type: Output
            }], downloadFail: [{
                type: Output
            }], downloadAbort: [{
                type: Output
            }], uploadCompleteHandler: [{
                type: HostListener,
                args: ['upload-complete', ['$event']]
            }], uploadCanceledHandler: [{
                type: HostListener,
                args: ['upload-abort', ['$event']]
            }], uploadStartedHandler: [{
                type: HostListener,
                args: ['upload-start', ['$event']]
            }], uploadFailedHandler: [{
                type: HostListener,
                args: ['upload-fail', ['$event']]
            }], filesChangedHandler: [{
                type: HostListener,
                args: ['files-changed', ['$event']]
            }], fileRejectedHandler: [{
                type: HostListener,
                args: ['file-rejected', ['$event']]
            }], menuItemClickedHandler: [{
                type: HostListener,
                args: ['menu-item-clicked', ['$event']]
            }], downloadFailedHandler: [{
                type: HostListener,
                args: ['download-fail', ['$event']]
            }], downloadCanceledHandler: [{
                type: HostListener,
                args: ['download-abort', ['$event']]
            }] } });

class AvlTabBarDirective {
    constructor(el) {
        this.el = el;
        this.selectedIndexChange = new EventEmitter();
        this.selectedValueChange = new EventEmitter();
        this.tabBar = this.el.nativeElement;
        Promise.resolve().then(() => {
            this.setEventListeners(el.nativeElement);
        });
    }
    setEventListeners(el) {
        return __awaiter(this, void 0, void 0, function* () {
            el.addEventListener('selected-value-changed', (event) => {
                Promise.resolve().then(() => {
                    this.selectedValueChange.emit(event.detail.value);
                });
            });
            el.addEventListener('selected-index-changed', (event) => {
                Promise.resolve().then(() => {
                    this.selectedIndexChange.emit(event.detail.value);
                });
            });
        });
    }
    setTab(index, value) {
        const tabs = this.tabBar.tabs;
        for (const prop in value) {
            if (value.hasOwnProperty(prop)) {
                tabs[index][prop] = value[prop];
                this.tabBar.notifyPath(`tabs.${index}.${prop}`);
            }
        }
    }
}
AvlTabBarDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlTabBarDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlTabBarDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlTabBarDirective, selector: "avl-tab-bar", outputs: { selectedIndexChange: "selectedIndexChange", selectedValueChange: "selectedValueChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlTabBarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-tab-bar',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { selectedIndexChange: [{
                type: Output
            }], selectedValueChange: [{
                type: Output
            }] } });

class AvlDropdownDirective {
    constructor(elementRef) {
        this.openChanged = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChanged);
    }
}
AvlDropdownDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlDropdownDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlDropdownDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlDropdownDirective, selector: "avl-dropdown", outputs: { openChanged: "openChanged" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlDropdownDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-dropdown'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { openChanged: [{
                type: Output
            }] } });

class AvlTimeDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
}
AvlTimeDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlTimeDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlTimeDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlTimeDirective, selector: "avl-time", outputs: { valueChange: "valueChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlTimeDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-time'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { valueChange: [{
                type: Output
            }] } });

class AvlListDirective extends AvlInteractionControlDirective {
    constructor(elementRef, renderer) {
        super(elementRef);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.invalidChange = new EventEmitter();
        this.overflowMenuItemClicked = new EventEmitter();
        this.rightCheckboxChanged = new EventEmitter();
        this.activeRowChanged = new EventEmitter();
        this.rowReordered = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'invalid-changed', this.focusedChange);
    }
    // Angular writes readonly attributes to a readOnly property,
    // because that's how it's called on the native input element.
    set readonly(value) {
        this.elementRef.nativeElement.readonly = value;
    }
    selectedValueChanged(e) {
        if (this.onChangeCallback && !this.isMulti()) {
            this.onChangeCallback(e.detail.value);
        }
    }
    selectedValuesChanged(e) {
        if (this.onChangeCallback && this.isMulti()) {
            this.onChangeCallback(e.detail.value);
        }
    }
    overflowMenuItemClickListener(e) {
        this.overflowMenuItemClicked.emit(e.detail);
    }
    rightCheckboxChangeListener(e) {
        this.rightCheckboxChanged.emit(e.detail);
    }
    activatedRowChangeListener(e) {
        this.activeRowChanged.emit(e.detail.value);
    }
    rowReorderedListener(e) {
        this.rowReordered.emit(e.detail);
    }
    writeValue(value) {
        const property = this.isMulti() ? 'selectedValues' : 'selectedValue';
        this.renderer.setProperty(this.elementRef.nativeElement, property, value);
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // Since avl-list doesn't have validate-on-leave, there's no touching
    registerOnTouched(fn) { }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    }
    isMulti() {
        return (this.elementRef.nativeElement && this.elementRef.nativeElement.multi === true);
    }
    //#region Validator
    validate(control) {
        const formControl = this.elementRef.nativeElement;
        if (formControl.invalid) {
            return { invalid: formControl.errorMessage };
        }
        else {
            return null;
        }
    }
}
AvlListDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlListDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
AvlListDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlListDirective, selector: "avl-list", inputs: { readonly: "readonly" }, outputs: { invalidChange: "invalidChange", overflowMenuItemClicked: "overflowMenuItemClicked", rightCheckboxChanged: "rightCheckboxChanged", activeRowChanged: "activeRowChanged", rowReordered: "rowReordered" }, host: { listeners: { "selected-value-changed": "selectedValueChanged($event)", "selected-values-changed": "selectedValuesChanged($event)", "overflow-menu-item-clicked": "overflowMenuItemClickListener($event)", "right-checkbox-changed": "rightCheckboxChangeListener($event)", "active-row-changed": "activatedRowChangeListener($event)", "row-reordered": "rowReorderedListener($event)" } }, providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlListDirective), multi: true },
        { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlListDirective), multi: true }], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlListDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-list',
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlListDirective), multi: true },
                        { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlListDirective), multi: true }]
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { invalidChange: [{
                type: Output
            }], overflowMenuItemClicked: [{
                type: Output
            }], rightCheckboxChanged: [{
                type: Output
            }], activeRowChanged: [{
                type: Output
            }], rowReordered: [{
                type: Output
            }], readonly: [{
                type: Input
            }], selectedValueChanged: [{
                type: HostListener,
                args: ['selected-value-changed', ['$event']]
            }], selectedValuesChanged: [{
                type: HostListener,
                args: ['selected-values-changed', ['$event']]
            }], overflowMenuItemClickListener: [{
                type: HostListener,
                args: ['overflow-menu-item-clicked', ['$event']]
            }], rightCheckboxChangeListener: [{
                type: HostListener,
                args: ['right-checkbox-changed', ['$event']]
            }], activatedRowChangeListener: [{
                type: HostListener,
                args: ['active-row-changed', ['$event']]
            }], rowReorderedListener: [{
                type: HostListener,
                args: ['row-reordered', ['$event']]
            }] } });

class AvlContextMenuDirective {
    constructor() {
        this.itemClicked = new EventEmitter();
    }
    itemClickedListener(e) {
        this.itemClicked.emit(e.detail.value);
    }
}
AvlContextMenuDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlContextMenuDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
AvlContextMenuDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlContextMenuDirective, selector: "avl-context-menu", outputs: { itemClicked: "itemClicked" }, host: { listeners: { "item-clicked": "itemClickedListener($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlContextMenuDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-context-menu'
                }]
        }], propDecorators: { itemClicked: [{
                type: Output
            }], itemClickedListener: [{
                type: HostListener,
                args: ['item-clicked', ['$event']]
            }] } });

class AvlNumberfieldDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
}
AvlNumberfieldDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlNumberfieldDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlNumberfieldDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlNumberfieldDirective, selector: "avl-numberfield", outputs: { valueChange: "valueChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlNumberfieldDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-numberfield'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { valueChange: [{
                type: Output
            }] } });

class AvlIconButtonDirective {
    constructor(elementRef) {
        this.badgeChange = new EventEmitter();
        this.badgeValueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'badge-changed', this.badgeChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'badge-value-changed', this.badgeValueChange);
    }
}
AvlIconButtonDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlIconButtonDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlIconButtonDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlIconButtonDirective, selector: "avl-icon-button", outputs: { badgeChange: "badgeChange", badgeValueChange: "badgeValueChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlIconButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-icon-button'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { badgeChange: [{
                type: Output
            }], badgeValueChange: [{
                type: Output
            }] } });

class AvlDatatableDirective {
    constructor(elementRef) {
        this.buttonClick = new EventEmitter();
        this.overflowMenuItemClick = new EventEmitter();
        this.linkClick = new EventEmitter();
        this.pageSizeChange = new EventEmitter();
        this.selectedPageChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'page-size-changed', this.pageSizeChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-page-changed', this.selectedPageChange);
    }
    buttonClickListener(e) {
        this.buttonClick.emit(e.detail);
    }
    overflowMenuItemClickListener(e) {
        this.overflowMenuItemClick.emit(e.detail);
    }
    linkClickListener(e) {
        this.linkClick.emit(e.detail);
    }
}
AvlDatatableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlDatatableDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlDatatableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlDatatableDirective, selector: "avl-datatable", outputs: { buttonClick: "buttonClick", overflowMenuItemClick: "overflowMenuItemClick", linkClick: "linkClick", pageSizeChange: "pageSizeChange", selectedPageChange: "selectedPageChange" }, host: { listeners: { "button-click": "buttonClickListener($event)", "overflow-menu-item-click": "overflowMenuItemClickListener($event)", "link-click": "linkClickListener($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlDatatableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-datatable'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { buttonClick: [{
                type: Output
            }], overflowMenuItemClick: [{
                type: Output
            }], linkClick: [{
                type: Output
            }], pageSizeChange: [{
                type: Output
            }], selectedPageChange: [{
                type: Output
            }], buttonClickListener: [{
                type: HostListener,
                args: ['button-click', ['$event']]
            }], overflowMenuItemClickListener: [{
                type: HostListener,
                args: ['overflow-menu-item-click', ['$event']]
            }], linkClickListener: [{
                type: HostListener,
                args: ['link-click', ['$event']]
            }] } });

class AvlSnackbarDirective {
    constructor() {
        this.buttonClicked = new EventEmitter();
        this.displayedChange = new EventEmitter();
    }
    buttonClickedHandler(e) {
        this.buttonClicked.emit(e.detail.value);
    }
    displayedChangeHandler(e) {
        this.displayedChange.emit(e.detail.value);
    }
}
AvlSnackbarDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlSnackbarDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
AvlSnackbarDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlSnackbarDirective, selector: "avl-snackbar", outputs: { buttonClicked: "buttonClicked", displayedChange: "displayedChange" }, host: { listeners: { "button-clicked": "buttonClickedHandler($event)", "displayed-changed": "displayedChangeHandler($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlSnackbarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-snackbar'
                }]
        }], propDecorators: { buttonClicked: [{
                type: Output
            }], displayedChange: [{
                type: Output
            }], buttonClickedHandler: [{
                type: HostListener,
                args: ['button-clicked', ['$event']]
            }], displayedChangeHandler: [{
                type: HostListener,
                args: ['displayed-changed', ['$event']]
            }] } });

class AvlStepProgressDirective {
    constructor(elementRef) {
        this.activeChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'active-changed', this.activeChange);
    }
}
AvlStepProgressDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlStepProgressDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlStepProgressDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlStepProgressDirective, selector: "avl-step-progress", outputs: { activeChange: "activeChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlStepProgressDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-step-progress'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { activeChange: [{
                type: Output
            }] } });

/** Directive for controls implementing [AvlCheckableControl]. */
class AvlCheckableControlDirective {
    constructor(elementRef) {
        this.checkedChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'checked-changed', this.checkedChange);
    }
}
AvlCheckableControlDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlCheckableControlDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlCheckableControlDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlCheckableControlDirective, selector: "avl-checkbox,avl-radio-button, avl-icon-toggle, avl-switch", outputs: { checkedChange: "checkedChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlCheckableControlDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-checkbox,avl-radio-button, avl-icon-toggle, avl-switch'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { checkedChange: [{
                type: Output
            }] } });

/** Directive for controls implementing [AvlMultiSelectControl]. */
class AvlMultiSelectControlDirective {
    constructor(elementRef) {
        this.selectedIndexesChange = new EventEmitter();
        this.selectedValuesChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-indexes-changed', this.selectedIndexesChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-values-changed', this.selectedValuesChange);
    }
}
AvlMultiSelectControlDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlMultiSelectControlDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlMultiSelectControlDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlMultiSelectControlDirective, selector: "avl-datatable,avl-list,avl-chip-list, avl-chip-input", outputs: { selectedIndexesChange: "selectedIndexesChange", selectedValuesChange: "selectedValuesChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlMultiSelectControlDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-datatable,avl-list,avl-chip-list, avl-chip-input'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { selectedIndexesChange: [{
                type: Output
            }], selectedValuesChange: [{
                type: Output
            }] } });

/** Directive for controls implementing [AvlSingleSelectControl]. */
class AvlSingleSelectControlDirective {
    constructor(elementRef) {
        this.selectedIndexChange = new EventEmitter();
        this.selectedValueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-index-changed', this.selectedIndexChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-value-changed', this.selectedValueChange);
    }
}
AvlSingleSelectControlDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlSingleSelectControlDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AvlSingleSelectControlDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlSingleSelectControlDirective, selector: "avl-datatable,avl-dropdown,avl-list,avl-radio-group,avl-app-switcher,avl-chip-list,avl-combo-box", outputs: { selectedIndexChange: "selectedIndexChange", selectedValueChange: "selectedValueChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlSingleSelectControlDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-datatable,avl-dropdown,avl-list,avl-radio-group,avl-app-switcher,avl-chip-list,avl-combo-box'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { selectedIndexChange: [{
                type: Output
            }], selectedValueChange: [{
                type: Output
            }] } });

// Defines which property is used as the 'value' for the ControlValueAccessor
const valuePropertyNameMap = {
    // TODO: is there a nameof function is typescript?
    'avl-checkbox': 'checked',
    'avl-date': 'value',
    'avl-dropdown': 'selectedValue',
    'avl-time': 'value',
    'avl-numberfield': 'value',
    'avl-radio-group': 'selectedValue',
    'avl-slider': 'value',
    'avl-textarea': 'value',
    'avl-textfield': 'value',
    'avl-timespan': 'value',
    'avl-chip-list': 'selectedValue',
    'avl-chip-input': 'selectedValues',
    'avl-upload': 'files',
    'avl-search-bar': 'query',
    'avl-icon-toggle': 'checked',
    'avl-switch': 'checked'
};
/** Directive for controls implementing [AvlFormControl]. */
class AvlFormControlDirective extends AvlInteractionControlDirective {
    constructor(elementRef, renderer) {
        super(elementRef);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.writeValueAlreadyCalled = false;
        //#endregion
        //#region AvlFormControl
        // tslint:disable-next-line:member-ordering
        this.invalidChange = new EventEmitter();
        const controlTag = this.elementRef.nativeElement.tagName.toLowerCase();
        this.valuePropertyName = valuePropertyNameMap[controlTag];
    }
    // Angular writes readonly attributes to a readOnly property,
    // because that's how it's called on the native input element.
    set readonly(value) {
        if (typeof value === 'boolean') {
            this.elementRef.nativeElement.readonly = value;
        }
        else {
            this.elementRef.nativeElement.readonly = value != null;
        }
    }
    ngOnInit() {
        this.unlistenPropertyChangedEvent =
            this.renderer.listen(this.elementRef.nativeElement, `${this.toKebabCase(this.valuePropertyName)}-changed`, (e) => {
                if (this.onChangeCallback) {
                    this.onChangeCallback(e.detail.value);
                }
            });
    }
    ngOnDestroy() {
        if (this.unlistenPropertyChangedEvent) {
            this.unlistenPropertyChangedEvent();
        }
    }
    writeValue(value) {
        // Because of a bug in Angular writeValue sometimes gets called with a null before being called with the real value,
        // so the null is discarded.
        // TODO: remove when issue is fixed: https://github.com/angular/angular/issues/14988
        if (!this.writeValueAlreadyCalled && value == null) {
            this.writeValueAlreadyCalled = true;
            return;
        }
        this.renderer.setProperty(this.elementRef.nativeElement, this.valuePropertyName, value);
        this.writeValueAlreadyCalled = true;
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    }
    onBlur() {
        if (this.onTouchedCallback) {
            this.onTouchedCallback();
        }
    }
    onFocusedChanged(focused) {
        if (!focused && this.onTouchedCallback) {
            this.onTouchedCallback();
        }
    }
    toKebabCase(camelCaseString) {
        return camelCaseString.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    }
    invalidChanged(e) {
        this.invalidChange.emit(e.detail.value);
        // Trigger validation
        if (this.onChangeCallback) {
            this.onChangeCallback(this.elementRef.nativeElement[this.valuePropertyName]);
        }
    }
    //#endregion
    //#region Validator
    validate(control) {
        const formControl = this.elementRef.nativeElement;
        if (formControl.invalid) {
            return { invalid: formControl.errorMessage };
        }
        else {
            return null;
        }
    }
}
AvlFormControlDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlFormControlDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
AvlFormControlDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.4", type: AvlFormControlDirective, selector: "avl-date,avl-dropdown,avl-time,avl-icon-toggle,avl-numberfield,avl-radio-group,avl-slider,avl-textarea,avl-textfield,avl-timespan,avl-checkbox,avl-switch,avl-chip-list,avl-upload,avl-search-bar,avl-chip-input", inputs: { readonly: "readonly" }, outputs: { invalidChange: "invalidChange" }, host: { listeners: { "blur": "onBlur()", "focused-changed": "onFocusedChanged($event.detail.value)", "invalid-changed": "invalidChanged($event)" } }, providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlFormControlDirective), multi: true },
        { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlFormControlDirective), multi: true }], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlFormControlDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'avl-date,avl-dropdown,avl-time,avl-icon-toggle,avl-numberfield,avl-radio-group,avl-slider,avl-textarea,avl-textfield,avl-timespan,avl-checkbox,avl-switch,avl-chip-list,avl-upload,avl-search-bar,avl-chip-input',
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlFormControlDirective), multi: true },
                        { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlFormControlDirective), multi: true }]
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { readonly: [{
                type: Input
            }], onBlur: [{
                type: HostListener,
                args: ['blur']
            }], onFocusedChanged: [{
                type: HostListener,
                args: ['focused-changed', ['$event.detail.value']]
            }], invalidChange: [{
                type: Output
            }], invalidChanged: [{
                type: HostListener,
                args: ['invalid-changed', ['$event']]
            }] } });

const binders = [
    AvlBreadcrumbDirective,
    AvlOverflowMenuDirective,
    AvlSearchBarDirective,
    AvlTextareaDirective,
    AvlDateDirective,
    AvlSideSheetDirective,
    AvlTextfieldDirective,
    AvlTimespanDirective,
    AvlCheckableControlDirective,
    AvlControlDirective,
    AvlFormControlDirective,
    AvlInteractionControlDirective,
    AvlMultiSelectControlDirective,
    AvlSingleSelectControlDirective,
    AvlDropdownDirective,
    AvlTimeDirective,
    AvlListDirective,
    AvlUploadDirective,
    AvlContextMenuDirective,
    AvlNumberfieldDirective,
    AvlCheckboxDirective,
    AvlDatatableDirective,
    AvlComboBoxDirective,
    AvlTabBarDirective,
    AvlSnackbarDirective,
    AvlStepProgressDirective,
    AvlIconButtonDirective,
];
class AvlNgBindersModule {
}
AvlNgBindersModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlNgBindersModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AvlNgBindersModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlNgBindersModule, declarations: [AvlBreadcrumbDirective,
        AvlOverflowMenuDirective,
        AvlSearchBarDirective,
        AvlTextareaDirective,
        AvlDateDirective,
        AvlSideSheetDirective,
        AvlTextfieldDirective,
        AvlTimespanDirective,
        AvlCheckableControlDirective,
        AvlControlDirective,
        AvlFormControlDirective,
        AvlInteractionControlDirective,
        AvlMultiSelectControlDirective,
        AvlSingleSelectControlDirective,
        AvlDropdownDirective,
        AvlTimeDirective,
        AvlListDirective,
        AvlUploadDirective,
        AvlContextMenuDirective,
        AvlNumberfieldDirective,
        AvlCheckboxDirective,
        AvlDatatableDirective,
        AvlComboBoxDirective,
        AvlTabBarDirective,
        AvlSnackbarDirective,
        AvlStepProgressDirective,
        AvlIconButtonDirective], imports: [CommonModule,
        FormsModule], exports: [AvlBreadcrumbDirective,
        AvlOverflowMenuDirective,
        AvlSearchBarDirective,
        AvlTextareaDirective,
        AvlDateDirective,
        AvlSideSheetDirective,
        AvlTextfieldDirective,
        AvlTimespanDirective,
        AvlCheckableControlDirective,
        AvlControlDirective,
        AvlFormControlDirective,
        AvlInteractionControlDirective,
        AvlMultiSelectControlDirective,
        AvlSingleSelectControlDirective,
        AvlDropdownDirective,
        AvlTimeDirective,
        AvlListDirective,
        AvlUploadDirective,
        AvlContextMenuDirective,
        AvlNumberfieldDirective,
        AvlCheckboxDirective,
        AvlDatatableDirective,
        AvlComboBoxDirective,
        AvlTabBarDirective,
        AvlSnackbarDirective,
        AvlStepProgressDirective,
        AvlIconButtonDirective] });
AvlNgBindersModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlNgBindersModule, imports: [[
            CommonModule,
            FormsModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.4", ngImport: i0, type: AvlNgBindersModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule
                    ],
                    declarations: [
                        ...binders
                    ],
                    exports: [
                        ...binders
                    ]
                }]
        }] });

/*
 * Public API Surface of ng-binders
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AvlBreadcrumbDirective, AvlCheckableControlDirective, AvlCheckboxDirective, AvlComboBoxDirective, AvlContextMenuDirective, AvlControlDirective, AvlDatatableDirective, AvlDateDirective, AvlDropdownDirective, AvlFormControlDirective, AvlIconButtonDirective, AvlInteractionControlDirective, AvlListDirective, AvlMultiSelectControlDirective, AvlNgBindersModule, AvlNumberfieldDirective, AvlOverflowMenuDirective, AvlSearchBarDirective, AvlSideSheetDirective, AvlSingleSelectControlDirective, AvlSnackbarDirective, AvlStepProgressDirective, AvlTabBarDirective, AvlTextareaDirective, AvlTextfieldDirective, AvlTimeDirective, AvlTimespanDirective, AvlUploadDirective };
//# sourceMappingURL=avl-controls-ng-binders.js.map
