import { __decorate, __metadata, __awaiter, __param } from 'tslib';
import { EventEmitter, Output, HostListener, Directive, ElementRef, Renderer2, Input, forwardRef, InjectionToken, Inject, Injectable, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS, FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { HttpEventType, HttpClient } from '@angular/common/http';
import { map, catchError } from 'rxjs/operators';
import { of } from 'rxjs';
import { TranslateService } from '@ngx-translate/core';

let AvlBreadcrumbDirective = class AvlBreadcrumbDirective {
    constructor() {
        this.itemClicked = new EventEmitter();
    }
    itemClickedListener(e) {
        this.itemClicked.emit(e.detail.item);
    }
};
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlBreadcrumbDirective.prototype, "itemClicked", void 0);
__decorate([
    HostListener('item-clicked', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlBreadcrumbDirective.prototype, "itemClickedListener", null);
AvlBreadcrumbDirective = __decorate([
    Directive({
        selector: 'avl-breadcrumb'
    })
], AvlBreadcrumbDirective);

/**
 * Maps Polymer 'changed' events to Angular 'change' events so it can be used in 2-way binding.
 * HostListener can't be used because when a polymer control has a default value polymer will emit a changed event
 * which will overwrite the value in the bound angular variable. So the event listener is added after the constructor
 * so the default value changed event will be skipped.
 * TODO: There is still a problem if the bound variable is not set. If the default changed event is skipped the variable
 * will not get the default value so the control and the variable will have missmatching values.
 */
function addEventListenerForEmittingChangedEvents(elementRef, polymerEventName, angularEventEmmiter) {
    return __awaiter(this, void 0, void 0, function* () {
        Promise.resolve().then(() => {
            const nativeElement = elementRef.nativeElement;
            return nativeElement.addEventListener(polymerEventName, (e) => {
                angularEventEmmiter.emit(e.detail.value);
            });
        });
    });
}

let AvlCheckboxDirective = class AvlCheckboxDirective {
    constructor(elementRef) {
        this.indeterminateChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'indeterminate-changed', this.indeterminateChange);
    }
};
AvlCheckboxDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlCheckboxDirective.prototype, "indeterminateChange", void 0);
AvlCheckboxDirective = __decorate([
    Directive({
        selector: 'avl-checkbox'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlCheckboxDirective);

/** Directive for controls implementing [AvlControl]. */
let AvlControlDirective = class AvlControlDirective {
    constructor(elementRef) {
        this.disabledChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'disabled-changed', this.disabledChange);
    }
};
AvlControlDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlControlDirective.prototype, "disabledChange", void 0);
AvlControlDirective = __decorate([
    Directive({
        selector: 'avl-breadcrumb,avl-context-menu,avl-header-bar,avl-menu-button,avl-user-info'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlControlDirective);

/** Directive for controls implementing [AvlInteractionControl]. */
let AvlInteractionControlDirective = class AvlInteractionControlDirective extends AvlControlDirective {
    constructor(elementRef) {
        super(elementRef);
        this.focusedChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'focused-changed', this.focusedChange);
    }
};
AvlInteractionControlDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlInteractionControlDirective.prototype, "focusedChange", void 0);
AvlInteractionControlDirective = __decorate([
    Directive({
        selector: 'avl-button,avl-icon-button,avl-item,avl-search-bar,avl-radio-button,avl-upload,avl-snackbar'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlInteractionControlDirective);

var AvlComboBoxDirective_1;
let AvlComboBoxDirective = AvlComboBoxDirective_1 = class AvlComboBoxDirective extends AvlInteractionControlDirective {
    constructor(elementRef, renderer) {
        super(elementRef);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.invalidChange = new EventEmitter();
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'invalid-changed', this.focusedChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
    // Angular writes readonly attributes to a readOnly property,
    // because that's how it's called on the native input element.
    set readonly(value) {
        this.elementRef.nativeElement.readonly = value;
    }
    valueChanged(e) {
        if (this.onChangeCallback && this.isAllowNewValues()) {
            this.onChangeCallback(e.detail.value);
        }
    }
    selectedValueChanged(e) {
        if (this.onChangeCallback && !this.isAllowNewValues()) {
            this.onChangeCallback(e.detail.value);
        }
    }
    writeValue(value) {
        const property = this.isAllowNewValues() ? 'value' : 'selectedValue';
        this.renderer.setProperty(this.elementRef.nativeElement, property, value);
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // Since avl-combo-box doesn't have validate-on-leave, there's no touching
    registerOnTouched(fn) { }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    }
    isAllowNewValues() {
        return (this.elementRef.nativeElement && this.elementRef.nativeElement.allowNewValues === true);
    }
    //#region Validator
    validate(control) {
        const formControl = this.elementRef.nativeElement;
        if (formControl.invalid) {
            return { invalid: formControl.errorMessage };
        }
        else {
            return null;
        }
    }
};
AvlComboBoxDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlComboBoxDirective.prototype, "invalidChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlComboBoxDirective.prototype, "valueChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], AvlComboBoxDirective.prototype, "readonly", null);
__decorate([
    HostListener('value-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlComboBoxDirective.prototype, "valueChanged", null);
__decorate([
    HostListener('selected-value-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlComboBoxDirective.prototype, "selectedValueChanged", null);
AvlComboBoxDirective = AvlComboBoxDirective_1 = __decorate([
    Directive({
        selector: 'avl-combo-box',
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlComboBoxDirective_1), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlComboBoxDirective_1), multi: true }]
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], AvlComboBoxDirective);

let AvlOverflowMenuDirective = class AvlOverflowMenuDirective {
    constructor(elementRef) {
        this.itemClicked = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'item-clicked', this.itemClicked);
    }
};
AvlOverflowMenuDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlOverflowMenuDirective.prototype, "itemClicked", void 0);
AvlOverflowMenuDirective = __decorate([
    Directive({
        selector: 'avl-overflow-menu'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlOverflowMenuDirective);

let AvlSearchBarDirective = class AvlSearchBarDirective {
    constructor(elementRef) {
        this.queryChange = new EventEmitter();
        this.openChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'query-changed', this.queryChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChange);
    }
};
AvlSearchBarDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlSearchBarDirective.prototype, "queryChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlSearchBarDirective.prototype, "openChange", void 0);
AvlSearchBarDirective = __decorate([
    Directive({
        selector: 'avl-search-bar'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlSearchBarDirective);

let AvlTextareaDirective = class AvlTextareaDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
};
AvlTextareaDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlTextareaDirective.prototype, "valueChange", void 0);
AvlTextareaDirective = __decorate([
    Directive({
        selector: 'avl-textarea'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlTextareaDirective);

let AvlDateDirective = class AvlDateDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
};
AvlDateDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlDateDirective.prototype, "valueChange", void 0);
AvlDateDirective = __decorate([
    Directive({
        selector: 'avl-date'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlDateDirective);

let AvlSideSheetDirective = class AvlSideSheetDirective {
    constructor(elementRef) {
        this.openChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChange);
    }
};
AvlSideSheetDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlSideSheetDirective.prototype, "openChange", void 0);
AvlSideSheetDirective = __decorate([
    Directive({
        selector: 'avl-side-sheet'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlSideSheetDirective);

let AvlTextfieldDirective = class AvlTextfieldDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
};
AvlTextfieldDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlTextfieldDirective.prototype, "valueChange", void 0);
AvlTextfieldDirective = __decorate([
    Directive({
        selector: 'avl-textfield'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlTextfieldDirective);

let AvlTimespanDirective = class AvlTimespanDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
};
AvlTimespanDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlTimespanDirective.prototype, "valueChange", void 0);
AvlTimespanDirective = __decorate([
    Directive({
        selector: 'avl-timespan'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlTimespanDirective);

const UPLOAD_SERVICE = new InjectionToken('UPLOAD_SERVICE');

let AvlUploadDirective = class AvlUploadDirective {
    constructor(element, uploadService) {
        this.element = element;
        this.uploadService = uploadService;
        this.uploadComplete = new EventEmitter();
        this.uploadAbort = new EventEmitter();
        this.uploadFail = new EventEmitter();
        this.uploadStart = new EventEmitter();
        this.filesChanged = new EventEmitter();
        this.fileRejected = new EventEmitter();
        this.menuItemClicked = new EventEmitter();
        this.downloadFail = new EventEmitter();
        this.downloadAbort = new EventEmitter();
    }
    ngOnInit() {
        const element = this.element.nativeElement;
        element.uploadService = this.uploadService;
    }
    uploadCompleteHandler(e) {
        this.uploadComplete.emit(e.detail.value);
    }
    uploadCanceledHandler(e) {
        this.uploadAbort.emit(e.detail.value);
    }
    uploadStartedHandler(e) {
        this.uploadStart.emit(e.detail.value);
    }
    uploadFailedHandler(e) {
        this.uploadFail.emit(e.detail);
    }
    filesChangedHandler(e) {
        this.filesChanged.emit(e.detail.value);
    }
    fileRejectedHandler(e) {
        this.fileRejected.emit(e.detail.value);
    }
    menuItemClickedHandler(e) {
        this.menuItemClicked.emit(e.detail);
    }
    downloadFailedHandler(e) {
        this.downloadFail.emit(e.detail);
    }
    downloadCanceledHandler(e) {
        this.downloadAbort.emit(e.detail.value);
    }
};
AvlUploadDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [UPLOAD_SERVICE,] }] }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "uploadComplete", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "uploadAbort", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "uploadFail", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "uploadStart", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "filesChanged", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "fileRejected", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "menuItemClicked", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "downloadFail", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlUploadDirective.prototype, "downloadAbort", void 0);
__decorate([
    HostListener('upload-complete', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "uploadCompleteHandler", null);
__decorate([
    HostListener('upload-abort', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "uploadCanceledHandler", null);
__decorate([
    HostListener('upload-start', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "uploadStartedHandler", null);
__decorate([
    HostListener('upload-fail', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "uploadFailedHandler", null);
__decorate([
    HostListener('files-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "filesChangedHandler", null);
__decorate([
    HostListener('file-rejected', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "fileRejectedHandler", null);
__decorate([
    HostListener('menu-item-clicked', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "menuItemClickedHandler", null);
__decorate([
    HostListener('download-fail', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "downloadFailedHandler", null);
__decorate([
    HostListener('download-abort', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlUploadDirective.prototype, "downloadCanceledHandler", null);
AvlUploadDirective = __decorate([
    Directive({
        selector: 'avl-upload',
    }),
    __param(1, Inject(UPLOAD_SERVICE)),
    __metadata("design:paramtypes", [ElementRef, Object])
], AvlUploadDirective);

let AvlTabBarDirective = class AvlTabBarDirective {
    constructor(el) {
        this.el = el;
        this.selectedIndexChange = new EventEmitter();
        this.selectedValueChange = new EventEmitter();
        this.tabBar = this.el.nativeElement;
        Promise.resolve().then(() => {
            this.setEventListeners(el.nativeElement);
        });
    }
    setEventListeners(el) {
        return __awaiter(this, void 0, void 0, function* () {
            el.addEventListener('selected-value-changed', (event) => {
                Promise.resolve().then(() => {
                    this.selectedValueChange.emit(event.detail.value);
                });
            });
            el.addEventListener('selected-index-changed', (event) => {
                Promise.resolve().then(() => {
                    this.selectedIndexChange.emit(event.detail.value);
                });
            });
        });
    }
    setTab(index, value) {
        const tabs = this.tabBar.tabs;
        for (const prop in value) {
            if (value.hasOwnProperty(prop)) {
                tabs[index][prop] = value[prop];
                this.tabBar.notifyPath(`tabs.${index}.${prop}`);
            }
        }
    }
};
AvlTabBarDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlTabBarDirective.prototype, "selectedIndexChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlTabBarDirective.prototype, "selectedValueChange", void 0);
AvlTabBarDirective = __decorate([
    Directive({
        selector: 'avl-tab-bar',
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlTabBarDirective);

let AvlDropdownDirective = class AvlDropdownDirective {
    constructor(elementRef) {
        this.openChanged = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChanged);
    }
};
AvlDropdownDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlDropdownDirective.prototype, "openChanged", void 0);
AvlDropdownDirective = __decorate([
    Directive({
        selector: 'avl-dropdown'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlDropdownDirective);

let AvlTimeDirective = class AvlTimeDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
};
AvlTimeDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlTimeDirective.prototype, "valueChange", void 0);
AvlTimeDirective = __decorate([
    Directive({
        selector: 'avl-time'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlTimeDirective);

var AvlListDirective_1;
let AvlListDirective = AvlListDirective_1 = class AvlListDirective extends AvlInteractionControlDirective {
    constructor(elementRef, renderer) {
        super(elementRef);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.invalidChange = new EventEmitter();
        this.overflowMenuItemClicked = new EventEmitter();
        this.rightCheckboxChanged = new EventEmitter();
        this.activeRowChanged = new EventEmitter();
        this.rowReordered = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'invalid-changed', this.focusedChange);
    }
    // Angular writes readonly attributes to a readOnly property,
    // because that's how it's called on the native input element.
    set readonly(value) {
        this.elementRef.nativeElement.readonly = value;
    }
    selectedValueChanged(e) {
        if (this.onChangeCallback && !this.isMulti()) {
            this.onChangeCallback(e.detail.value);
        }
    }
    selectedValuesChanged(e) {
        if (this.onChangeCallback && this.isMulti()) {
            this.onChangeCallback(e.detail.value);
        }
    }
    overflowMenuItemClickListener(e) {
        this.overflowMenuItemClicked.emit(e.detail);
    }
    rightCheckboxChangeListener(e) {
        this.rightCheckboxChanged.emit(e.detail);
    }
    activatedRowChangeListener(e) {
        this.activeRowChanged.emit(e.detail.value);
    }
    rowReorderedListener(e) {
        this.rowReordered.emit(e.detail);
    }
    writeValue(value) {
        const property = this.isMulti() ? 'selectedValues' : 'selectedValue';
        this.renderer.setProperty(this.elementRef.nativeElement, property, value);
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // Since avl-list doesn't have validate-on-leave, there's no touching
    registerOnTouched(fn) { }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    }
    isMulti() {
        return (this.elementRef.nativeElement && this.elementRef.nativeElement.multi === true);
    }
    //#region Validator
    validate(control) {
        const formControl = this.elementRef.nativeElement;
        if (formControl.invalid) {
            return { invalid: formControl.errorMessage };
        }
        else {
            return null;
        }
    }
};
AvlListDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlListDirective.prototype, "invalidChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlListDirective.prototype, "overflowMenuItemClicked", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlListDirective.prototype, "rightCheckboxChanged", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlListDirective.prototype, "activeRowChanged", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlListDirective.prototype, "rowReordered", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], AvlListDirective.prototype, "readonly", null);
__decorate([
    HostListener('selected-value-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlListDirective.prototype, "selectedValueChanged", null);
__decorate([
    HostListener('selected-values-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlListDirective.prototype, "selectedValuesChanged", null);
__decorate([
    HostListener('overflow-menu-item-clicked', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlListDirective.prototype, "overflowMenuItemClickListener", null);
__decorate([
    HostListener('right-checkbox-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlListDirective.prototype, "rightCheckboxChangeListener", null);
__decorate([
    HostListener('active-row-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlListDirective.prototype, "activatedRowChangeListener", null);
__decorate([
    HostListener('row-reordered', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlListDirective.prototype, "rowReorderedListener", null);
AvlListDirective = AvlListDirective_1 = __decorate([
    Directive({
        selector: 'avl-list',
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlListDirective_1), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlListDirective_1), multi: true }]
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], AvlListDirective);

let AvlContextMenuDirective = class AvlContextMenuDirective {
    constructor() {
        this.itemClicked = new EventEmitter();
    }
    itemClickedListener(e) {
        this.itemClicked.emit(e.detail.value);
    }
};
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlContextMenuDirective.prototype, "itemClicked", void 0);
__decorate([
    HostListener('item-clicked', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlContextMenuDirective.prototype, "itemClickedListener", null);
AvlContextMenuDirective = __decorate([
    Directive({
        selector: 'avl-context-menu'
    })
], AvlContextMenuDirective);

let AvlNumberfieldDirective = class AvlNumberfieldDirective {
    constructor(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
};
AvlNumberfieldDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlNumberfieldDirective.prototype, "valueChange", void 0);
AvlNumberfieldDirective = __decorate([
    Directive({
        selector: 'avl-numberfield'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlNumberfieldDirective);

let AvlIconButtonDirective = class AvlIconButtonDirective {
    constructor(elementRef) {
        this.badgeChange = new EventEmitter();
        this.badgeValueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'badge-changed', this.badgeChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'badge-value-changed', this.badgeValueChange);
    }
};
AvlIconButtonDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlIconButtonDirective.prototype, "badgeChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlIconButtonDirective.prototype, "badgeValueChange", void 0);
AvlIconButtonDirective = __decorate([
    Directive({
        selector: 'avl-icon-button'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlIconButtonDirective);

let AvlDatatableDirective = class AvlDatatableDirective {
    constructor(elementRef) {
        this.buttonClick = new EventEmitter();
        this.overflowMenuItemClick = new EventEmitter();
        this.linkClick = new EventEmitter();
        this.pageSizeChange = new EventEmitter();
        this.selectedPageChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'page-size-changed', this.pageSizeChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-page-changed', this.selectedPageChange);
    }
    buttonClickListener(e) {
        this.buttonClick.emit(e.detail);
    }
    overflowMenuItemClickListener(e) {
        this.overflowMenuItemClick.emit(e.detail);
    }
    linkClickListener(e) {
        this.linkClick.emit(e.detail);
    }
};
AvlDatatableDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlDatatableDirective.prototype, "buttonClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlDatatableDirective.prototype, "overflowMenuItemClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlDatatableDirective.prototype, "linkClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlDatatableDirective.prototype, "pageSizeChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlDatatableDirective.prototype, "selectedPageChange", void 0);
__decorate([
    HostListener('button-click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlDatatableDirective.prototype, "buttonClickListener", null);
__decorate([
    HostListener('overflow-menu-item-click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlDatatableDirective.prototype, "overflowMenuItemClickListener", null);
__decorate([
    HostListener('link-click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlDatatableDirective.prototype, "linkClickListener", null);
AvlDatatableDirective = __decorate([
    Directive({
        selector: 'avl-datatable'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlDatatableDirective);

let AvlSnackbarDirective = class AvlSnackbarDirective {
    constructor() {
        this.buttonClicked = new EventEmitter();
        this.displayedChange = new EventEmitter();
    }
    buttonClickedHandler(e) {
        this.buttonClicked.emit(e.detail.value);
    }
    displayedChangeHandler(e) {
        this.displayedChange.emit(e.detail.value);
    }
};
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlSnackbarDirective.prototype, "buttonClicked", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlSnackbarDirective.prototype, "displayedChange", void 0);
__decorate([
    HostListener('button-clicked', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlSnackbarDirective.prototype, "buttonClickedHandler", null);
__decorate([
    HostListener('displayed-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlSnackbarDirective.prototype, "displayedChangeHandler", null);
AvlSnackbarDirective = __decorate([
    Directive({
        selector: 'avl-snackbar'
    })
], AvlSnackbarDirective);

/** Directive for controls implementing [AvlCheckableControl]. */
let AvlCheckableControlDirective = class AvlCheckableControlDirective {
    constructor(elementRef) {
        this.checkedChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'checked-changed', this.checkedChange);
    }
};
AvlCheckableControlDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlCheckableControlDirective.prototype, "checkedChange", void 0);
AvlCheckableControlDirective = __decorate([
    Directive({
        selector: 'avl-checkbox,avl-radio-button, avl-icon-toggle, avl-switch'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlCheckableControlDirective);

/** Directive for controls implementing [AvlMultiSelectControl]. */
let AvlMultiSelectControlDirective = class AvlMultiSelectControlDirective {
    constructor(elementRef) {
        this.selectedIndexesChange = new EventEmitter();
        this.selectedValuesChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-indexes-changed', this.selectedIndexesChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-values-changed', this.selectedValuesChange);
    }
};
AvlMultiSelectControlDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlMultiSelectControlDirective.prototype, "selectedIndexesChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlMultiSelectControlDirective.prototype, "selectedValuesChange", void 0);
AvlMultiSelectControlDirective = __decorate([
    Directive({
        selector: 'avl-datatable,avl-list,avl-chip-list, avl-chip-input'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlMultiSelectControlDirective);

/** Directive for controls implementing [AvlSingleSelectControl]. */
let AvlSingleSelectControlDirective = class AvlSingleSelectControlDirective {
    constructor(elementRef) {
        this.selectedIndexChange = new EventEmitter();
        this.selectedValueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-index-changed', this.selectedIndexChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-value-changed', this.selectedValueChange);
    }
};
AvlSingleSelectControlDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlSingleSelectControlDirective.prototype, "selectedIndexChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlSingleSelectControlDirective.prototype, "selectedValueChange", void 0);
AvlSingleSelectControlDirective = __decorate([
    Directive({
        selector: 'avl-datatable,avl-dropdown,avl-list,avl-radio-group,avl-app-switcher,avl-chip-list,avl-combo-box'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlSingleSelectControlDirective);

var AvlFormControlDirective_1;
// Defines which property is used as the 'value' for the ControlValueAccessor
const valuePropertyNameMap = {
    // TODO: is there a nameof function is typescript?
    'avl-checkbox': 'checked',
    'avl-date': 'value',
    'avl-dropdown': 'selectedValue',
    'avl-time': 'value',
    'avl-numberfield': 'value',
    'avl-radio-group': 'selectedValue',
    'avl-slider': 'value',
    'avl-textarea': 'value',
    'avl-textfield': 'value',
    'avl-timespan': 'value',
    'avl-chip-list': 'selectedValue',
    'avl-chip-input': 'selectedValues',
    'avl-upload': 'files',
    'avl-search-bar': 'query',
    'avl-icon-toggle': 'checked',
    'avl-switch': 'checked'
};
/** Directive for controls implementing [AvlFormControl]. */
let AvlFormControlDirective = AvlFormControlDirective_1 = class AvlFormControlDirective extends AvlInteractionControlDirective {
    constructor(elementRef, renderer) {
        super(elementRef);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.writeValueAlreadyCalled = false;
        //#endregion
        //#region AvlFormControl
        // tslint:disable-next-line:member-ordering
        this.invalidChange = new EventEmitter();
        const controlTag = this.elementRef.nativeElement.tagName.toLowerCase();
        this.valuePropertyName = valuePropertyNameMap[controlTag];
    }
    // Angular writes readonly attributes to a readOnly property,
    // because that's how it's called on the native input element.
    set readonly(value) {
        if (typeof value === 'boolean') {
            this.elementRef.nativeElement.readonly = value;
        }
        else {
            this.elementRef.nativeElement.readonly = value != null;
        }
    }
    ngOnInit() {
        this.unlistenPropertyChangedEvent =
            this.renderer.listen(this.elementRef.nativeElement, `${this.toKebabCase(this.valuePropertyName)}-changed`, (e) => {
                if (this.onChangeCallback) {
                    this.onChangeCallback(e.detail.value);
                }
            });
    }
    ngOnDestroy() {
        if (this.unlistenPropertyChangedEvent) {
            this.unlistenPropertyChangedEvent();
        }
    }
    writeValue(value) {
        // Because of a bug in Angular writeValue sometimes gets called with a null before being called with the real value,
        // so the null is discarded.
        // TODO: remove when issue is fixed: https://github.com/angular/angular/issues/14988
        if (!this.writeValueAlreadyCalled && value == null) {
            this.writeValueAlreadyCalled = true;
            return;
        }
        this.renderer.setProperty(this.elementRef.nativeElement, this.valuePropertyName, value);
        this.writeValueAlreadyCalled = true;
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    }
    onBlur() {
        if (this.onTouchedCallback) {
            this.onTouchedCallback();
        }
    }
    onFocusedChanged(focused) {
        if (!focused && this.onTouchedCallback) {
            this.onTouchedCallback();
        }
    }
    toKebabCase(camelCaseString) {
        return camelCaseString.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    }
    invalidChanged(e) {
        this.invalidChange.emit(e.detail.value);
        // Trigger validation
        if (this.onChangeCallback) {
            this.onChangeCallback(this.elementRef.nativeElement[this.valuePropertyName]);
        }
    }
    //#endregion
    //#region Validator
    validate(control) {
        const formControl = this.elementRef.nativeElement;
        if (formControl.invalid) {
            return { invalid: formControl.errorMessage };
        }
        else {
            return null;
        }
    }
};
AvlFormControlDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], AvlFormControlDirective.prototype, "readonly", null);
__decorate([
    HostListener('blur'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], AvlFormControlDirective.prototype, "onBlur", null);
__decorate([
    HostListener('focused-changed', ['$event.detail.value']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], AvlFormControlDirective.prototype, "onFocusedChanged", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlFormControlDirective.prototype, "invalidChange", void 0);
__decorate([
    HostListener('invalid-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlFormControlDirective.prototype, "invalidChanged", null);
AvlFormControlDirective = AvlFormControlDirective_1 = __decorate([
    Directive({
        selector: 'avl-date,avl-dropdown,avl-time,avl-icon-toggle,avl-numberfield,avl-radio-group,avl-slider,avl-textarea,avl-textfield,avl-timespan,avl-checkbox,avl-switch,avl-chip-list,avl-upload,avl-search-bar,avl-chip-input',
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlFormControlDirective_1), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlFormControlDirective_1), multi: true }]
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], AvlFormControlDirective);

let UploadService = class UploadService {
    constructor(httpClient) {
        this.httpClient = httpClient;
    }
    downloadFile(url, progressCallback, completeCallback, failCallback) {
        const req = this.httpClient.get(url, { reportProgress: true, responseType: "blob", observe: 'events' })
            .pipe(map(event => {
            if (event.type === HttpEventType.DownloadProgress) {
                progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback(event);
            }
            if (event.type === HttpEventType.Response && event.body != null) {
                completeCallback === null || completeCallback === void 0 ? void 0 : completeCallback(event.body);
            }
        }), catchError((err) => {
            const response = err.error instanceof Event ? err.error.target.response : err.error;
            if (failCallback)
                failCallback({
                    status: err.status,
                    response: response
                });
            return of(null);
        }));
        const subscription = req.subscribe();
        return subscription.unsubscribe.bind(subscription);
    }
    uploadFile(file, target, progressCallback, completeCallback, failCallback) {
        const formData = new FormData();
        formData.append('file', file.file);
        const uploadReq = this.httpClient.post(target, formData, { reportProgress: true, observe: 'events' })
            .pipe(map(event => {
            if (event.type === HttpEventType.UploadProgress) {
                progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback(event);
            }
            if (event.type === HttpEventType.Response) {
                if (event.body != null && event.body.downloadUrl) {
                    completeCallback === null || completeCallback === void 0 ? void 0 : completeCallback(event.body.downloadUrl);
                }
                else {
                    completeCallback === null || completeCallback === void 0 ? void 0 : completeCallback();
                }
            }
        }), catchError((err, caught) => {
            const response = err.error instanceof Event ? err.error.target.response : err.error;
            if (failCallback)
                failCallback({
                    status: err.status,
                    response: response
                });
            return of(null);
        }));
        const subscription = uploadReq.subscribe();
        return subscription.unsubscribe.bind(subscription);
    }
};
UploadService.ctorParameters = () => [
    { type: HttpClient }
];
UploadService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [HttpClient])
], UploadService);

let AvlStepProgressDirective = class AvlStepProgressDirective {
    constructor(elementRef) {
        this.activeChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'active-changed', this.activeChange);
    }
};
AvlStepProgressDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlStepProgressDirective.prototype, "activeChange", void 0);
AvlStepProgressDirective = __decorate([
    Directive({
        selector: 'avl-step-progress'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlStepProgressDirective);

const binders = [
    AvlBreadcrumbDirective,
    AvlOverflowMenuDirective,
    AvlSearchBarDirective,
    AvlTextareaDirective,
    AvlDateDirective,
    AvlSideSheetDirective,
    AvlTextfieldDirective,
    AvlTimespanDirective,
    AvlCheckableControlDirective,
    AvlControlDirective,
    AvlFormControlDirective,
    AvlInteractionControlDirective,
    AvlMultiSelectControlDirective,
    AvlSingleSelectControlDirective,
    AvlDropdownDirective,
    AvlTimeDirective,
    AvlListDirective,
    AvlUploadDirective,
    AvlContextMenuDirective,
    AvlNumberfieldDirective,
    AvlCheckboxDirective,
    AvlDatatableDirective,
    AvlComboBoxDirective,
    AvlTabBarDirective,
    AvlSnackbarDirective,
    AvlStepProgressDirective,
    AvlIconButtonDirective,
];
let AvlNgBindersModule = class AvlNgBindersModule {
};
AvlNgBindersModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            FormsModule
        ],
        declarations: [
            ...binders
        ],
        exports: [
            ...binders
        ],
        providers: [
            { provide: UPLOAD_SERVICE, useClass: UploadService }
        ]
    })
], AvlNgBindersModule);

let NgxTranslateTranslationService = class NgxTranslateTranslationService {
    constructor(translateService) {
        this.translateService = translateService;
    }
    get language() {
        return this.translateService.currentLang;
    }
    translate(key, interpolateParams) {
        return this.translateService.get(key, interpolateParams).toPromise();
    }
};
NgxTranslateTranslationService.ctorParameters = () => [
    { type: TranslateService }
];
NgxTranslateTranslationService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [TranslateService])
], NgxTranslateTranslationService);

/*
 * Public API Surface of ng-binders
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AvlBreadcrumbDirective, AvlCheckableControlDirective, AvlCheckboxDirective, AvlComboBoxDirective, AvlContextMenuDirective, AvlControlDirective, AvlDatatableDirective, AvlDateDirective, AvlDropdownDirective, AvlFormControlDirective, AvlIconButtonDirective, AvlInteractionControlDirective, AvlListDirective, AvlMultiSelectControlDirective, AvlNgBindersModule, AvlNumberfieldDirective, AvlOverflowMenuDirective, AvlSearchBarDirective, AvlSideSheetDirective, AvlSingleSelectControlDirective, AvlSnackbarDirective, AvlTabBarDirective, AvlTextareaDirective, AvlTextfieldDirective, AvlTimeDirective, AvlTimespanDirective, AvlUploadDirective, NgxTranslateTranslationService, UPLOAD_SERVICE, UploadService, AvlStepProgressDirective as ɵa };
//# sourceMappingURL=avl-controls-ng-binders.js.map
