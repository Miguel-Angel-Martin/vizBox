import { __awaiter, __decorate, __metadata } from "tslib";
import { Directive, ElementRef, Output, EventEmitter } from '@angular/core';
let AvlTabBarDirective = class AvlTabBarDirective {
    constructor(el) {
        this.el = el;
        this.selectedIndexChange = new EventEmitter();
        this.selectedValueChange = new EventEmitter();
        this.tabBar = this.el.nativeElement;
        Promise.resolve().then(() => {
            this.setEventListeners(el.nativeElement);
        });
    }
    setEventListeners(el) {
        return __awaiter(this, void 0, void 0, function* () {
            el.addEventListener('selected-value-changed', (event) => {
                Promise.resolve().then(() => {
                    this.selectedValueChange.emit(event.detail.value);
                });
            });
            el.addEventListener('selected-index-changed', (event) => {
                Promise.resolve().then(() => {
                    this.selectedIndexChange.emit(event.detail.value);
                });
            });
        });
    }
    setTab(index, value) {
        const tabs = this.tabBar.tabs;
        for (const prop in value) {
            if (value.hasOwnProperty(prop)) {
                tabs[index][prop] = value[prop];
                this.tabBar.notifyPath(`tabs.${index}.${prop}`);
            }
        }
    }
};
AvlTabBarDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlTabBarDirective.prototype, "selectedIndexChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlTabBarDirective.prototype, "selectedValueChange", void 0);
AvlTabBarDirective = __decorate([
    Directive({
        selector: 'avl-tab-bar',
    }),
    __metadata("design:paramtypes", [ElementRef])
], AvlTabBarDirective);
export { AvlTabBarDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZsLXRhYi1iYXIuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGF2bC1jb250cm9scy9uZy1iaW5kZXJzLyIsInNvdXJjZXMiOlsibGliL2NvbnRyb2xzL2F2bC10YWItYmFyLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUs1RSxJQUFhLGtCQUFrQixHQUEvQixNQUFhLGtCQUFrQjtJQW1CN0IsWUFBb0IsRUFBYztRQUFkLE9BQUUsR0FBRixFQUFFLENBQVk7UUFsQnhCLHdCQUFtQixHQUF5QixJQUFJLFlBQVksRUFBRSxDQUFDO1FBQy9ELHdCQUFtQixHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO1FBa0JwRSxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDO1FBQ3BDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQzFCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDM0MsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBbEJhLGlCQUFpQixDQUFDLEVBQU87O1lBQ3JDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyx3QkFBd0IsRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFO2dCQUN0RCxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtvQkFDMUIsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNwRCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1lBQ0gsRUFBRSxDQUFDLGdCQUFnQixDQUFDLHdCQUF3QixFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7Z0JBQ3RELE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO29CQUMxQixJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3BELENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDO0tBQUE7SUFTRCxNQUFNLENBQUMsS0FBYSxFQUFFLEtBQWdFO1FBQ3BGLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO1FBQzlCLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO1lBQ3hCLElBQUksS0FBSyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDOUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDaEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxLQUFLLElBQUksSUFBSSxFQUFFLENBQUMsQ0FBQzthQUNqRDtTQUNGO0lBQ0gsQ0FBQztDQUNGLENBQUE7O1lBaEJ5QixVQUFVOztBQWxCeEI7SUFBVCxNQUFNLEVBQUU7OEJBQXNCLFlBQVk7K0RBQThCO0FBQy9EO0lBQVQsTUFBTSxFQUFFOzhCQUFzQixZQUFZOytEQUEyQjtBQUYzRCxrQkFBa0I7SUFIOUIsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLGFBQWE7S0FDeEIsQ0FBQztxQ0FvQndCLFVBQVU7R0FuQnZCLGtCQUFrQixDQW1DOUI7U0FuQ1ksa0JBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdhdmwtdGFiLWJhcicsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBdmxUYWJCYXJEaXJlY3RpdmUge1xyXG4gIEBPdXRwdXQoKSBzZWxlY3RlZEluZGV4Q2hhbmdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICBAT3V0cHV0KCkgc2VsZWN0ZWRWYWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcblxyXG4gIHByaXZhdGUgdGFiQmFyOiBhbnk7XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgc2V0RXZlbnRMaXN0ZW5lcnMoZWw6IGFueSkge1xyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0ZWQtdmFsdWUtY2hhbmdlZCcsIChldmVudCkgPT4ge1xyXG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWVDaGFuZ2UuZW1pdChldmVudC5kZXRhaWwudmFsdWUpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0ZWQtaW5kZXgtY2hhbmdlZCcsIChldmVudCkgPT4ge1xyXG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXhDaGFuZ2UuZW1pdChldmVudC5kZXRhaWwudmFsdWUpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbDogRWxlbWVudFJlZikge1xyXG4gICAgdGhpcy50YWJCYXIgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcclxuICAgICAgdGhpcy5zZXRFdmVudExpc3RlbmVycyhlbC5uYXRpdmVFbGVtZW50KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc2V0VGFiKGluZGV4OiBudW1iZXIsIHZhbHVlOiB7IGxhYmVsOiBzdHJpbmcsIGRpc2FibGVkPzogYm9vbGVhbiwgW2tleTogc3RyaW5nXTogYW55IH0pIHtcclxuICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYkJhci50YWJzO1xyXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHZhbHVlKSB7XHJcbiAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgIHRhYnNbaW5kZXhdW3Byb3BdID0gdmFsdWVbcHJvcF07XHJcbiAgICAgICAgdGhpcy50YWJCYXIubm90aWZ5UGF0aChgdGFicy4ke2luZGV4fS4ke3Byb3B9YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19