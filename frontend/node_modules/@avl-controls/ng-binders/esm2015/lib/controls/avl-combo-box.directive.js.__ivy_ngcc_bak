var AvlComboBoxDirective_1;
import { __decorate, __metadata } from "tslib";
import { Directive, ElementRef, EventEmitter, forwardRef, HostListener, Output, Renderer2, Input } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR } from '@angular/forms';
import { AvlInteractionControlDirective } from '../interface/avl-interaction-control.directive';
import { addEventListenerForEmittingChangedEvents } from '../binding-utils';
let AvlComboBoxDirective = AvlComboBoxDirective_1 = class AvlComboBoxDirective extends AvlInteractionControlDirective {
    constructor(elementRef, renderer) {
        super(elementRef);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.invalidChange = new EventEmitter();
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'invalid-changed', this.focusedChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
    // Angular writes readonly attributes to a readOnly property,
    // because that's how it's called on the native input element.
    set readonly(value) {
        this.elementRef.nativeElement.readonly = value;
    }
    valueChanged(e) {
        if (this.onChangeCallback && this.isAllowNewValues()) {
            this.onChangeCallback(e.detail.value);
        }
    }
    selectedValueChanged(e) {
        if (this.onChangeCallback && !this.isAllowNewValues()) {
            this.onChangeCallback(e.detail.value);
        }
    }
    writeValue(value) {
        const property = this.isAllowNewValues() ? 'value' : 'selectedValue';
        this.renderer.setProperty(this.elementRef.nativeElement, property, value);
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // Since avl-combo-box doesn't have validate-on-leave, there's no touching
    registerOnTouched(fn) { }
    setDisabledState(isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    }
    isAllowNewValues() {
        return (this.elementRef.nativeElement && this.elementRef.nativeElement.allowNewValues === true);
    }
    //#region Validator
    validate(control) {
        const formControl = this.elementRef.nativeElement;
        if (formControl.invalid) {
            return { invalid: formControl.errorMessage };
        }
        else {
            return null;
        }
    }
};
AvlComboBoxDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlComboBoxDirective.prototype, "invalidChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], AvlComboBoxDirective.prototype, "valueChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], AvlComboBoxDirective.prototype, "readonly", null);
__decorate([
    HostListener('value-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlComboBoxDirective.prototype, "valueChanged", null);
__decorate([
    HostListener('selected-value-changed', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CustomEvent]),
    __metadata("design:returntype", void 0)
], AvlComboBoxDirective.prototype, "selectedValueChanged", null);
AvlComboBoxDirective = AvlComboBoxDirective_1 = __decorate([
    Directive({
        selector: 'avl-combo-box',
        providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AvlComboBoxDirective_1), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AvlComboBoxDirective_1), multi: true }]
    }),
    __metadata("design:paramtypes", [ElementRef, Renderer2])
], AvlComboBoxDirective);
export { AvlComboBoxDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZsLWNvbWJvLWJveC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYXZsLWNvbnRyb2xzL25nLWJpbmRlcnMvIiwic291cmNlcyI6WyJsaWIvY29udHJvbHMvYXZsLWNvbWJvLWJveC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4SCxPQUFPLEVBQXlDLGFBQWEsRUFBRSxpQkFBaUIsRUFBK0IsTUFBTSxnQkFBZ0IsQ0FBQztBQUV0SSxPQUFPLEVBQUUsOEJBQThCLEVBQUUsTUFBTSxnREFBZ0QsQ0FBQztBQUNoRyxPQUFPLEVBQUUsd0NBQXdDLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQU81RSxJQUFhLG9CQUFvQiw0QkFBakMsTUFBYSxvQkFBcUIsU0FBUSw4QkFBOEI7SUFNdEUsWUFBb0IsVUFBc0IsRUFBVSxRQUFtQjtRQUNyRSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7UUFEQSxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQVUsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUw3RCxrQkFBYSxHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO1FBQ3RELGdCQUFXLEdBQXNCLElBQUksWUFBWSxFQUFFLENBQUM7UUFNNUQsd0NBQXdDLENBQUMsVUFBVSxFQUFFLGlCQUFpQixFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUM1Rix3Q0FBd0MsQ0FBQyxVQUFVLEVBQUUsZUFBZSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUMxRixDQUFDO0lBRUQsNkRBQTZEO0lBQzdELDhEQUE4RDtJQUU5RCxJQUFXLFFBQVEsQ0FBQyxLQUFjO1FBQ2hDLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLFFBQVEsR0FB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aXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSG9zdExpc3RlbmVyLCBPdXRwdXQsIFJlbmRlcmVyMiwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMSURBVE9SUywgTkdfVkFMVUVfQUNDRVNTT1IsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgQXZsRm9ybUNvbnRyb2wgfSBmcm9tICdAYXZsLWNvbnRyb2xzL2ludGVyZmFjZXMnO1xyXG5pbXBvcnQgeyBBdmxJbnRlcmFjdGlvbkNvbnRyb2xEaXJlY3RpdmUgfSBmcm9tICcuLi9pbnRlcmZhY2UvYXZsLWludGVyYWN0aW9uLWNvbnRyb2wuZGlyZWN0aXZlJztcclxuaW1wb3J0IHsgYWRkRXZlbnRMaXN0ZW5lckZvckVtaXR0aW5nQ2hhbmdlZEV2ZW50cyB9IGZyb20gJy4uL2JpbmRpbmctdXRpbHMnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdhdmwtY29tYm8tYm94JyxcclxuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBBdmxDb21ib0JveERpcmVjdGl2ZSksIG11bHRpOiB0cnVlIH0sXHJcbiAgeyBwcm92aWRlOiBOR19WQUxJREFUT1JTLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBBdmxDb21ib0JveERpcmVjdGl2ZSksIG11bHRpOiB0cnVlIH1dXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBdmxDb21ib0JveERpcmVjdGl2ZSBleHRlbmRzIEF2bEludGVyYWN0aW9uQ29udHJvbERpcmVjdGl2ZSBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3Ige1xyXG4gIEBPdXRwdXQoKSBpbnZhbGlkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICBwcml2YXRlIG9uQ2hhbmdlQ2FsbGJhY2s6ICh2YWx1ZTogYW55KSA9PiB2b2lkO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMikge1xyXG4gICAgc3VwZXIoZWxlbWVudFJlZik7XHJcbiAgICBhZGRFdmVudExpc3RlbmVyRm9yRW1pdHRpbmdDaGFuZ2VkRXZlbnRzKGVsZW1lbnRSZWYsICdpbnZhbGlkLWNoYW5nZWQnLCB0aGlzLmZvY3VzZWRDaGFuZ2UpO1xyXG4gICAgYWRkRXZlbnRMaXN0ZW5lckZvckVtaXR0aW5nQ2hhbmdlZEV2ZW50cyhlbGVtZW50UmVmLCAndmFsdWUtY2hhbmdlZCcsIHRoaXMudmFsdWVDaGFuZ2UpO1xyXG4gIH1cclxuXHJcbiAgLy8gQW5ndWxhciB3cml0ZXMgcmVhZG9ubHkgYXR0cmlidXRlcyB0byBhIHJlYWRPbmx5IHByb3BlcnR5LFxyXG4gIC8vIGJlY2F1c2UgdGhhdCdzIGhvdyBpdCdzIGNhbGxlZCBvbiB0aGUgbmF0aXZlIGlucHV0IGVsZW1lbnQuXHJcbiAgQElucHV0KClcclxuICBwdWJsaWMgc2V0IHJlYWRvbmx5KHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5yZWFkb25seSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgQEhvc3RMaXN0ZW5lcigndmFsdWUtY2hhbmdlZCcsIFsnJGV2ZW50J10pXHJcbiAgdmFsdWVDaGFuZ2VkKGU6IEN1c3RvbUV2ZW50KSB7XHJcbiAgICBpZiAodGhpcy5vbkNoYW5nZUNhbGxiYWNrICYmIHRoaXMuaXNBbGxvd05ld1ZhbHVlcygpKSB7XHJcbiAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayhlLmRldGFpbC52YWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBASG9zdExpc3RlbmVyKCdzZWxlY3RlZC12YWx1ZS1jaGFuZ2VkJywgWyckZXZlbnQnXSlcclxuICBzZWxlY3RlZFZhbHVlQ2hhbmdlZChlOiBDdXN0b21FdmVudCkge1xyXG4gICAgaWYgKHRoaXMub25DaGFuZ2VDYWxsYmFjayAmJiAhdGhpcy5pc0FsbG93TmV3VmFsdWVzKCkpIHtcclxuICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKGUuZGV0YWlsLnZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xyXG4gICAgY29uc3QgcHJvcGVydHkgPSB0aGlzLmlzQWxsb3dOZXdWYWx1ZXMoKSA/ICd2YWx1ZScgOiAnc2VsZWN0ZWRWYWx1ZSc7XHJcbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKHZhbHVlOiBhbnkpID0+IHZvaWQpIHtcclxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGZuO1xyXG4gIH1cclxuXHJcbiAgLy8gU2luY2UgYXZsLWNvbWJvLWJveCBkb2Vzbid0IGhhdmUgdmFsaWRhdGUtb24tbGVhdmUsIHRoZXJlJ3Mgbm8gdG91Y2hpbmdcclxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KSB7IH1cclxuXHJcbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKSB7XHJcbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgaXNBbGxvd05ld1ZhbHVlcygpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgJiYgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuYWxsb3dOZXdWYWx1ZXMgPT09IHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLy8jcmVnaW9uIFZhbGlkYXRvclxyXG4gIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcclxuICAgIGNvbnN0IGZvcm1Db250cm9sID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgYXMgQXZsRm9ybUNvbnRyb2w7XHJcbiAgICBpZiAoZm9ybUNvbnRyb2wuaW52YWxpZCkge1xyXG4gICAgICByZXR1cm4geyBpbnZhbGlkOiBmb3JtQ29udHJvbC5lcnJvck1lc3NhZ2UgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyNlbmRyZWdpb25cclxufVxyXG4iXX0=