import { __decorate, __metadata, __awaiter, __generator, __extends, __param, __spread } from 'tslib';
import { EventEmitter, Output, HostListener, Directive, ElementRef, Renderer2, Input, forwardRef, InjectionToken, Inject, Injectable, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS, FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { HttpEventType, HttpClient } from '@angular/common/http';
import { map, catchError } from 'rxjs/operators';
import { of } from 'rxjs';
import { TranslateService } from '@ngx-translate/core';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common/http';
import * as ɵngcc2 from '@ngx-translate/core';
var AvlBreadcrumbDirective = /** @class */ (function () {
    function AvlBreadcrumbDirective() {
        this.itemClicked = new EventEmitter();
    }
    AvlBreadcrumbDirective.prototype.itemClickedListener = function (e) {
        this.itemClicked.emit(e.detail.item);
    };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlBreadcrumbDirective.prototype, "itemClicked", void 0);
    __decorate([
        HostListener('item-clicked', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlBreadcrumbDirective.prototype, "itemClickedListener", null);
AvlBreadcrumbDirective.ɵfac = function AvlBreadcrumbDirective_Factory(t) { return new (t || AvlBreadcrumbDirective)(); };
AvlBreadcrumbDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlBreadcrumbDirective, selectors: [["avl-breadcrumb"]], hostBindings: function AvlBreadcrumbDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("item-clicked", function AvlBreadcrumbDirective_item_clicked_HostBindingHandler($event) { return ctx.itemClickedListener($event); });
    } }, outputs: { itemClicked: "itemClicked" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlBreadcrumbDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-breadcrumb'
            }]
    }], function () { return []; }, { itemClicked: [{
            type: Output
        }], itemClickedListener: [{
            type: HostListener,
            args: ['item-clicked', ['$event']]
        }] }); })();
    return AvlBreadcrumbDirective;
}());

/**
 * Maps Polymer 'changed' events to Angular 'change' events so it can be used in 2-way binding.
 * HostListener can't be used because when a polymer control has a default value polymer will emit a changed event
 * which will overwrite the value in the bound angular variable. So the event listener is added after the constructor
 * so the default value changed event will be skipped.
 * TODO: There is still a problem if the bound variable is not set. If the default changed event is skipped the variable
 * will not get the default value so the control and the variable will have missmatching values.
 */
function addEventListenerForEmittingChangedEvents(elementRef, polymerEventName, angularEventEmmiter) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            Promise.resolve().then(function () {
                var nativeElement = elementRef.nativeElement;
                return nativeElement.addEventListener(polymerEventName, function (e) {
                    angularEventEmmiter.emit(e.detail.value);
                });
            });
            return [2 /*return*/];
        });
    });
}

var AvlCheckboxDirective = /** @class */ (function () {
    function AvlCheckboxDirective(elementRef) {
        this.indeterminateChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'indeterminate-changed', this.indeterminateChange);
    }
    AvlCheckboxDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlCheckboxDirective.prototype, "indeterminateChange", void 0);
    AvlCheckboxDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlCheckboxDirective);
AvlCheckboxDirective.ɵfac = function AvlCheckboxDirective_Factory(t) { return new (t || AvlCheckboxDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlCheckboxDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlCheckboxDirective, selectors: [["avl-checkbox"]], outputs: { indeterminateChange: "indeterminateChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlCheckboxDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-checkbox'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { indeterminateChange: [{
            type: Output
        }] }); })();
    return AvlCheckboxDirective;
}());

/** Directive for controls implementing [AvlControl]. */
var AvlControlDirective = /** @class */ (function () {
    function AvlControlDirective(elementRef) {
        this.disabledChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'disabled-changed', this.disabledChange);
    }
    AvlControlDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlControlDirective.prototype, "disabledChange", void 0);
    AvlControlDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlControlDirective);
AvlControlDirective.ɵfac = function AvlControlDirective_Factory(t) { return new (t || AvlControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlControlDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlControlDirective, selectors: [["avl-breadcrumb"], ["avl-context-menu"], ["avl-header-bar"], ["avl-menu-button"], ["avl-user-info"]], outputs: { disabledChange: "disabledChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlControlDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-breadcrumb,avl-context-menu,avl-header-bar,avl-menu-button,avl-user-info'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { disabledChange: [{
            type: Output
        }] }); })();
    return AvlControlDirective;
}());

/** Directive for controls implementing [AvlInteractionControl]. */
var AvlInteractionControlDirective = /** @class */ (function (_super) {
    __extends(AvlInteractionControlDirective, _super);
    function AvlInteractionControlDirective(elementRef) {
        var _this = _super.call(this, elementRef) || this;
        _this.focusedChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'focused-changed', _this.focusedChange);
        return _this;
    }
    AvlInteractionControlDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlInteractionControlDirective.prototype, "focusedChange", void 0);
    AvlInteractionControlDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlInteractionControlDirective);
AvlInteractionControlDirective.ɵfac = function AvlInteractionControlDirective_Factory(t) { return new (t || AvlInteractionControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlInteractionControlDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlInteractionControlDirective, selectors: [["avl-button"], ["avl-icon-button"], ["avl-item"], ["avl-search-bar"], ["avl-radio-button"], ["avl-upload"], ["avl-snackbar"]], outputs: { focusedChange: "focusedChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlInteractionControlDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-button,avl-icon-button,avl-item,avl-search-bar,avl-radio-button,avl-upload,avl-snackbar'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { focusedChange: [{
            type: Output
        }] }); })();
    return AvlInteractionControlDirective;
}(AvlControlDirective));

var AvlComboBoxDirective = /** @class */ (function (_super) {
    __extends(AvlComboBoxDirective, _super);
    function AvlComboBoxDirective(elementRef, renderer) {
        var _this = _super.call(this, elementRef) || this;
        _this.elementRef = elementRef;
        _this.renderer = renderer;
        _this.invalidChange = new EventEmitter();
        _this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'invalid-changed', _this.focusedChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', _this.valueChange);
        return _this;
    }
    AvlComboBoxDirective_1 = AvlComboBoxDirective;
    Object.defineProperty(AvlComboBoxDirective.prototype, "readonly", {
        // Angular writes readonly attributes to a readOnly property,
        // because that's how it's called on the native input element.
        set: function (value) {
            this.elementRef.nativeElement.readonly = value;
        },
        enumerable: true,
        configurable: true
    });
    AvlComboBoxDirective.prototype.valueChanged = function (e) {
        if (this.onChangeCallback && this.isAllowNewValues()) {
            this.onChangeCallback(e.detail.value);
        }
    };
    AvlComboBoxDirective.prototype.selectedValueChanged = function (e) {
        if (this.onChangeCallback && !this.isAllowNewValues()) {
            this.onChangeCallback(e.detail.value);
        }
    };
    AvlComboBoxDirective.prototype.writeValue = function (value) {
        var property = this.isAllowNewValues() ? 'value' : 'selectedValue';
        this.renderer.setProperty(this.elementRef.nativeElement, property, value);
    };
    AvlComboBoxDirective.prototype.registerOnChange = function (fn) {
        this.onChangeCallback = fn;
    };
    // Since avl-combo-box doesn't have validate-on-leave, there's no touching
    AvlComboBoxDirective.prototype.registerOnTouched = function (fn) { };
    AvlComboBoxDirective.prototype.setDisabledState = function (isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    };
    AvlComboBoxDirective.prototype.isAllowNewValues = function () {
        return (this.elementRef.nativeElement && this.elementRef.nativeElement.allowNewValues === true);
    };
    //#region Validator
    AvlComboBoxDirective.prototype.validate = function (control) {
        var formControl = this.elementRef.nativeElement;
        if (formControl.invalid) {
            return { invalid: formControl.errorMessage };
        }
        else {
            return null;
        }
    };
    var AvlComboBoxDirective_1;
    AvlComboBoxDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlComboBoxDirective.prototype, "invalidChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlComboBoxDirective.prototype, "valueChange", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], AvlComboBoxDirective.prototype, "readonly", null);
    __decorate([
        HostListener('value-changed', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlComboBoxDirective.prototype, "valueChanged", null);
    __decorate([
        HostListener('selected-value-changed', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlComboBoxDirective.prototype, "selectedValueChanged", null);
    AvlComboBoxDirective = AvlComboBoxDirective_1 = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
    ], AvlComboBoxDirective);
AvlComboBoxDirective.ɵfac = function AvlComboBoxDirective_Factory(t) { return new (t || AvlComboBoxDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
AvlComboBoxDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlComboBoxDirective, selectors: [["avl-combo-box"]], hostBindings: function AvlComboBoxDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("value-changed", function AvlComboBoxDirective_value_changed_HostBindingHandler($event) { return ctx.valueChanged($event); })("selected-value-changed", function AvlComboBoxDirective_selected_value_changed_HostBindingHandler($event) { return ctx.selectedValueChanged($event); });
    } }, inputs: { readonly: "readonly" }, outputs: { invalidChange: "invalidChange", valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return AvlComboBoxDirective_1; }), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(function () { return AvlComboBoxDirective_1; }), multi: true }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlComboBoxDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-combo-box',
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return AvlComboBoxDirective_1; }), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(function () { return AvlComboBoxDirective_1; }), multi: true }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { readonly: [{
            type: Input
        }], valueChanged: [{
            type: HostListener,
            args: ['value-changed', ['$event']]
        }], selectedValueChanged: [{
            type: HostListener,
            args: ['selected-value-changed', ['$event']]
        }], invalidChange: [{
            type: Output
        }], valueChange: [{
            type: Output
        }] }); })();
    return AvlComboBoxDirective;
}(AvlInteractionControlDirective));

var AvlOverflowMenuDirective = /** @class */ (function () {
    function AvlOverflowMenuDirective(elementRef) {
        this.itemClicked = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'item-clicked', this.itemClicked);
    }
    AvlOverflowMenuDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlOverflowMenuDirective.prototype, "itemClicked", void 0);
    AvlOverflowMenuDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlOverflowMenuDirective);
AvlOverflowMenuDirective.ɵfac = function AvlOverflowMenuDirective_Factory(t) { return new (t || AvlOverflowMenuDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlOverflowMenuDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlOverflowMenuDirective, selectors: [["avl-overflow-menu"]], outputs: { itemClicked: "itemClicked" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlOverflowMenuDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-overflow-menu'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { itemClicked: [{
            type: Output
        }] }); })();
    return AvlOverflowMenuDirective;
}());

var AvlSearchBarDirective = /** @class */ (function () {
    function AvlSearchBarDirective(elementRef) {
        this.queryChange = new EventEmitter();
        this.openChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'query-changed', this.queryChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChange);
    }
    AvlSearchBarDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlSearchBarDirective.prototype, "queryChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlSearchBarDirective.prototype, "openChange", void 0);
    AvlSearchBarDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlSearchBarDirective);
AvlSearchBarDirective.ɵfac = function AvlSearchBarDirective_Factory(t) { return new (t || AvlSearchBarDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlSearchBarDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlSearchBarDirective, selectors: [["avl-search-bar"]], outputs: { queryChange: "queryChange", openChange: "openChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlSearchBarDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-search-bar'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { queryChange: [{
            type: Output
        }], openChange: [{
            type: Output
        }] }); })();
    return AvlSearchBarDirective;
}());

var AvlTextareaDirective = /** @class */ (function () {
    function AvlTextareaDirective(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
    AvlTextareaDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlTextareaDirective.prototype, "valueChange", void 0);
    AvlTextareaDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlTextareaDirective);
AvlTextareaDirective.ɵfac = function AvlTextareaDirective_Factory(t) { return new (t || AvlTextareaDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlTextareaDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlTextareaDirective, selectors: [["avl-textarea"]], outputs: { valueChange: "valueChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlTextareaDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-textarea'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { valueChange: [{
            type: Output
        }] }); })();
    return AvlTextareaDirective;
}());

var AvlDateDirective = /** @class */ (function () {
    function AvlDateDirective(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
    AvlDateDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlDateDirective.prototype, "valueChange", void 0);
    AvlDateDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlDateDirective);
AvlDateDirective.ɵfac = function AvlDateDirective_Factory(t) { return new (t || AvlDateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlDateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlDateDirective, selectors: [["avl-date"]], outputs: { valueChange: "valueChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlDateDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-date'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { valueChange: [{
            type: Output
        }] }); })();
    return AvlDateDirective;
}());

var AvlSideSheetDirective = /** @class */ (function () {
    function AvlSideSheetDirective(elementRef) {
        this.openChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChange);
    }
    AvlSideSheetDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlSideSheetDirective.prototype, "openChange", void 0);
    AvlSideSheetDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlSideSheetDirective);
AvlSideSheetDirective.ɵfac = function AvlSideSheetDirective_Factory(t) { return new (t || AvlSideSheetDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlSideSheetDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlSideSheetDirective, selectors: [["avl-side-sheet"]], outputs: { openChange: "openChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlSideSheetDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-side-sheet'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { openChange: [{
            type: Output
        }] }); })();
    return AvlSideSheetDirective;
}());

var AvlTextfieldDirective = /** @class */ (function () {
    function AvlTextfieldDirective(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
    AvlTextfieldDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlTextfieldDirective.prototype, "valueChange", void 0);
    AvlTextfieldDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlTextfieldDirective);
AvlTextfieldDirective.ɵfac = function AvlTextfieldDirective_Factory(t) { return new (t || AvlTextfieldDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlTextfieldDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlTextfieldDirective, selectors: [["avl-textfield"]], outputs: { valueChange: "valueChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlTextfieldDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-textfield'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { valueChange: [{
            type: Output
        }] }); })();
    return AvlTextfieldDirective;
}());

var AvlTimespanDirective = /** @class */ (function () {
    function AvlTimespanDirective(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
    AvlTimespanDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlTimespanDirective.prototype, "valueChange", void 0);
    AvlTimespanDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlTimespanDirective);
AvlTimespanDirective.ɵfac = function AvlTimespanDirective_Factory(t) { return new (t || AvlTimespanDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlTimespanDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlTimespanDirective, selectors: [["avl-timespan"]], outputs: { valueChange: "valueChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlTimespanDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-timespan'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { valueChange: [{
            type: Output
        }] }); })();
    return AvlTimespanDirective;
}());

var UPLOAD_SERVICE = new InjectionToken('UPLOAD_SERVICE');

var AvlUploadDirective = /** @class */ (function () {
    function AvlUploadDirective(element, uploadService) {
        this.element = element;
        this.uploadService = uploadService;
        this.uploadComplete = new EventEmitter();
        this.uploadAbort = new EventEmitter();
        this.uploadFail = new EventEmitter();
        this.uploadStart = new EventEmitter();
        this.filesChanged = new EventEmitter();
        this.fileRejected = new EventEmitter();
        this.menuItemClicked = new EventEmitter();
        this.downloadFail = new EventEmitter();
        this.downloadAbort = new EventEmitter();
    }
    AvlUploadDirective.prototype.ngOnInit = function () {
        var element = this.element.nativeElement;
        element.uploadService = this.uploadService;
    };
    AvlUploadDirective.prototype.uploadCompleteHandler = function (e) {
        this.uploadComplete.emit(e.detail.value);
    };
    AvlUploadDirective.prototype.uploadCanceledHandler = function (e) {
        this.uploadAbort.emit(e.detail.value);
    };
    AvlUploadDirective.prototype.uploadStartedHandler = function (e) {
        this.uploadStart.emit(e.detail.value);
    };
    AvlUploadDirective.prototype.uploadFailedHandler = function (e) {
        this.uploadFail.emit(e.detail);
    };
    AvlUploadDirective.prototype.filesChangedHandler = function (e) {
        this.filesChanged.emit(e.detail.value);
    };
    AvlUploadDirective.prototype.fileRejectedHandler = function (e) {
        this.fileRejected.emit(e.detail.value);
    };
    AvlUploadDirective.prototype.menuItemClickedHandler = function (e) {
        this.menuItemClicked.emit(e.detail);
    };
    AvlUploadDirective.prototype.downloadFailedHandler = function (e) {
        this.downloadFail.emit(e.detail);
    };
    AvlUploadDirective.prototype.downloadCanceledHandler = function (e) {
        this.downloadAbort.emit(e.detail.value);
    };
    AvlUploadDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Inject, args: [UPLOAD_SERVICE,] }] }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlUploadDirective.prototype, "uploadComplete", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlUploadDirective.prototype, "uploadAbort", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlUploadDirective.prototype, "uploadFail", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlUploadDirective.prototype, "uploadStart", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlUploadDirective.prototype, "filesChanged", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlUploadDirective.prototype, "fileRejected", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlUploadDirective.prototype, "menuItemClicked", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlUploadDirective.prototype, "downloadFail", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlUploadDirective.prototype, "downloadAbort", void 0);
    __decorate([
        HostListener('upload-complete', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlUploadDirective.prototype, "uploadCompleteHandler", null);
    __decorate([
        HostListener('upload-abort', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlUploadDirective.prototype, "uploadCanceledHandler", null);
    __decorate([
        HostListener('upload-start', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlUploadDirective.prototype, "uploadStartedHandler", null);
    __decorate([
        HostListener('upload-fail', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlUploadDirective.prototype, "uploadFailedHandler", null);
    __decorate([
        HostListener('files-changed', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlUploadDirective.prototype, "filesChangedHandler", null);
    __decorate([
        HostListener('file-rejected', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlUploadDirective.prototype, "fileRejectedHandler", null);
    __decorate([
        HostListener('menu-item-clicked', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlUploadDirective.prototype, "menuItemClickedHandler", null);
    __decorate([
        HostListener('download-fail', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlUploadDirective.prototype, "downloadFailedHandler", null);
    __decorate([
        HostListener('download-abort', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlUploadDirective.prototype, "downloadCanceledHandler", null);
    AvlUploadDirective = __decorate([ __param(1, Inject(UPLOAD_SERVICE)),
        __metadata("design:paramtypes", [ElementRef, Object])
    ], AvlUploadDirective);
AvlUploadDirective.ɵfac = function AvlUploadDirective_Factory(t) { return new (t || AvlUploadDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(UPLOAD_SERVICE)); };
AvlUploadDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlUploadDirective, selectors: [["avl-upload"]], hostBindings: function AvlUploadDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("upload-complete", function AvlUploadDirective_upload_complete_HostBindingHandler($event) { return ctx.uploadCompleteHandler($event); })("upload-abort", function AvlUploadDirective_upload_abort_HostBindingHandler($event) { return ctx.uploadCanceledHandler($event); })("upload-start", function AvlUploadDirective_upload_start_HostBindingHandler($event) { return ctx.uploadStartedHandler($event); })("upload-fail", function AvlUploadDirective_upload_fail_HostBindingHandler($event) { return ctx.uploadFailedHandler($event); })("files-changed", function AvlUploadDirective_files_changed_HostBindingHandler($event) { return ctx.filesChangedHandler($event); })("file-rejected", function AvlUploadDirective_file_rejected_HostBindingHandler($event) { return ctx.fileRejectedHandler($event); })("menu-item-clicked", function AvlUploadDirective_menu_item_clicked_HostBindingHandler($event) { return ctx.menuItemClickedHandler($event); })("download-fail", function AvlUploadDirective_download_fail_HostBindingHandler($event) { return ctx.downloadFailedHandler($event); })("download-abort", function AvlUploadDirective_download_abort_HostBindingHandler($event) { return ctx.downloadCanceledHandler($event); });
    } }, outputs: { uploadComplete: "uploadComplete", uploadAbort: "uploadAbort", uploadFail: "uploadFail", uploadStart: "uploadStart", filesChanged: "filesChanged", fileRejected: "fileRejected", menuItemClicked: "menuItemClicked", downloadFail: "downloadFail", downloadAbort: "downloadAbort" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlUploadDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-upload'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [UPLOAD_SERVICE]
            }] }]; }, { uploadComplete: [{
            type: Output
        }], uploadAbort: [{
            type: Output
        }], uploadFail: [{
            type: Output
        }], uploadStart: [{
            type: Output
        }], filesChanged: [{
            type: Output
        }], fileRejected: [{
            type: Output
        }], menuItemClicked: [{
            type: Output
        }], downloadFail: [{
            type: Output
        }], downloadAbort: [{
            type: Output
        }], uploadCompleteHandler: [{
            type: HostListener,
            args: ['upload-complete', ['$event']]
        }], uploadCanceledHandler: [{
            type: HostListener,
            args: ['upload-abort', ['$event']]
        }], uploadStartedHandler: [{
            type: HostListener,
            args: ['upload-start', ['$event']]
        }], uploadFailedHandler: [{
            type: HostListener,
            args: ['upload-fail', ['$event']]
        }], filesChangedHandler: [{
            type: HostListener,
            args: ['files-changed', ['$event']]
        }], fileRejectedHandler: [{
            type: HostListener,
            args: ['file-rejected', ['$event']]
        }], menuItemClickedHandler: [{
            type: HostListener,
            args: ['menu-item-clicked', ['$event']]
        }], downloadFailedHandler: [{
            type: HostListener,
            args: ['download-fail', ['$event']]
        }], downloadCanceledHandler: [{
            type: HostListener,
            args: ['download-abort', ['$event']]
        }] }); })();
    return AvlUploadDirective;
}());

var AvlTabBarDirective = /** @class */ (function () {
    function AvlTabBarDirective(el) {
        var _this = this;
        this.el = el;
        this.selectedIndexChange = new EventEmitter();
        this.selectedValueChange = new EventEmitter();
        this.tabBar = this.el.nativeElement;
        Promise.resolve().then(function () {
            _this.setEventListeners(el.nativeElement);
        });
    }
    AvlTabBarDirective.prototype.setEventListeners = function (el) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                el.addEventListener('selected-value-changed', function (event) {
                    Promise.resolve().then(function () {
                        _this.selectedValueChange.emit(event.detail.value);
                    });
                });
                el.addEventListener('selected-index-changed', function (event) {
                    Promise.resolve().then(function () {
                        _this.selectedIndexChange.emit(event.detail.value);
                    });
                });
                return [2 /*return*/];
            });
        });
    };
    AvlTabBarDirective.prototype.setTab = function (index, value) {
        var tabs = this.tabBar.tabs;
        for (var prop in value) {
            if (value.hasOwnProperty(prop)) {
                tabs[index][prop] = value[prop];
                this.tabBar.notifyPath("tabs." + index + "." + prop);
            }
        }
    };
    AvlTabBarDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlTabBarDirective.prototype, "selectedIndexChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlTabBarDirective.prototype, "selectedValueChange", void 0);
    AvlTabBarDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlTabBarDirective);
AvlTabBarDirective.ɵfac = function AvlTabBarDirective_Factory(t) { return new (t || AvlTabBarDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlTabBarDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlTabBarDirective, selectors: [["avl-tab-bar"]], outputs: { selectedIndexChange: "selectedIndexChange", selectedValueChange: "selectedValueChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlTabBarDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-tab-bar'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { selectedIndexChange: [{
            type: Output
        }], selectedValueChange: [{
            type: Output
        }] }); })();
    return AvlTabBarDirective;
}());

var AvlDropdownDirective = /** @class */ (function () {
    function AvlDropdownDirective(elementRef) {
        this.openChanged = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'open-changed', this.openChanged);
    }
    AvlDropdownDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlDropdownDirective.prototype, "openChanged", void 0);
    AvlDropdownDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlDropdownDirective);
AvlDropdownDirective.ɵfac = function AvlDropdownDirective_Factory(t) { return new (t || AvlDropdownDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlDropdownDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlDropdownDirective, selectors: [["avl-dropdown"]], outputs: { openChanged: "openChanged" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlDropdownDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-dropdown'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { openChanged: [{
            type: Output
        }] }); })();
    return AvlDropdownDirective;
}());

var AvlTimeDirective = /** @class */ (function () {
    function AvlTimeDirective(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
    AvlTimeDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlTimeDirective.prototype, "valueChange", void 0);
    AvlTimeDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlTimeDirective);
AvlTimeDirective.ɵfac = function AvlTimeDirective_Factory(t) { return new (t || AvlTimeDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlTimeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlTimeDirective, selectors: [["avl-time"]], outputs: { valueChange: "valueChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlTimeDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-time'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { valueChange: [{
            type: Output
        }] }); })();
    return AvlTimeDirective;
}());

var AvlListDirective = /** @class */ (function (_super) {
    __extends(AvlListDirective, _super);
    function AvlListDirective(elementRef, renderer) {
        var _this = _super.call(this, elementRef) || this;
        _this.elementRef = elementRef;
        _this.renderer = renderer;
        _this.invalidChange = new EventEmitter();
        _this.overflowMenuItemClicked = new EventEmitter();
        _this.rightCheckboxChanged = new EventEmitter();
        _this.activeRowChanged = new EventEmitter();
        _this.rowReordered = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'invalid-changed', _this.focusedChange);
        return _this;
    }
    AvlListDirective_1 = AvlListDirective;
    Object.defineProperty(AvlListDirective.prototype, "readonly", {
        // Angular writes readonly attributes to a readOnly property,
        // because that's how it's called on the native input element.
        set: function (value) {
            this.elementRef.nativeElement.readonly = value;
        },
        enumerable: true,
        configurable: true
    });
    AvlListDirective.prototype.selectedValueChanged = function (e) {
        if (this.onChangeCallback && !this.isMulti()) {
            this.onChangeCallback(e.detail.value);
        }
    };
    AvlListDirective.prototype.selectedValuesChanged = function (e) {
        if (this.onChangeCallback && this.isMulti()) {
            this.onChangeCallback(e.detail.value);
        }
    };
    AvlListDirective.prototype.overflowMenuItemClickListener = function (e) {
        this.overflowMenuItemClicked.emit(e.detail);
    };
    AvlListDirective.prototype.rightCheckboxChangeListener = function (e) {
        this.rightCheckboxChanged.emit(e.detail);
    };
    AvlListDirective.prototype.activatedRowChangeListener = function (e) {
        this.activeRowChanged.emit(e.detail.value);
    };
    AvlListDirective.prototype.rowReorderedListener = function (e) {
        this.rowReordered.emit(e.detail);
    };
    AvlListDirective.prototype.writeValue = function (value) {
        var property = this.isMulti() ? 'selectedValues' : 'selectedValue';
        this.renderer.setProperty(this.elementRef.nativeElement, property, value);
    };
    AvlListDirective.prototype.registerOnChange = function (fn) {
        this.onChangeCallback = fn;
    };
    // Since avl-list doesn't have validate-on-leave, there's no touching
    AvlListDirective.prototype.registerOnTouched = function (fn) { };
    AvlListDirective.prototype.setDisabledState = function (isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    };
    AvlListDirective.prototype.isMulti = function () {
        return (this.elementRef.nativeElement && this.elementRef.nativeElement.multi === true);
    };
    //#region Validator
    AvlListDirective.prototype.validate = function (control) {
        var formControl = this.elementRef.nativeElement;
        if (formControl.invalid) {
            return { invalid: formControl.errorMessage };
        }
        else {
            return null;
        }
    };
    var AvlListDirective_1;
    AvlListDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlListDirective.prototype, "invalidChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlListDirective.prototype, "overflowMenuItemClicked", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlListDirective.prototype, "rightCheckboxChanged", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlListDirective.prototype, "activeRowChanged", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlListDirective.prototype, "rowReordered", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], AvlListDirective.prototype, "readonly", null);
    __decorate([
        HostListener('selected-value-changed', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlListDirective.prototype, "selectedValueChanged", null);
    __decorate([
        HostListener('selected-values-changed', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlListDirective.prototype, "selectedValuesChanged", null);
    __decorate([
        HostListener('overflow-menu-item-clicked', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlListDirective.prototype, "overflowMenuItemClickListener", null);
    __decorate([
        HostListener('right-checkbox-changed', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlListDirective.prototype, "rightCheckboxChangeListener", null);
    __decorate([
        HostListener('active-row-changed', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlListDirective.prototype, "activatedRowChangeListener", null);
    __decorate([
        HostListener('row-reordered', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlListDirective.prototype, "rowReorderedListener", null);
    AvlListDirective = AvlListDirective_1 = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
    ], AvlListDirective);
AvlListDirective.ɵfac = function AvlListDirective_Factory(t) { return new (t || AvlListDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
AvlListDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlListDirective, selectors: [["avl-list"]], hostBindings: function AvlListDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("selected-value-changed", function AvlListDirective_selected_value_changed_HostBindingHandler($event) { return ctx.selectedValueChanged($event); })("selected-values-changed", function AvlListDirective_selected_values_changed_HostBindingHandler($event) { return ctx.selectedValuesChanged($event); })("overflow-menu-item-clicked", function AvlListDirective_overflow_menu_item_clicked_HostBindingHandler($event) { return ctx.overflowMenuItemClickListener($event); })("right-checkbox-changed", function AvlListDirective_right_checkbox_changed_HostBindingHandler($event) { return ctx.rightCheckboxChangeListener($event); })("active-row-changed", function AvlListDirective_active_row_changed_HostBindingHandler($event) { return ctx.activatedRowChangeListener($event); })("row-reordered", function AvlListDirective_row_reordered_HostBindingHandler($event) { return ctx.rowReorderedListener($event); });
    } }, inputs: { readonly: "readonly" }, outputs: { invalidChange: "invalidChange", overflowMenuItemClicked: "overflowMenuItemClicked", rightCheckboxChanged: "rightCheckboxChanged", activeRowChanged: "activeRowChanged", rowReordered: "rowReordered" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return AvlListDirective_1; }), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(function () { return AvlListDirective_1; }), multi: true }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlListDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-list',
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return AvlListDirective_1; }), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(function () { return AvlListDirective_1; }), multi: true }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { readonly: [{
            type: Input
        }], selectedValueChanged: [{
            type: HostListener,
            args: ['selected-value-changed', ['$event']]
        }], selectedValuesChanged: [{
            type: HostListener,
            args: ['selected-values-changed', ['$event']]
        }], overflowMenuItemClickListener: [{
            type: HostListener,
            args: ['overflow-menu-item-clicked', ['$event']]
        }], rightCheckboxChangeListener: [{
            type: HostListener,
            args: ['right-checkbox-changed', ['$event']]
        }], activatedRowChangeListener: [{
            type: HostListener,
            args: ['active-row-changed', ['$event']]
        }], rowReorderedListener: [{
            type: HostListener,
            args: ['row-reordered', ['$event']]
        }], invalidChange: [{
            type: Output
        }], overflowMenuItemClicked: [{
            type: Output
        }], rightCheckboxChanged: [{
            type: Output
        }], activeRowChanged: [{
            type: Output
        }], rowReordered: [{
            type: Output
        }] }); })();
    return AvlListDirective;
}(AvlInteractionControlDirective));

var AvlContextMenuDirective = /** @class */ (function () {
    function AvlContextMenuDirective() {
        this.itemClicked = new EventEmitter();
    }
    AvlContextMenuDirective.prototype.itemClickedListener = function (e) {
        this.itemClicked.emit(e.detail.value);
    };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlContextMenuDirective.prototype, "itemClicked", void 0);
    __decorate([
        HostListener('item-clicked', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlContextMenuDirective.prototype, "itemClickedListener", null);
AvlContextMenuDirective.ɵfac = function AvlContextMenuDirective_Factory(t) { return new (t || AvlContextMenuDirective)(); };
AvlContextMenuDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlContextMenuDirective, selectors: [["avl-context-menu"]], hostBindings: function AvlContextMenuDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("item-clicked", function AvlContextMenuDirective_item_clicked_HostBindingHandler($event) { return ctx.itemClickedListener($event); });
    } }, outputs: { itemClicked: "itemClicked" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlContextMenuDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-context-menu'
            }]
    }], function () { return []; }, { itemClicked: [{
            type: Output
        }], itemClickedListener: [{
            type: HostListener,
            args: ['item-clicked', ['$event']]
        }] }); })();
    return AvlContextMenuDirective;
}());

var AvlNumberfieldDirective = /** @class */ (function () {
    function AvlNumberfieldDirective(elementRef) {
        this.valueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'value-changed', this.valueChange);
    }
    AvlNumberfieldDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlNumberfieldDirective.prototype, "valueChange", void 0);
    AvlNumberfieldDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlNumberfieldDirective);
AvlNumberfieldDirective.ɵfac = function AvlNumberfieldDirective_Factory(t) { return new (t || AvlNumberfieldDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlNumberfieldDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlNumberfieldDirective, selectors: [["avl-numberfield"]], outputs: { valueChange: "valueChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlNumberfieldDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-numberfield'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { valueChange: [{
            type: Output
        }] }); })();
    return AvlNumberfieldDirective;
}());

var AvlIconButtonDirective = /** @class */ (function () {
    function AvlIconButtonDirective(elementRef) {
        this.badgeChange = new EventEmitter();
        this.badgeValueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'badge-changed', this.badgeChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'badge-value-changed', this.badgeValueChange);
    }
    AvlIconButtonDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlIconButtonDirective.prototype, "badgeChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlIconButtonDirective.prototype, "badgeValueChange", void 0);
    AvlIconButtonDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlIconButtonDirective);
AvlIconButtonDirective.ɵfac = function AvlIconButtonDirective_Factory(t) { return new (t || AvlIconButtonDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlIconButtonDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlIconButtonDirective, selectors: [["avl-icon-button"]], outputs: { badgeChange: "badgeChange", badgeValueChange: "badgeValueChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlIconButtonDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-icon-button'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { badgeChange: [{
            type: Output
        }], badgeValueChange: [{
            type: Output
        }] }); })();
    return AvlIconButtonDirective;
}());

var AvlDatatableDirective = /** @class */ (function () {
    function AvlDatatableDirective(elementRef) {
        this.buttonClick = new EventEmitter();
        this.overflowMenuItemClick = new EventEmitter();
        this.linkClick = new EventEmitter();
        this.pageSizeChange = new EventEmitter();
        this.selectedPageChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'page-size-changed', this.pageSizeChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-page-changed', this.selectedPageChange);
    }
    AvlDatatableDirective.prototype.buttonClickListener = function (e) {
        this.buttonClick.emit(e.detail);
    };
    AvlDatatableDirective.prototype.overflowMenuItemClickListener = function (e) {
        this.overflowMenuItemClick.emit(e.detail);
    };
    AvlDatatableDirective.prototype.linkClickListener = function (e) {
        this.linkClick.emit(e.detail);
    };
    AvlDatatableDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlDatatableDirective.prototype, "buttonClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlDatatableDirective.prototype, "overflowMenuItemClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlDatatableDirective.prototype, "linkClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlDatatableDirective.prototype, "pageSizeChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlDatatableDirective.prototype, "selectedPageChange", void 0);
    __decorate([
        HostListener('button-click', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlDatatableDirective.prototype, "buttonClickListener", null);
    __decorate([
        HostListener('overflow-menu-item-click', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlDatatableDirective.prototype, "overflowMenuItemClickListener", null);
    __decorate([
        HostListener('link-click', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlDatatableDirective.prototype, "linkClickListener", null);
    AvlDatatableDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlDatatableDirective);
AvlDatatableDirective.ɵfac = function AvlDatatableDirective_Factory(t) { return new (t || AvlDatatableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlDatatableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlDatatableDirective, selectors: [["avl-datatable"]], hostBindings: function AvlDatatableDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("button-click", function AvlDatatableDirective_button_click_HostBindingHandler($event) { return ctx.buttonClickListener($event); })("overflow-menu-item-click", function AvlDatatableDirective_overflow_menu_item_click_HostBindingHandler($event) { return ctx.overflowMenuItemClickListener($event); })("link-click", function AvlDatatableDirective_link_click_HostBindingHandler($event) { return ctx.linkClickListener($event); });
    } }, outputs: { buttonClick: "buttonClick", overflowMenuItemClick: "overflowMenuItemClick", linkClick: "linkClick", pageSizeChange: "pageSizeChange", selectedPageChange: "selectedPageChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlDatatableDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-datatable'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { buttonClick: [{
            type: Output
        }], overflowMenuItemClick: [{
            type: Output
        }], linkClick: [{
            type: Output
        }], pageSizeChange: [{
            type: Output
        }], selectedPageChange: [{
            type: Output
        }], buttonClickListener: [{
            type: HostListener,
            args: ['button-click', ['$event']]
        }], overflowMenuItemClickListener: [{
            type: HostListener,
            args: ['overflow-menu-item-click', ['$event']]
        }], linkClickListener: [{
            type: HostListener,
            args: ['link-click', ['$event']]
        }] }); })();
    return AvlDatatableDirective;
}());

var AvlSnackbarDirective = /** @class */ (function () {
    function AvlSnackbarDirective() {
        this.buttonClicked = new EventEmitter();
        this.displayedChange = new EventEmitter();
    }
    AvlSnackbarDirective.prototype.buttonClickedHandler = function (e) {
        this.buttonClicked.emit(e.detail.value);
    };
    AvlSnackbarDirective.prototype.displayedChangeHandler = function (e) {
        this.displayedChange.emit(e.detail.value);
    };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlSnackbarDirective.prototype, "buttonClicked", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlSnackbarDirective.prototype, "displayedChange", void 0);
    __decorate([
        HostListener('button-clicked', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlSnackbarDirective.prototype, "buttonClickedHandler", null);
    __decorate([
        HostListener('displayed-changed', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlSnackbarDirective.prototype, "displayedChangeHandler", null);
AvlSnackbarDirective.ɵfac = function AvlSnackbarDirective_Factory(t) { return new (t || AvlSnackbarDirective)(); };
AvlSnackbarDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlSnackbarDirective, selectors: [["avl-snackbar"]], hostBindings: function AvlSnackbarDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("button-clicked", function AvlSnackbarDirective_button_clicked_HostBindingHandler($event) { return ctx.buttonClickedHandler($event); })("displayed-changed", function AvlSnackbarDirective_displayed_changed_HostBindingHandler($event) { return ctx.displayedChangeHandler($event); });
    } }, outputs: { buttonClicked: "buttonClicked", displayedChange: "displayedChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlSnackbarDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-snackbar'
            }]
    }], function () { return []; }, { buttonClicked: [{
            type: Output
        }], displayedChange: [{
            type: Output
        }], buttonClickedHandler: [{
            type: HostListener,
            args: ['button-clicked', ['$event']]
        }], displayedChangeHandler: [{
            type: HostListener,
            args: ['displayed-changed', ['$event']]
        }] }); })();
    return AvlSnackbarDirective;
}());

/** Directive for controls implementing [AvlCheckableControl]. */
var AvlCheckableControlDirective = /** @class */ (function () {
    function AvlCheckableControlDirective(elementRef) {
        this.checkedChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'checked-changed', this.checkedChange);
    }
    AvlCheckableControlDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlCheckableControlDirective.prototype, "checkedChange", void 0);
    AvlCheckableControlDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlCheckableControlDirective);
AvlCheckableControlDirective.ɵfac = function AvlCheckableControlDirective_Factory(t) { return new (t || AvlCheckableControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlCheckableControlDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlCheckableControlDirective, selectors: [["avl-checkbox"], ["avl-radio-button"], ["avl-icon-toggle"], ["avl-switch"]], outputs: { checkedChange: "checkedChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlCheckableControlDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-checkbox,avl-radio-button, avl-icon-toggle, avl-switch'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { checkedChange: [{
            type: Output
        }] }); })();
    return AvlCheckableControlDirective;
}());

/** Directive for controls implementing [AvlMultiSelectControl]. */
var AvlMultiSelectControlDirective = /** @class */ (function () {
    function AvlMultiSelectControlDirective(elementRef) {
        this.selectedIndexesChange = new EventEmitter();
        this.selectedValuesChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-indexes-changed', this.selectedIndexesChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-values-changed', this.selectedValuesChange);
    }
    AvlMultiSelectControlDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlMultiSelectControlDirective.prototype, "selectedIndexesChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlMultiSelectControlDirective.prototype, "selectedValuesChange", void 0);
    AvlMultiSelectControlDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlMultiSelectControlDirective);
AvlMultiSelectControlDirective.ɵfac = function AvlMultiSelectControlDirective_Factory(t) { return new (t || AvlMultiSelectControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlMultiSelectControlDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlMultiSelectControlDirective, selectors: [["avl-datatable"], ["avl-list"], ["avl-chip-list"], ["avl-chip-input"]], outputs: { selectedIndexesChange: "selectedIndexesChange", selectedValuesChange: "selectedValuesChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlMultiSelectControlDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-datatable,avl-list,avl-chip-list, avl-chip-input'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { selectedIndexesChange: [{
            type: Output
        }], selectedValuesChange: [{
            type: Output
        }] }); })();
    return AvlMultiSelectControlDirective;
}());

/** Directive for controls implementing [AvlSingleSelectControl]. */
var AvlSingleSelectControlDirective = /** @class */ (function () {
    function AvlSingleSelectControlDirective(elementRef) {
        this.selectedIndexChange = new EventEmitter();
        this.selectedValueChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-index-changed', this.selectedIndexChange);
        addEventListenerForEmittingChangedEvents(elementRef, 'selected-value-changed', this.selectedValueChange);
    }
    AvlSingleSelectControlDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlSingleSelectControlDirective.prototype, "selectedIndexChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlSingleSelectControlDirective.prototype, "selectedValueChange", void 0);
    AvlSingleSelectControlDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlSingleSelectControlDirective);
AvlSingleSelectControlDirective.ɵfac = function AvlSingleSelectControlDirective_Factory(t) { return new (t || AvlSingleSelectControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlSingleSelectControlDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlSingleSelectControlDirective, selectors: [["avl-datatable"], ["avl-dropdown"], ["avl-list"], ["avl-radio-group"], ["avl-app-switcher"], ["avl-chip-list"], ["avl-combo-box"]], outputs: { selectedIndexChange: "selectedIndexChange", selectedValueChange: "selectedValueChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlSingleSelectControlDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-datatable,avl-dropdown,avl-list,avl-radio-group,avl-app-switcher,avl-chip-list,avl-combo-box'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { selectedIndexChange: [{
            type: Output
        }], selectedValueChange: [{
            type: Output
        }] }); })();
    return AvlSingleSelectControlDirective;
}());

// Defines which property is used as the 'value' for the ControlValueAccessor
var valuePropertyNameMap = {
    // TODO: is there a nameof function is typescript?
    'avl-checkbox': 'checked',
    'avl-date': 'value',
    'avl-dropdown': 'selectedValue',
    'avl-time': 'value',
    'avl-numberfield': 'value',
    'avl-radio-group': 'selectedValue',
    'avl-slider': 'value',
    'avl-textarea': 'value',
    'avl-textfield': 'value',
    'avl-timespan': 'value',
    'avl-chip-list': 'selectedValue',
    'avl-chip-input': 'selectedValues',
    'avl-upload': 'files',
    'avl-search-bar': 'query',
    'avl-icon-toggle': 'checked',
    'avl-switch': 'checked'
};
/** Directive for controls implementing [AvlFormControl]. */
var AvlFormControlDirective = /** @class */ (function (_super) {
    __extends(AvlFormControlDirective, _super);
    function AvlFormControlDirective(elementRef, renderer) {
        var _this = _super.call(this, elementRef) || this;
        _this.elementRef = elementRef;
        _this.renderer = renderer;
        _this.writeValueAlreadyCalled = false;
        //#endregion
        //#region AvlFormControl
        // tslint:disable-next-line:member-ordering
        _this.invalidChange = new EventEmitter();
        var controlTag = _this.elementRef.nativeElement.tagName.toLowerCase();
        _this.valuePropertyName = valuePropertyNameMap[controlTag];
        return _this;
    }
    AvlFormControlDirective_1 = AvlFormControlDirective;
    Object.defineProperty(AvlFormControlDirective.prototype, "readonly", {
        // Angular writes readonly attributes to a readOnly property,
        // because that's how it's called on the native input element.
        set: function (value) {
            if (typeof value === 'boolean') {
                this.elementRef.nativeElement.readonly = value;
            }
            else {
                this.elementRef.nativeElement.readonly = value != null;
            }
        },
        enumerable: true,
        configurable: true
    });
    AvlFormControlDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.unlistenPropertyChangedEvent =
            this.renderer.listen(this.elementRef.nativeElement, this.toKebabCase(this.valuePropertyName) + "-changed", function (e) {
                if (_this.onChangeCallback) {
                    _this.onChangeCallback(e.detail.value);
                }
            });
    };
    AvlFormControlDirective.prototype.ngOnDestroy = function () {
        if (this.unlistenPropertyChangedEvent) {
            this.unlistenPropertyChangedEvent();
        }
    };
    AvlFormControlDirective.prototype.writeValue = function (value) {
        // Because of a bug in Angular writeValue sometimes gets called with a null before being called with the real value,
        // so the null is discarded.
        // TODO: remove when issue is fixed: https://github.com/angular/angular/issues/14988
        if (!this.writeValueAlreadyCalled && value == null) {
            this.writeValueAlreadyCalled = true;
            return;
        }
        this.renderer.setProperty(this.elementRef.nativeElement, this.valuePropertyName, value);
        this.writeValueAlreadyCalled = true;
    };
    AvlFormControlDirective.prototype.registerOnChange = function (fn) {
        this.onChangeCallback = fn;
    };
    AvlFormControlDirective.prototype.registerOnTouched = function (fn) {
        this.onTouchedCallback = fn;
    };
    AvlFormControlDirective.prototype.setDisabledState = function (isDisabled) {
        this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
    };
    AvlFormControlDirective.prototype.onBlur = function () {
        if (this.onTouchedCallback) {
            this.onTouchedCallback();
        }
    };
    AvlFormControlDirective.prototype.onFocusedChanged = function (focused) {
        if (!focused && this.onTouchedCallback) {
            this.onTouchedCallback();
        }
    };
    AvlFormControlDirective.prototype.toKebabCase = function (camelCaseString) {
        return camelCaseString.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    };
    AvlFormControlDirective.prototype.invalidChanged = function (e) {
        this.invalidChange.emit(e.detail.value);
        // Trigger validation
        if (this.onChangeCallback) {
            this.onChangeCallback(this.elementRef.nativeElement[this.valuePropertyName]);
        }
    };
    //#endregion
    //#region Validator
    AvlFormControlDirective.prototype.validate = function (control) {
        var formControl = this.elementRef.nativeElement;
        if (formControl.invalid) {
            return { invalid: formControl.errorMessage };
        }
        else {
            return null;
        }
    };
    var AvlFormControlDirective_1;
    AvlFormControlDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], AvlFormControlDirective.prototype, "readonly", null);
    __decorate([
        HostListener('blur'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], AvlFormControlDirective.prototype, "onBlur", null);
    __decorate([
        HostListener('focused-changed', ['$event.detail.value']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], AvlFormControlDirective.prototype, "onFocusedChanged", null);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlFormControlDirective.prototype, "invalidChange", void 0);
    __decorate([
        HostListener('invalid-changed', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [CustomEvent]),
        __metadata("design:returntype", void 0)
    ], AvlFormControlDirective.prototype, "invalidChanged", null);
    AvlFormControlDirective = AvlFormControlDirective_1 = __decorate([ __metadata("design:paramtypes", [ElementRef, Renderer2])
    ], AvlFormControlDirective);
AvlFormControlDirective.ɵfac = function AvlFormControlDirective_Factory(t) { return new (t || AvlFormControlDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
AvlFormControlDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlFormControlDirective, selectors: [["avl-date"], ["avl-dropdown"], ["avl-time"], ["avl-icon-toggle"], ["avl-numberfield"], ["avl-radio-group"], ["avl-slider"], ["avl-textarea"], ["avl-textfield"], ["avl-timespan"], ["avl-checkbox"], ["avl-switch"], ["avl-chip-list"], ["avl-upload"], ["avl-search-bar"], ["avl-chip-input"]], hostBindings: function AvlFormControlDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("blur", function AvlFormControlDirective_blur_HostBindingHandler() { return ctx.onBlur(); })("focused-changed", function AvlFormControlDirective_focused_changed_HostBindingHandler($event) { return ctx.onFocusedChanged($event.detail.value); })("invalid-changed", function AvlFormControlDirective_invalid_changed_HostBindingHandler($event) { return ctx.invalidChanged($event); });
    } }, inputs: { readonly: "readonly" }, outputs: { invalidChange: "invalidChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return AvlFormControlDirective_1; }), multi: true },
            { provide: NG_VALIDATORS, useExisting: forwardRef(function () { return AvlFormControlDirective_1; }), multi: true }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlFormControlDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-date,avl-dropdown,avl-time,avl-icon-toggle,avl-numberfield,avl-radio-group,avl-slider,avl-textarea,avl-textfield,avl-timespan,avl-checkbox,avl-switch,avl-chip-list,avl-upload,avl-search-bar,avl-chip-input',
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return AvlFormControlDirective_1; }), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef(function () { return AvlFormControlDirective_1; }), multi: true }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { readonly: [{
            type: Input
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }], onFocusedChanged: [{
            type: HostListener,
            args: ['focused-changed', ['$event.detail.value']]
        }], invalidChanged: [{
            type: HostListener,
            args: ['invalid-changed', ['$event']]
        }], invalidChange: [{
            type: Output
        }] }); })();
    return AvlFormControlDirective;
}(AvlInteractionControlDirective));

var UploadService = /** @class */ (function () {
    function UploadService(httpClient) {
        this.httpClient = httpClient;
    }
    UploadService.prototype.downloadFile = function (url, progressCallback, completeCallback, failCallback) {
        var req = this.httpClient.get(url, { reportProgress: true, responseType: "blob", observe: 'events' })
            .pipe(map(function (event) {
            if (event.type === HttpEventType.DownloadProgress) {
                progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback(event);
            }
            if (event.type === HttpEventType.Response && event.body != null) {
                completeCallback === null || completeCallback === void 0 ? void 0 : completeCallback(event.body);
            }
        }), catchError(function (err) {
            var response = err.error instanceof Event ? err.error.target.response : err.error;
            if (failCallback)
                failCallback({
                    status: err.status,
                    response: response
                });
            return of(null);
        }));
        var subscription = req.subscribe();
        return subscription.unsubscribe.bind(subscription);
    };
    UploadService.prototype.uploadFile = function (file, target, progressCallback, completeCallback, failCallback) {
        var formData = new FormData();
        formData.append('file', file.file);
        var uploadReq = this.httpClient.post(target, formData, { reportProgress: true, observe: 'events' })
            .pipe(map(function (event) {
            if (event.type === HttpEventType.UploadProgress) {
                progressCallback === null || progressCallback === void 0 ? void 0 : progressCallback(event);
            }
            if (event.type === HttpEventType.Response) {
                if (event.body != null && event.body.downloadUrl) {
                    completeCallback === null || completeCallback === void 0 ? void 0 : completeCallback(event.body.downloadUrl);
                }
                else {
                    completeCallback === null || completeCallback === void 0 ? void 0 : completeCallback();
                }
            }
        }), catchError(function (err, caught) {
            var response = err.error instanceof Event ? err.error.target.response : err.error;
            if (failCallback)
                failCallback({
                    status: err.status,
                    response: response
                });
            return of(null);
        }));
        var subscription = uploadReq.subscribe();
        return subscription.unsubscribe.bind(subscription);
    };
    UploadService.ctorParameters = function () { return [
        { type: HttpClient }
    ]; };
    UploadService = __decorate([ __metadata("design:paramtypes", [HttpClient])
    ], UploadService);
UploadService.ɵfac = function UploadService_Factory(t) { return new (t || UploadService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient)); };
UploadService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: UploadService, factory: function (t) { return UploadService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UploadService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.HttpClient }]; }, null); })();
    return UploadService;
}());

var AvlStepProgressDirective = /** @class */ (function () {
    function AvlStepProgressDirective(elementRef) {
        this.activeChange = new EventEmitter();
        addEventListenerForEmittingChangedEvents(elementRef, 'active-changed', this.activeChange);
    }
    AvlStepProgressDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], AvlStepProgressDirective.prototype, "activeChange", void 0);
    AvlStepProgressDirective = __decorate([ __metadata("design:paramtypes", [ElementRef])
    ], AvlStepProgressDirective);
AvlStepProgressDirective.ɵfac = function AvlStepProgressDirective_Factory(t) { return new (t || AvlStepProgressDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
AvlStepProgressDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AvlStepProgressDirective, selectors: [["avl-step-progress"]], outputs: { activeChange: "activeChange" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlStepProgressDirective, [{
        type: Directive,
        args: [{
                selector: 'avl-step-progress'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { activeChange: [{
            type: Output
        }] }); })();
    return AvlStepProgressDirective;
}());

var binders = [
    AvlBreadcrumbDirective,
    AvlOverflowMenuDirective,
    AvlSearchBarDirective,
    AvlTextareaDirective,
    AvlDateDirective,
    AvlSideSheetDirective,
    AvlTextfieldDirective,
    AvlTimespanDirective,
    AvlCheckableControlDirective,
    AvlControlDirective,
    AvlFormControlDirective,
    AvlInteractionControlDirective,
    AvlMultiSelectControlDirective,
    AvlSingleSelectControlDirective,
    AvlDropdownDirective,
    AvlTimeDirective,
    AvlListDirective,
    AvlUploadDirective,
    AvlContextMenuDirective,
    AvlNumberfieldDirective,
    AvlCheckboxDirective,
    AvlDatatableDirective,
    AvlComboBoxDirective,
    AvlTabBarDirective,
    AvlSnackbarDirective,
    AvlStepProgressDirective,
    AvlIconButtonDirective,
];
var AvlNgBindersModule = /** @class */ (function () {
    function AvlNgBindersModule() {
    }
AvlNgBindersModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AvlNgBindersModule });
AvlNgBindersModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AvlNgBindersModule_Factory(t) { return new (t || AvlNgBindersModule)(); }, providers: [
        { provide: UPLOAD_SERVICE, useClass: UploadService }
    ], imports: [[
            CommonModule,
            FormsModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AvlNgBindersModule, { declarations: function () { return [AvlBreadcrumbDirective,
        AvlOverflowMenuDirective,
        AvlSearchBarDirective,
        AvlTextareaDirective,
        AvlDateDirective,
        AvlSideSheetDirective,
        AvlTextfieldDirective,
        AvlTimespanDirective,
        AvlCheckableControlDirective,
        AvlControlDirective,
        AvlFormControlDirective,
        AvlInteractionControlDirective,
        AvlMultiSelectControlDirective,
        AvlSingleSelectControlDirective,
        AvlDropdownDirective,
        AvlTimeDirective,
        AvlListDirective,
        AvlUploadDirective,
        AvlContextMenuDirective,
        AvlNumberfieldDirective,
        AvlCheckboxDirective,
        AvlDatatableDirective,
        AvlComboBoxDirective,
        AvlTabBarDirective,
        AvlSnackbarDirective,
        AvlStepProgressDirective,
        AvlIconButtonDirective]; }, imports: function () { return [CommonModule,
        FormsModule]; }, exports: function () { return [AvlBreadcrumbDirective,
        AvlOverflowMenuDirective,
        AvlSearchBarDirective,
        AvlTextareaDirective,
        AvlDateDirective,
        AvlSideSheetDirective,
        AvlTextfieldDirective,
        AvlTimespanDirective,
        AvlCheckableControlDirective,
        AvlControlDirective,
        AvlFormControlDirective,
        AvlInteractionControlDirective,
        AvlMultiSelectControlDirective,
        AvlSingleSelectControlDirective,
        AvlDropdownDirective,
        AvlTimeDirective,
        AvlListDirective,
        AvlUploadDirective,
        AvlContextMenuDirective,
        AvlNumberfieldDirective,
        AvlCheckboxDirective,
        AvlDatatableDirective,
        AvlComboBoxDirective,
        AvlTabBarDirective,
        AvlSnackbarDirective,
        AvlStepProgressDirective,
        AvlIconButtonDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AvlNgBindersModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule
                ],
                declarations: __spread(binders),
                exports: __spread(binders),
                providers: [
                    { provide: UPLOAD_SERVICE, useClass: UploadService }
                ]
            }]
    }], function () { return []; }, null); })();
    return AvlNgBindersModule;
}());

var NgxTranslateTranslationService = /** @class */ (function () {
    function NgxTranslateTranslationService(translateService) {
        this.translateService = translateService;
    }
    Object.defineProperty(NgxTranslateTranslationService.prototype, "language", {
        get: function () {
            return this.translateService.currentLang;
        },
        enumerable: true,
        configurable: true
    });
    NgxTranslateTranslationService.prototype.translate = function (key, interpolateParams) {
        return this.translateService.get(key, interpolateParams).toPromise();
    };
    NgxTranslateTranslationService.ctorParameters = function () { return [
        { type: TranslateService }
    ]; };
    NgxTranslateTranslationService = __decorate([ __metadata("design:paramtypes", [TranslateService])
    ], NgxTranslateTranslationService);
NgxTranslateTranslationService.ɵfac = function NgxTranslateTranslationService_Factory(t) { return new (t || NgxTranslateTranslationService)(ɵngcc0.ɵɵinject(ɵngcc2.TranslateService)); };
NgxTranslateTranslationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NgxTranslateTranslationService, factory: function (t) { return NgxTranslateTranslationService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxTranslateTranslationService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc2.TranslateService }]; }, null); })();
    return NgxTranslateTranslationService;
}());

/*
 * Public API Surface of ng-binders
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AvlBreadcrumbDirective, AvlCheckableControlDirective, AvlCheckboxDirective, AvlComboBoxDirective, AvlContextMenuDirective, AvlControlDirective, AvlDatatableDirective, AvlDateDirective, AvlDropdownDirective, AvlFormControlDirective, AvlIconButtonDirective, AvlInteractionControlDirective, AvlListDirective, AvlMultiSelectControlDirective, AvlNgBindersModule, AvlNumberfieldDirective, AvlOverflowMenuDirective, AvlSearchBarDirective, AvlSideSheetDirective, AvlSingleSelectControlDirective, AvlSnackbarDirective, AvlTabBarDirective, AvlTextareaDirective, AvlTextfieldDirective, AvlTimeDirective, AvlTimespanDirective, AvlUploadDirective, NgxTranslateTranslationService, UPLOAD_SERVICE, UploadService, AvlStepProgressDirective as ɵa };

//# sourceMappingURL=avl-controls-ng-binders.js.map